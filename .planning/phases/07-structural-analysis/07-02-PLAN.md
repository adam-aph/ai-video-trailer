---
phase: 07-structural-analysis
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/cinecut/inference/text_engine.py
  - src/cinecut/inference/structural.py
  - src/cinecut/manifest/schema.py
  - src/cinecut/checkpoint.py
  - src/cinecut/cli.py
  - tests/test_structural.py
autonomous: true
requirements: [IINF-04, STRC-01, STRC-03]

must_haves:
  truths:
    - "Running cinecut against a film with Mistral GGUF present produces BEGIN_T, ESCALATION_T, CLIMAX_T timestamps printed to console and stored in manifest"
    - "When Mistral GGUF is absent, pipeline continues using 5%/45%/80% heuristic fallback — logs yellow warning, does not abort"
    - "Generated TRAILER_MANIFEST.json has schema_version = '2.0' and a structural_anchors block with begin_t, escalation_t, climax_t, source"
    - "Old v1.0 manifests still load without error (backward-compatible schema extension)"
    - "Subtitle corpus is processed in chunks of 75 events; LLM sees absolute film timestamps"
  artifacts:
    - path: "src/cinecut/inference/structural.py"
      provides: "run_structural_analysis(), compute_heuristic_anchors(), subtitle chunking"
      exports: ["run_structural_analysis", "compute_heuristic_anchors", "CHUNK_SIZE"]
    - path: "src/cinecut/inference/text_engine.py"
      provides: "analyze_chunk() added to TextEngine"
      contains: "def analyze_chunk"
    - path: "src/cinecut/manifest/schema.py"
      provides: "StructuralAnchors model, TrailerManifest.structural_anchors field, schema_version '2.0'"
      contains: "class StructuralAnchors"
    - path: "src/cinecut/checkpoint.py"
      provides: "PipelineCheckpoint.structural_anchors field, proxy_duration_s field"
      contains: "structural_anchors"
    - path: "src/cinecut/cli.py"
      provides: "Stage 5 structural analysis gate; TOTAL_STAGES=8; duration extraction in Stage 1"
      contains: "Stage 5"
    - path: "tests/test_structural.py"
      provides: "Unit tests for structural.py functions (no live LLM)"
      min_lines: 60
  key_links:
    - from: "src/cinecut/cli.py Stage 5"
      to: "src/cinecut/inference/structural.py compute_heuristic_anchors"
      via: "called when text_model_path.exists() is False"
      pattern: "compute_heuristic_anchors"
    - from: "src/cinecut/cli.py Stage 5"
      to: "src/cinecut/inference/text_engine.py TextEngine"
      via: "with TextEngine(mistral_path) as text_engine: run_structural_analysis(...)"
      pattern: "TextEngine\\(mistral_path\\)"
    - from: "src/cinecut/narrative/generator.py run_narrative_stage"
      to: "src/cinecut/manifest/schema.py TrailerManifest"
      via: "TrailerManifest instantiation now includes structural_anchors=... kwarg from checkpoint"
      pattern: "structural_anchors"
---

<objective>
Implement structural analysis: subtitle chunking + Mistral inference + heuristic fallback + manifest v2.0 schema bump + Stage 5 in cli.py.

Purpose: This plan completes Phase 7. After 07-01 provides TextEngine and get_models_dir, this plan adds the analysis logic (structural.py), the analyze_chunk method on TextEngine, the StructuralAnchors model in schema.py, checkpoint fields, and wires everything into cli.py as a new Stage 5. The manifest schema bumps from "1.0" to "2.0" with the structural_anchors block.

Output:
- src/cinecut/inference/structural.py (new)
- src/cinecut/inference/text_engine.py (analyze_chunk method added)
- src/cinecut/manifest/schema.py (StructuralAnchors + TrailerManifest.structural_anchors + schema_version bump)
- src/cinecut/checkpoint.py (structural_anchors + proxy_duration_s fields added)
- src/cinecut/cli.py (Stage 5 inserted, TOTAL_STAGES=8, duration captured in Stage 1)
- tests/test_structural.py (unit tests — no live LLM)
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-structural-analysis/07-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/cinecut/models.py (DialogueEvent — input to structural analysis):
```python
@dataclass
class DialogueEvent:
    start_ms: int
    end_ms: int
    start_s: float      # absolute film timestamp — USE THIS in chunk formatting
    end_s: float
    midpoint_s: float
    text: str
    emotion: str
```

From src/cinecut/manifest/schema.py (existing TrailerManifest to extend):
```python
class ClipEntry(BaseModel):
    source_start_s: float
    source_end_s: float
    beat_type: Literal[...]
    act: Literal[...]
    transition: Literal[...] = "hard_cut"
    dialogue_excerpt: str = ""
    reasoning: Optional[str] = None
    visual_analysis: Optional[str] = None
    subtitle_analysis: Optional[str] = None
    money_shot_score: Optional[float] = None

class TrailerManifest(BaseModel):
    schema_version: str = "1.0"   # BUMP TO "2.0" — keep as str, NOT Literal
    source_file: str
    vibe: str
    clips: list[ClipEntry] = Field(min_length=1)
    # ADD: structural_anchors: Optional[StructuralAnchors] = None
```

From src/cinecut/checkpoint.py (existing PipelineCheckpoint to extend):
```python
@dataclass
class PipelineCheckpoint:
    source_file: str
    vibe: str
    stages_complete: list[str] = field(default_factory=list)
    proxy_path: Optional[str] = None
    keyframe_count: Optional[int] = None
    dialogue_event_count: Optional[int] = None
    inference_complete: Optional[bool] = None
    cache_hit: Optional[bool] = None
    manifest_path: Optional[str] = None
    assembly_manifest_path: Optional[str] = None
    # ADD: proxy_duration_s: Optional[float] = None
    # ADD: structural_anchors: Optional[dict] = None  (same pattern as cache_hit)
```

From src/cinecut/narrative/signals.py (reuse for duration):
```python
def get_film_duration_s(source_file: Path) -> float:
    """Return film duration in seconds via ffprobe JSON format."""
    # runs: ffprobe -v quiet -print_format json -show_format <file>
```

From src/cinecut/inference/text_engine.py (created in 07-01):
```python
MISTRAL_GGUF_NAME = "mistral-7b-instruct-v0.3.Q4_K_M.gguf"
def get_models_dir() -> Path: ...
class TextEngine:
    def __init__(self, model_path: Path, port: int = 8090, debug: bool = False) -> None
    def __enter__(self) -> "TextEngine"
    def __exit__(self, *_) -> None
    # analyze_chunk() ADDED BY THIS PLAN — not yet present
```

From src/cinecut/cli.py (current stage count and imports to update):
```python
TOTAL_STAGES = 7   # BUMP TO 8

# Stage 4 ends with save_checkpoint(ckpt, work_dir) then
# # --- Stage 5/7: Narrative beat extraction ...
# INSERT new Stage 5 (structural) BEFORE the existing "Stage 5" narrative block
# Renumber old Stage 5 → Stage 6, old Stage 6 → Stage 7, old Stage 7 → Stage 8
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inference/structural.py and add analyze_chunk to TextEngine</name>
  <files>
    src/cinecut/inference/structural.py
    src/cinecut/inference/text_engine.py
  </files>
  <action>
**Part A — Create src/cinecut/inference/structural.py:**

```python
"""Structural analysis: subtitle chunking + LLM anchor extraction + heuristic fallback."""
import statistics
from typing import TYPE_CHECKING

from cinecut.models import DialogueEvent

if TYPE_CHECKING:
    from cinecut.inference.text_engine import TextEngine

CHUNK_SIZE = 75  # midpoint of 50-100 requirement range; ~1500 tokens per chunk

STRUCTURAL_ANCHORS_SCHEMA: dict = {
    "type": "object",
    "properties": {
        "begin_t": {"type": "number", "description": "timestamp in seconds where narrative begins"},
        "escalation_t": {"type": "number", "description": "timestamp in seconds of escalation"},
        "climax_t": {"type": "number", "description": "timestamp in seconds of climax"},
    },
    "required": ["begin_t", "escalation_t", "climax_t"],
    "additionalProperties": False,
}
```

Then implement these functions:

`_format_subtitle_chunk(events: list[DialogueEvent]) -> str`
- Format as `"[{ev.start_s:.1f}s] {ev.text}\n"` for each event
- Joined with newlines
- Always use absolute start_s — do NOT normalize to 0

`_chunk_events(events: list[DialogueEvent]) -> list[list[DialogueEvent]]`
- `return [events[i:i + CHUNK_SIZE] for i in range(0, len(events), CHUNK_SIZE)]`

`_clamp_anchors_to_chunk(result: dict, chunk: list[DialogueEvent]) -> dict | None`
- Get chunk_start = chunk[0].start_s, chunk_end = chunk[-1].end_s
- If any of begin_t, escalation_t, climax_t is outside [chunk_start - 10, chunk_end + 10], return None
- Return result unchanged if all values are within range
- This prevents hallucinated timestamps outside the chunk from polluting the median

`compute_heuristic_anchors(duration_s: float) -> "StructuralAnchors"`
- Import StructuralAnchors inline to avoid circular import: `from cinecut.manifest.schema import StructuralAnchors`
- Returns `StructuralAnchors(begin_t=round(duration_s * 0.05, 2), escalation_t=round(duration_s * 0.45, 2), climax_t=round(duration_s * 0.80, 2), source="heuristic")`

`run_structural_analysis(dialogue_events: list[DialogueEvent], engine: "TextEngine") -> "StructuralAnchors"`
- Import StructuralAnchors inline: `from cinecut.manifest.schema import StructuralAnchors`
- Chunk events with `_chunk_events`
- For each chunk: format text, call `engine.analyze_chunk(chunk_text)`, clamp result, append valid results
- After all chunks: if no valid results, derive from first/last event timestamps using heuristic ratios with source="heuristic"
- If 1+ results: return `StructuralAnchors(begin_t=round(statistics.median([r["begin_t"] for r in results]), 2), escalation_t=round(statistics.median([r["escalation_t"] for r in results]), 2), climax_t=round(statistics.median([r["climax_t"] for r in results]), 2), source="llm")`

**Part B — Add analyze_chunk to TextEngine in text_engine.py:**

Add this method to the TextEngine class (after __exit__ or at end of class):

```python
def analyze_chunk(self, chunk_text: str, timeout_s: float = 60.0) -> dict | None:
    """Submit one subtitle chunk for structural anchor extraction.

    Returns dict with begin_t, escalation_t, climax_t (floats, absolute seconds)
    or None on any failure. Never raises — pipeline continues if chunks fail.
    Uses json_schema constrained generation (same pattern as LlavaEngine.describe_frame).
    """
    from cinecut.inference.structural import STRUCTURAL_ANCHORS_SCHEMA

    payload = {
        "temperature": 0.1,
        "max_tokens": 128,
        "json_schema": STRUCTURAL_ANCHORS_SCHEMA,
        "messages": [{
            "role": "user",
            "content": (
                "You are a film narrative analyst. Given the subtitle transcript below, "
                "identify the three narrative anchor timestamps (in seconds):\n"
                "- begin_t: when the story truly begins (inciting incident or first conflict)\n"
                "- escalation_t: when tension escalates significantly\n"
                "- climax_t: when the climax or peak emotional moment occurs\n\n"
                "Respond with a JSON object only.\n\n"
                f"TRANSCRIPT:\n{chunk_text}"
            ),
        }],
    }
    try:
        r = requests.post(
            f"{self.base_url}/v1/chat/completions",
            json=payload,
            timeout=timeout_s,
        )
        r.raise_for_status()
        content = r.json()["choices"][0]["message"]["content"]
        return json.loads(content.strip())
    except (requests.RequestException, KeyError, IndexError, json.JSONDecodeError):
        return None
```

Note: `requests` and `json` are already imported at the top of text_engine.py.
The endpoint is `/v1/chat/completions` — NOT `/chat/completions` (LlavaEngine uses the shorter path; for text use the full OpenAI-compatible path per research pitfall 1).
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "from cinecut.inference.structural import run_structural_analysis, compute_heuristic_anchors, CHUNK_SIZE; a = compute_heuristic_anchors(7200.0); assert a.begin_t == 360.0; assert a.escalation_t == 3240.0; assert a.source == 'heuristic'; print('heuristic OK:', a)"</automated>
  </verify>
  <done>structural.py importable; compute_heuristic_anchors(7200) returns begin_t=360.0, escalation_t=3240.0, climax_t=5760.0, source="heuristic"; TextEngine.analyze_chunk method exists; STRUCTURAL_ANCHORS_SCHEMA exported</done>
</task>

<task type="auto">
  <name>Task 2: Add StructuralAnchors to manifest/schema.py, extend checkpoint.py, wire Stage 5 in cli.py</name>
  <files>
    src/cinecut/manifest/schema.py
    src/cinecut/checkpoint.py
    src/cinecut/cli.py
  </files>
  <action>
**Part A — manifest/schema.py:**

Add `StructuralAnchors` class BEFORE `ClipEntry`:
```python
class StructuralAnchors(BaseModel):
    begin_t: float = Field(ge=0.0, description="BEGIN narrative anchor timestamp (seconds)")
    escalation_t: float = Field(ge=0.0, description="ESCALATION narrative anchor timestamp (seconds)")
    climax_t: float = Field(ge=0.0, description="CLIMAX narrative anchor timestamp (seconds)")
    source: str = "llm"  # "llm" | "heuristic"
```

Modify `TrailerManifest`:
- Change `schema_version: str = "1.0"` to `schema_version: str = "2.0"`
- Keep as `str` — NOT `Literal["2.0"]` (backward-compat: old manifests with "1.0" still load)
- Add field: `structural_anchors: Optional[StructuralAnchors] = None`
- Add `Optional` to the import line at top of file

**Part B — checkpoint.py:**

In `PipelineCheckpoint` dataclass, add two new optional fields (after `assembly_manifest_path`):
```python
proxy_duration_s: Optional[float] = None     # Video duration (seconds) for heuristic fallback
structural_anchors: Optional[dict] = None    # StructuralAnchors.model_dump() result
```

**Part C — cli.py — three changes:**

1. Update imports at top of cli.py:
   Add: `from cinecut.inference.text_engine import get_models_dir, MISTRAL_GGUF_NAME`
   Add: `from cinecut.inference.structural import run_structural_analysis, compute_heuristic_anchors`
   Add: `from cinecut.manifest.schema import StructuralAnchors`
   Add: `from cinecut.narrative.signals import get_film_duration_s`

2. Change `TOTAL_STAGES = 7` to `TOTAL_STAGES = 8`

3. In Stage 1 (proxy), after `save_checkpoint(ckpt, work_dir)` on the fresh-proxy path AND after `proxy_path = Path(ckpt.proxy_path)` on the resume path, capture video duration:
   ```python
   # Capture proxy duration for heuristic fallback (Stage 5)
   if ckpt.proxy_duration_s is None:
       try:
           ckpt.proxy_duration_s = get_film_duration_s(proxy_path)
           save_checkpoint(ckpt, work_dir)
       except Exception:
           ckpt.proxy_duration_s = 0.0  # safe default; heuristic will use subtitle span instead
   proxy_duration_s = ckpt.proxy_duration_s
   ```
   Place this block immediately after each branch of Stage 1 (after both the fresh and resume checkpoint save).
   Also add `proxy_duration_s = ckpt.proxy_duration_s or 0.0` in the resume branch if already set.

4. Insert Stage 5 structural analysis AFTER Stage 4 (after `save_checkpoint(ckpt, work_dir)` following `ckpt.inference_complete = True`) and BEFORE the existing narrative beat block:

   ```python
   # --- Stage 5/8: Structural Analysis (IINF-03, IINF-04, STRC-01, STRC-03) ---
   if not ckpt.is_stage_complete("structural"):
       console.print(f"[bold]Stage 5/{TOTAL_STAGES}:[/bold] Structural analysis...")
       models_dir = get_models_dir()
       mistral_path = models_dir / MISTRAL_GGUF_NAME
       if not mistral_path.exists():
           console.print(
               f"[yellow]Heuristic fallback:[/] Mistral GGUF not found at "
               f"[dim]{mistral_path}[/dim] — using 5%/45%/80% zone anchors\n"
           )
           structural_anchors = compute_heuristic_anchors(proxy_duration_s)
       else:
           with TextEngine(mistral_path) as text_engine:
               structural_anchors = run_structural_analysis(dialogue_events, text_engine)
       ckpt.structural_anchors = structural_anchors.model_dump()
       ckpt.mark_stage_complete("structural")
       save_checkpoint(ckpt, work_dir)
       console.print(
           f"[green]Structural anchors:[/] BEGIN={structural_anchors.begin_t:.1f}s "
           f"ESCALATION={structural_anchors.escalation_t:.1f}s "
           f"CLIMAX={structural_anchors.climax_t:.1f}s "
           f"([dim]source={structural_anchors.source}[/dim])\n"
       )
   else:
       structural_anchors = StructuralAnchors(**ckpt.structural_anchors)
       console.print(f"[yellow]Resuming:[/] Stage 5 already complete\n")
   ```

5. Renumber the existing stages in cli.py:
   - Old `Stage 5/7` (narrative) → `Stage 6/8`
   - Old `Stage 6/7` (assembly) → `Stage 7/8`
   - Old `Stage 7/7` (conform) → `Stage 8/8`
   Update all console.print stage number strings and the summary panel title.

6. Add `TextEngine` to the imports:
   `from cinecut.inference.text_engine import TextEngine, get_models_dir, MISTRAL_GGUF_NAME`
   (TextEngine is needed for the `with TextEngine(...)` block in Stage 5.)
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.manifest.schema import StructuralAnchors, TrailerManifest
from cinecut.checkpoint import PipelineCheckpoint
# Test StructuralAnchors
a = StructuralAnchors(begin_t=300.0, escalation_t=3000.0, climax_t=5500.0)
assert a.source == 'llm'
# Test schema_version default
import json, pathlib
# Minimal manifest for construction test
from cinecut.manifest.schema import ClipEntry
ce = ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='act1')
m = TrailerManifest(source_file='x.mkv', vibe='drama', clips=[ce])
assert m.schema_version == '2.0', m.schema_version
assert m.structural_anchors is None
m2 = TrailerManifest(source_file='x.mkv', vibe='drama', clips=[ce], structural_anchors=a)
assert m2.structural_anchors.begin_t == 300.0
# Test backward compat: v1.0 manifest loads
m3 = TrailerManifest(source_file='x.mkv', vibe='drama', clips=[ce], schema_version='1.0')
assert m3.schema_version == '1.0'
# Test PipelineCheckpoint new fields
ckpt = PipelineCheckpoint(source_file='x.mkv', vibe='drama')
assert ckpt.proxy_duration_s is None
assert ckpt.structural_anchors is None
print('All schema/checkpoint assertions passed')
"</automated>
  </verify>
  <done>StructuralAnchors importable from manifest.schema; TrailerManifest.schema_version defaults to "2.0"; structural_anchors field Optional and defaults None; PipelineCheckpoint has proxy_duration_s and structural_anchors fields; cli.py imports cleanly; TOTAL_STAGES=8</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for structural.py</name>
  <files>tests/test_structural.py</files>
  <action>
Create tests/test_structural.py with unit tests that do NOT require a live llama-server. Use unittest.mock.MagicMock for the engine.

Test cases to implement:

1. `test_chunk_events_basic` — 150 events chunked into [75, 75]
2. `test_chunk_events_partial` — 80 events chunked into [75, 5]
3. `test_chunk_events_empty` — empty list returns []
4. `test_format_subtitle_chunk_uses_absolute_timestamps` — events with start_s=120.0 produce "[120.0s]" in output, NOT "[0.0s]"
5. `test_clamp_anchors_valid` — all anchors within chunk range pass through unchanged
6. `test_clamp_anchors_hallucinated` — anchors far outside chunk range returns None
7. `test_compute_heuristic_anchors` — input 7200.0s returns begin_t=360.0, escalation_t=3240.0, climax_t=5760.0, source="heuristic"
8. `test_run_structural_analysis_single_chunk` — mock engine.analyze_chunk returns {"begin_t": 300.0, "escalation_t": 3000.0, "climax_t": 5500.0}; result source="llm"
9. `test_run_structural_analysis_all_chunks_fail` — mock engine.analyze_chunk always returns None; result source="heuristic"
10. `test_run_structural_analysis_median_aggregation` — mock returns two results: chunk1={begin_t:100, esc:400, climax:800}, chunk2={begin_t:200, esc:600, climax:1000}; median begin_t=150.0

Use `from cinecut.models import DialogueEvent` to create test events.
Helper to create a DialogueEvent: `DialogueEvent(start_ms=int(s*1000), end_ms=int((s+2)*1000), start_s=s, end_s=s+2.0, midpoint_s=s+1.0, text=f"Hello {i}", emotion="neutral")`

For mock engine: `from unittest.mock import MagicMock; engine = MagicMock(); engine.analyze_chunk.return_value = {...}`

Run existing test suite to confirm no regressions after schema changes:
`pytest tests/ -x -q`
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && pytest tests/test_structural.py -v && pytest tests/ -x -q</automated>
  </verify>
  <done>All 10 tests in test_structural.py pass; full test suite passes with no regressions from schema changes</done>
</task>

</tasks>

<verification>
Structural analysis end-to-end import check (no live models needed):

```bash
cd /home/adamh/ai-video-trailer && python -c "
import cinecut.cli          # verifies full import chain
from cinecut.manifest.schema import StructuralAnchors, TrailerManifest
from cinecut.inference.structural import run_structural_analysis, compute_heuristic_anchors
from cinecut.inference.text_engine import TextEngine, get_models_dir, MISTRAL_GGUF_NAME
from cinecut.checkpoint import PipelineCheckpoint
print('All imports OK')
print('TOTAL_STAGES:', end=' ')
import cinecut.cli as c; print(c.TOTAL_STAGES)
assert c.TOTAL_STAGES == 8
"
```

Heuristic fallback smoke test:
```bash
python -c "
from cinecut.inference.structural import compute_heuristic_anchors
a = compute_heuristic_anchors(5400.0)  # 90-minute film
print(f'BEGIN: {a.begin_t}s  ESC: {a.escalation_t}s  CLIMAX: {a.climax_t}s  SRC: {a.source}')
assert a.begin_t == 270.0
assert a.escalation_t == 2430.0
assert a.climax_t == 4320.0
assert a.source == 'heuristic'
print('Heuristic fallback verified')
"
```

Full test suite:
```bash
cd /home/adamh/ai-video-trailer && pytest tests/ -x -q
```
</verification>

<success_criteria>
- src/cinecut/inference/structural.py exists with run_structural_analysis, compute_heuristic_anchors, CHUNK_SIZE=75
- TextEngine.analyze_chunk method added; uses /v1/chat/completions with json_schema
- manifest/schema.py: StructuralAnchors model; TrailerManifest schema_version="2.0"; structural_anchors Optional field
- Old manifests with schema_version="1.0" load without error
- checkpoint.py: proxy_duration_s and structural_anchors fields added
- cli.py: TOTAL_STAGES=8; Stage 5 structural analysis gate present; heuristic fallback when GGUF absent
- Stage numbers in console output renumbered: 5→narrative is now 6, assembly=7, conform=8
- tests/test_structural.py: 10 tests passing, no live LLM required
- Full test suite passes: pytest tests/ -x -q
</success_criteria>

<output>
After completion, create `.planning/phases/07-structural-analysis/07-02-SUMMARY.md`
</output>
