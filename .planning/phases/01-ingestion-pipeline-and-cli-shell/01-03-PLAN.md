---
phase: 01-ingestion-pipeline-and-cli-shell
plan: 03
type: execute
wave: 3
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/cinecut/cli.py
  - src/cinecut/ingestion/keyframes.py
  - tests/test_keyframes.py
autonomous: true
requirements:
  - PIPE-03
  - CLI-01
  - CLI-02
  - CLI-03

must_haves:
  truths:
    - "User can run `cinecut film.mkv --subtitle film.srt --vibe action` and see Rich progress bars during ingestion"
    - "CLI validates that video extension is MKV/AVI/MP4 and subtitle extension is SRT/ASS before doing any work"
    - "CLI creates the work directory at `<video_stem>_cinecut_work/` alongside the source file"
    - "Keyframe extraction combines subtitle midpoints, scene-change detection, and interval fallback into a deduplicated sorted list of PTS seconds"
    - "Scene-change detection runs on the proxy (not the source)"
    - "Interval fallback fills any gap > 30s between consecutive timestamps with frames every 30s"
    - "Each keyframe is extracted as a JPEG saved to `work_dir/keyframes/frame_{timestamp_ms:010d}.jpg`"
    - "When any stage fails, the CLI displays a Rich error panel with a human-readable message and exits non-zero"
    - "The CLI never prints raw FFmpeg stderr or Python tracebacks to the terminal"
  artifacts:
    - path: "src/cinecut/cli.py"
      provides: "Typer CLI entry point wiring all ingestion stages with Rich progress"
      exports: ["app"]
    - path: "src/cinecut/ingestion/keyframes.py"
      provides: "Hybrid keyframe timestamp collection and JPEG extraction"
      exports: ["collect_keyframe_timestamps", "extract_frame", "extract_all_keyframes"]
    - path: "tests/test_keyframes.py"
      provides: "Unit tests for timestamp collection logic (no real video required)"
  key_links:
    - from: "src/cinecut/cli.py"
      to: "src/cinecut/ingestion/proxy.py:create_proxy"
      via: "called in main() after work_dir setup"
      pattern: "create_proxy"
    - from: "src/cinecut/cli.py"
      to: "src/cinecut/ingestion/subtitles.py:parse_subtitles"
      via: "called in main() after proxy creation"
      pattern: "parse_subtitles"
    - from: "src/cinecut/cli.py"
      to: "src/cinecut/ingestion/keyframes.py:extract_all_keyframes"
      via: "called in main() after subtitle parsing"
      pattern: "extract_all_keyframes"
    - from: "src/cinecut/ingestion/keyframes.py"
      to: "scenedetect.detect + ContentDetector"
      via: "supplementary timestamp collection"
      pattern: "from scenedetect import detect, ContentDetector"
    - from: "src/cinecut/cli.py"
      to: "src/cinecut/errors.py:CineCutError"
      via: "catch-all for typed errors → Rich error panel → Exit(1)"
      pattern: "except CineCutError"
---

<objective>
Wire the complete Phase 1 pipeline: the Typer CLI shell that accepts user inputs (CLI-01), drives Rich progress bars through each stage (CLI-02), handles errors with human-readable panels (CLI-03), and the hybrid keyframe extractor that produces the frame set for Phase 3 inference (PIPE-03).

Purpose: This is the plan that makes everything functional end-to-end. After this plan, a user can run `cinecut <film> --subtitle <srt> --vibe action` and see proxy creation, subtitle parsing, and keyframe extraction complete with progress feedback. The work directory contains all artifacts Phase 3 will consume.

Output: `cli.py` (Typer entry point), `ingestion/keyframes.py` (hybrid extractor), `tests/test_keyframes.py`.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-RESEARCH.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-01-SUMMARY.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-02-SUMMARY.md

<interfaces>
<!-- Contracts from plans 01 and 02 that this plan uses. -->

From src/cinecut/models.py:
```python
@dataclass
class DialogueEvent:
    start_ms: int; end_ms: int; start_s: float; end_s: float
    midpoint_s: float; text: str; emotion: str

@dataclass
class KeyframeRecord:
    timestamp_s: float; frame_path: str; source: str
    # source values: "subtitle_midpoint" | "scene_change" | "interval_fallback"
```

From src/cinecut/errors.py:
```python
class CineCutError(Exception): ...  # Base — catch all pipeline errors here
class ProxyCreationError(CineCutError): ...
class KeyframeExtractionError(CineCutError): ...
class SubtitleParseError(CineCutError): ...
class ProxyValidationError(CineCutError): ...
```

From src/cinecut/ingestion/proxy.py:
```python
def probe_video(source: Path) -> dict:
    # Returns {"duration_seconds": float, "r_frame_rate": str}

def create_proxy(source: Path, work_dir: Path, progress_callback=None) -> Path:
    # Returns Path to proxy MP4 in work_dir; idempotent

def validate_proxy(proxy_path: Path, source: Path) -> None:
    # Raises ProxyValidationError if proxy is corrupt
```

From src/cinecut/ingestion/subtitles.py:
```python
def parse_subtitles(subtitle_path: Path) -> list[DialogueEvent]:
    # Returns list of DialogueEvent; raises SubtitleParseError on failure
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement hybrid keyframe extractor</name>
  <files>
    src/cinecut/ingestion/keyframes.py
    tests/test_keyframes.py
  </files>
  <action>
**`src/cinecut/ingestion/keyframes.py`**:

Implement three functions:

**`collect_keyframe_timestamps(proxy: Path, subtitle_midpoints: list[float], gap_threshold_s: float = 30.0, interval_s: float = 30.0) -> list[float]`**:
- Start with `timestamps = set(subtitle_midpoints)` (primary source — PIPE-03)
- Run scene-change detection on the proxy (NOT the source — see anti-patterns in research): `scenes = detect(str(proxy), ContentDetector(threshold=27.0))`
- For each scene `(start, end)`: compute `mid = round((start.get_seconds() + end.get_seconds()) / 2.0, 3)` and add to timestamps set. This is supplementary — it adds scene transitions the subtitle file may not cover.
- Sort the combined timestamp set: `sorted_ts = sorted(timestamps)`
- Apply interval fallback: for each consecutive pair where `gap > gap_threshold_s`, insert a timestamp every `interval_s` seconds until the gap is closed. This ensures coverage of dialogue-free sequences (Pitfall 2 research note: action films may produce too many scene-detected timestamps at threshold=27.0, but deduplication against the set naturally caps redundancy).
- Return `sorted(set(filled))` — final sorted deduplicated list of PTS float seconds.

**`extract_frame(proxy: Path, timestamp_s: float, output_path: Path) -> None`**:
- Run FFmpeg with pre-seek: `-ss <timestamp_s>` BEFORE `-i` (fast, keyframe-aligned — acceptable for 24fps analysis proxy)
- Command: `["ffmpeg", "-y", "-ss", str(timestamp_s), "-i", str(proxy), "-frames:v", "1", "-q:v", "2", str(output_path)]`
- Use `subprocess.run(cmd, check=True, capture_output=True)`
- Catch `subprocess.CalledProcessError` → raise `KeyframeExtractionError(timestamp_s, e.stderr.decode("utf-8", errors="replace"))`

**`extract_all_keyframes(proxy: Path, timestamps: list[float], keyframes_dir: Path) -> list[KeyframeRecord]`**:
- Ensure `keyframes_dir` exists (`keyframes_dir.mkdir(exist_ok=True)`)
- For each `timestamp_s` in `timestamps`:
  - Compute filename: `frame_{int(timestamp_s * 1000):010d}.jpg` (milliseconds as zero-padded int for deterministic lexicographic sort)
  - `output_path = keyframes_dir / filename`
  - If `output_path` exists, skip extraction (idempotent)
  - Otherwise call `extract_frame(proxy, timestamp_s, output_path)`
  - Append `KeyframeRecord(timestamp_s=timestamp_s, frame_path=str(output_path.resolve()), source=_infer_source(timestamp_s, subtitle_midpoints))` to results
- Return list of `KeyframeRecord`

Note: `_infer_source()` is a private helper. Since timestamps from all sources are merged before extraction, pass `subtitle_midpoints` set as a parameter and check membership:
```python
def _infer_source(ts: float, subtitle_midpoints: set[float]) -> str:
    if ts in subtitle_midpoints:
        return "subtitle_midpoint"
    return "scene_change"  # interval_fallback is indistinguishable from scene_change post-merge; acceptable
```

Revise the signature of `extract_all_keyframes` to accept `subtitle_midpoints: set[float]` as a parameter.

**`tests/test_keyframes.py`**:

```python
# Tests to include (pure logic — no real video required):
# test_collect_no_gaps: subtitle midpoints evenly spaced at 20s intervals → no interval fallback added
# test_collect_gap_filled: midpoints at 0s and 90s → interval fallback adds timestamps at 30s and 60s
# test_collect_deduplicates: subtitle midpoint and scene midpoint at same second → only one entry in output
# test_collect_sorted: timestamps from multiple sources arrive unsorted → output is sorted ascending
# test_infer_source_subtitle: timestamp in subtitle_midpoints set → "subtitle_midpoint"
# test_infer_source_scene: timestamp not in subtitle_midpoints → "scene_change"
```

For `test_collect_no_gaps` and `test_collect_gap_filled`, mock `detect()` to return an empty scene list (no PySceneDetect calls needed in unit tests). Use `unittest.mock.patch("cinecut.ingestion.keyframes.detect", return_value=[])`.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_keyframes.py -v --tb=short 2>&1 | tail -20</automated>
  </verify>
  <done>
All tests in `tests/test_keyframes.py` pass. `collect_keyframe_timestamps()` correctly applies the interval fallback for gaps over 30s, deduplicates, and returns a sorted list. Source inference correctly distinguishes subtitle midpoints from other sources.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Typer CLI shell with Rich progress</name>
  <files>
    src/cinecut/cli.py
  </files>
  <action>
**`src/cinecut/cli.py`**:

Implement the `cinecut` CLI command using Typer. This is the integration point that wires all ingestion modules.

```python
# src/cinecut/cli.py
from pathlib import Path
from typing import Annotated

import typer
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn

from cinecut.errors import CineCutError
from cinecut.ingestion.proxy import create_proxy
from cinecut.ingestion.subtitles import parse_subtitles
from cinecut.ingestion.keyframes import collect_keyframe_timestamps, extract_all_keyframes

app = typer.Typer(
    name="cinecut",
    help="CineCut AI — Generate a narratively coherent trailer from any feature film.",
    add_completion=False,
)
console = Console()
err_console = Console(stderr=True)

# Valid input formats
_VALID_VIDEO_EXTS = {".mkv", ".avi", ".mp4"}
_VALID_SUBTITLE_EXTS = {".srt", ".ass"}


def _setup_work_dir(source: Path) -> Path:
    """Create <source_stem>_cinecut_work/ alongside the source file. Idempotent."""
    work_dir = source.parent / f"{source.stem}_cinecut_work"
    work_dir.mkdir(exist_ok=True)
    (work_dir / "keyframes").mkdir(exist_ok=True)
    return work_dir


@app.command()
def main(
    video: Annotated[
        Path,
        typer.Argument(
            exists=True,
            file_okay=True,
            dir_okay=False,
            resolve_path=True,
            help="Input video file (MKV, AVI, or MP4).",
        ),
    ],
    subtitle: Annotated[
        Path,
        typer.Option(
            "--subtitle", "-s",
            exists=True,
            file_okay=True,
            dir_okay=False,
            resolve_path=True,
            help="Subtitle file (SRT or ASS).",
        ),
    ],
    vibe: Annotated[
        str,
        typer.Option("--vibe", "-v", help="Trailer vibe profile name (e.g. action, drama, horror)."),
    ],
    review: Annotated[
        bool,
        typer.Option("--review", help="Pause after manifest generation for inspection before conform."),
    ] = False,
) -> None:
    """Ingest a film and produce analysis-ready artifacts for trailer generation."""
    # --- Input validation (PIPE-01) ---
    if video.suffix.lower() not in _VALID_VIDEO_EXTS:
        err_console.print(Panel(
            f"Unsupported video format: [bold]{video.suffix}[/bold]\n"
            f"Supported formats: {', '.join(sorted(_VALID_VIDEO_EXTS))}",
            title="[red]Input Error[/red]",
            border_style="red",
        ))
        raise typer.Exit(1)

    if subtitle.suffix.lower() not in _VALID_SUBTITLE_EXTS:
        err_console.print(Panel(
            f"Unsupported subtitle format: [bold]{subtitle.suffix}[/bold]\n"
            f"Supported formats: {', '.join(sorted(_VALID_SUBTITLE_EXTS))}",
            title="[red]Input Error[/red]",
            border_style="red",
        ))
        raise typer.Exit(1)

    console.print(f"\n[bold cyan]CineCut AI[/bold cyan] — [dim]{video.name}[/dim]  vibe=[bold]{vibe}[/bold]\n")

    # --- Work directory setup ---
    work_dir = _setup_work_dir(video)
    console.print(f"Work directory: [dim]{work_dir}[/dim]\n")

    try:
        # --- Stage 1: Proxy creation (PIPE-02) ---
        # better-ffmpeg-progress handles its own Rich progress bar during the FFmpeg call.
        console.print("[bold]Stage 1/3:[/bold] Creating 420p analysis proxy...")
        proxy_path = create_proxy(video, work_dir)
        console.print(f"[green]✓[/green] Proxy ready: [dim]{proxy_path.name}[/dim]\n")

        # --- Stage 2: Subtitle parsing (NARR-01) ---
        console.print("[bold]Stage 2/3:[/bold] Parsing subtitles...")
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            TimeElapsedColumn(),
            console=console,
            transient=True,
        ) as progress:
            task = progress.add_task("Parsing subtitle events...", total=None)
            dialogue_events = parse_subtitles(subtitle)
            progress.update(task, description=f"Parsed {len(dialogue_events)} dialogue events")
        console.print(f"[green]✓[/green] Parsed {len(dialogue_events)} dialogue events\n")

        # --- Stage 3: Keyframe extraction (PIPE-03) ---
        console.print("[bold]Stage 3/3:[/bold] Extracting keyframes...")
        subtitle_midpoints = [e.midpoint_s for e in dialogue_events]

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TextColumn("{task.completed}/{task.total}"),
            TimeElapsedColumn(),
            console=console,
        ) as progress:
            ts_task = progress.add_task("Collecting timestamps (scene detection)...", total=None)
            timestamps = collect_keyframe_timestamps(proxy_path, subtitle_midpoints)
            progress.update(ts_task, description=f"Collected {len(timestamps)} keyframe timestamps", completed=1, total=1)

            kf_task = progress.add_task("Extracting frames...", total=len(timestamps))
            keyframe_records = extract_all_keyframes(
                proxy_path,
                timestamps,
                work_dir / "keyframes",
                subtitle_midpoints=set(subtitle_midpoints),
                progress_callback=lambda: progress.advance(kf_task),
            )
        console.print(f"[green]✓[/green] Extracted {len(keyframe_records)} keyframes\n")

        # --- Summary ---
        console.print(Panel(
            f"[bold green]Ingestion complete[/bold green]\n\n"
            f"  Proxy:      [dim]{proxy_path.name}[/dim]\n"
            f"  Subtitles:  {len(dialogue_events)} events\n"
            f"  Keyframes:  {len(keyframe_records)} frames\n"
            f"  Work dir:   [dim]{work_dir}[/dim]",
            title="[green]Phase 1 Complete[/green]",
            border_style="green",
        ))

    except CineCutError as e:
        # Translate all typed pipeline errors to a Rich panel — never show tracebacks (CLI-03)
        err_console.print(Panel(
            str(e),
            title="[red]Pipeline Error[/red]",
            border_style="red",
        ))
        raise typer.Exit(1)
```

**Update `extract_all_keyframes` signature** in `keyframes.py` to accept `progress_callback: Callable[[], None] | None = None` and call it after each frame is extracted. Also accept `subtitle_midpoints: set[float]` for source inference.

This is the only file in this plan that requires a backward-compatible update to a prior plan's module — update `keyframes.py` to add the `progress_callback` and `subtitle_midpoints` parameters, keeping both optional with sensible defaults so `test_keyframes.py` tests still pass without modification.

**Important implementation details:**
- Do NOT import `better_ffmpeg_progress` directly in cli.py — proxy.py handles that internally. The CLI just calls `create_proxy()`.
- The `--review` flag is accepted and stored but not acted on in Phase 1 (Phase 2 implements the manifest/conform pipeline). Do not add a TODO or warning — it's a no-op for now.
- Vibe validation is also deferred to Phase 2 (vibe profiles are defined there). Accept any string for `--vibe` in Phase 1.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/ -v --tb=short 2>&1 | tail -30</automated>
  </verify>
  <done>
`cinecut --help` displays the command help text with all four arguments/options listed. All existing tests in `tests/` continue to pass. `cinecut` entry point resolves without ImportError. Running `cinecut nonexistent.mkv --subtitle s.srt --vibe action` exits non-zero with a Rich error panel (Typer's built-in `exists=True` validation).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
- `cinecut --help` shows usage with video, --subtitle, --vibe, --review
- `python -m pytest tests/ -v` passes all tests (test_subtitles, test_proxy, test_keyframes)
- `python -c "from cinecut.ingestion.keyframes import collect_keyframe_timestamps, extract_all_keyframes"` succeeds
- `python -c "from cinecut.cli import app"` succeeds without ImportError
- Running `cinecut /nonexistent/path.mkv --subtitle /nonexistent.srt --vibe action` exits non-zero with an error panel (not a Python traceback)
</verification>

<success_criteria>
`cinecut` is a fully functional CLI entry point that accepts video + subtitle + vibe inputs, creates the work directory, runs all three ingestion stages (proxy creation, subtitle parsing, keyframe extraction) with Rich progress feedback, and surfaces human-readable error panels for any failure. The hybrid keyframe extractor correctly combines subtitle midpoints with scene-change detection and interval fallback. All phase-level unit tests pass. Phase 1 artifacts (proxy, dialogue events, keyframe JPEGs) are written to `<video_stem>_cinecut_work/` and are ready for Phase 3 consumption.
</success_criteria>

<output>
After completion, create `.planning/phases/01-ingestion-pipeline-and-cli-shell/01-03-SUMMARY.md` following the summary template.
</output>
