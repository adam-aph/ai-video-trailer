---
phase: 05-trailer-assembly-and-end-to-end-pipeline
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/cinecut/cli.py
  - tests/test_checkpoint.py
  - tests/test_assembly.py
autonomous: true
requirements:
  - PIPE-04
  - EDIT-02
  - EDIT-03

must_haves:
  truths:
    - "CLI wraps every pipeline stage with checkpoint guards — completed stages are skipped on resume"
    - "Stage numbers in CLI output are updated to reflect the 7-stage pipeline (1-proxy through 7-conform)"
    - "Stage 6 (assembly) runs assemble_manifest() and injects title_card + button paths into conform"
    - "conform_manifest() receives a reordered TrailerManifest (act-sorted) not the raw generator output"
    - "96+ non-inference tests still pass after cli.py changes"
  artifacts:
    - path: "src/cinecut/cli.py"
      provides: "Updated CLI with checkpoint guards on all 6 pipeline stages + Stage 6 assembly"
      contains: "load_checkpoint"
    - path: "tests/test_checkpoint.py"
      provides: "Unit tests for PipelineCheckpoint, load_checkpoint, save_checkpoint"
      exports: ["TestPipelineCheckpoint"]
    - path: "tests/test_assembly.py"
      provides: "Unit tests for sort_clips_by_act, enforce_pacing_curve, pacing assertion helper"
      exports: ["TestSortClipsByAct", "TestEnforcePacingCurve"]
  key_links:
    - from: "cli.py main()"
      to: "load_checkpoint()"
      via: "ckpt = load_checkpoint(work_dir) or PipelineCheckpoint(source_file=..., vibe=...)"
      pattern: "load_checkpoint"
    - from: "cli.py Stage 6"
      to: "assemble_manifest()"
      via: "reordered_manifest, extra_paths = assemble_manifest(trailer_manifest, video, work_dir)"
      pattern: "assemble_manifest"
    - from: "cli.py conform call"
      to: "conform_manifest(reordered_manifest, ...)"
      via: "Pass reordered_manifest (not original trailer_manifest) to conform_manifest"
      pattern: "reordered_manifest"
---

<objective>
Wire checkpoint guards into `cli.py` for all pipeline stages and add Stage 6 (assembly). Write unit tests for checkpoint and assembly modules.

Purpose: Completes PIPE-04 (resume after crash), EDIT-02 (3-act conform order), EDIT-03 (pacing curve in output). Tests verify behavioral contracts before end-to-end human verify.

Output: Updated `cli.py` with 7-stage pipeline + checkpoint, plus `tests/test_checkpoint.py` and `tests/test_assembly.py`.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-trailer-assembly-and-end-to-end-pipeline/05-01-SUMMARY.md
@.planning/phases/05-trailer-assembly-and-end-to-end-pipeline/05-02-SUMMARY.md

<interfaces>
<!-- Contracts from plans 05-01 and 05-02 that cli.py consumes -->

From src/cinecut/checkpoint.py (05-01):
```python
@dataclass
class PipelineCheckpoint:
    source_file: str
    vibe: str
    stages_complete: list[str] = field(default_factory=list)
    proxy_path: Optional[str] = None
    keyframe_count: Optional[int] = None
    dialogue_event_count: Optional[int] = None
    inference_complete: Optional[bool] = None
    manifest_path: Optional[str] = None
    assembly_manifest_path: Optional[str] = None

    def is_stage_complete(self, stage: str) -> bool: ...
    def mark_stage_complete(self, stage: str) -> None: ...

def load_checkpoint(work_dir: Path) -> Optional[PipelineCheckpoint]: ...
def save_checkpoint(checkpoint: PipelineCheckpoint, work_dir: Path) -> None: ...
```

Stage name strings for checkpoint: "proxy", "subtitles", "keyframes", "inference", "narrative", "assembly"

From src/cinecut/assembly/__init__.py (05-02):
```python
def assemble_manifest(
    manifest: TrailerManifest,
    source_file: Path,
    work_dir: Path,
) -> tuple[TrailerManifest, list[Path]]:
    """Returns (reordered_manifest, [title_card_path, button_path])"""
```

From src/cinecut/conform/pipeline.py (unchanged):
```python
def conform_manifest(
    manifest: TrailerManifest,
    source: Path,
    work_dir: Path,
) -> Path:
    """Iterates manifest.clips in order given. Does NOT enforce act order itself."""
```

IMPORTANT: conform_manifest() iterates manifest.clips as given. Phase 5 ensures
the reordered_manifest (from assemble_manifest) is passed instead of the raw generator output.

Extra title_card and button paths from assemble_manifest() must be appended to the
final concat list AFTER act3 clips have been extracted+graded. The cleanest approach:
after conform_manifest() processes reordered_manifest.clips, call concatenate_clips()
with the clip paths + extra_paths appended.

However, conform_manifest() currently handles the full concat internally. To avoid
refactoring conform_manifest(), the simpler approach: pass the full ordered clip list
(including generated segment paths injected as pre-graded clips) into a modified
conform flow. The cleanest minimal change: add a `extra_clip_paths: list[Path] = []`
parameter to conform_manifest(), or handle concatenation after the fact.

RECOMMENDATION from research: Create a new TrailerManifest with reordered clips and
pass it to conform_manifest(). For title_card/button, after conform_manifest() writes
graded clips, we need to append the pre-encoded title_card.mp4 and button.mp4 BEFORE
the final concatenate_clips() call. The current conform_manifest() does both grading
AND concat in one call. Options:
  (a) Add extra_paths param to conform_manifest() — minimal invasive change
  (b) Call conform_manifest() then concatenate separately — but conform already concatenates

CHOOSE OPTION (a): Add optional `extra_clip_paths: list[Path] = []` parameter to
`conform_manifest()` that appends those paths to clip_output_paths before the final concat.
This is a backward-compatible change (default = empty list).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update cli.py — checkpoint guards on all stages + Stage 6 assembly wiring</name>
  <files>src/cinecut/cli.py</files>
  <action>
Modify `src/cinecut/cli.py` with these changes:

**1. Add imports at top:**
```python
from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint
from cinecut.assembly import assemble_manifest
```

**2. Add `TOTAL_STAGES = 7` constant after imports** (Pitfall 5: fix hardcoded stage counts).

**3. In `main()`, after `work_dir = _setup_work_dir(video)` and before the `try:` block, add checkpoint initialization:**
```python
# --- Checkpoint init (PIPE-04) ---
ckpt = load_checkpoint(work_dir)
if ckpt is not None and ckpt.source_file != str(video):
    console.print("[yellow]Warning:[/] Stale checkpoint (different source file). Starting fresh.")
    ckpt = None
if ckpt is None:
    ckpt = PipelineCheckpoint(source_file=str(video), vibe=vibe_normalized)
```

**4. Update all stage progress labels** to use `f"Stage N/{TOTAL_STAGES}:"` format. The new stage numbering is:
- Stage 1/7: Proxy creation
- Stage 2/7: Subtitle parsing
- Stage 3/7: Keyframe extraction
- Stage 4/7: LLaVA inference
- Stage 5/7: Narrative manifest generation
- Stage 6/7: 3-act assembly
- Stage 7/7: FFmpeg conform

**5. Wrap each existing stage** with checkpoint guard pattern. Only apply to the `else:` branch (full pipeline, not `--manifest` shortcut):

For Stage 1 (proxy):
```python
if not ckpt.is_stage_complete("proxy"):
    console.print(f"[bold]Stage 1/{TOTAL_STAGES}:[/bold] Creating 420p analysis proxy...")
    proxy_path = create_proxy(video, work_dir)
    ckpt.proxy_path = str(proxy_path)
    ckpt.mark_stage_complete("proxy")
    save_checkpoint(ckpt, work_dir)
    console.print(f"[green]Proxy ready: [dim]{proxy_path.name}[/dim]\n")
else:
    proxy_path = Path(ckpt.proxy_path)
    console.print(f"[yellow]Resuming:[/] Stage 1 already complete (proxy: {proxy_path.name})\n")
```

Apply same pattern for Stage 2 (subtitles), Stage 3 (keyframes), Stage 4 (inference), Stage 5 (narrative). Each stage:
- Checks `ckpt.is_stage_complete(stage_name)`
- On completion: sets relevant ckpt field, calls `mark_stage_complete()`, calls `save_checkpoint()`
- On resume: reconstructs from ckpt fields

For Stage 3 (keyframes) resume path: `keyframe_records` can be reconstructed by re-loading from `work_dir / "keyframes"` or just re-running the extraction (it's idempotent). For simplicity, skip the keyframe stage entirely on resume — keyframe files are already in `work_dir/keyframes/` and will be loaded by inference. Store `keyframe_count` in checkpoint for the summary panel.

For Stage 4 (inference) resume: inference produces no persistent output file (results are in memory). Re-run inference from existing keyframe files. Do NOT mark inference as resumed-skippable in Phase 5 — it's too complex and the research does not recommend it. Mark the checkpoint field `inference_complete` but do not skip re-running inference on resume. Leave a TODO comment: `# TODO: inference resume requires persisting SceneDescription results; deferred to v2`.

For Stage 5 (narrative) resume: `manifest_path` is stored. On resume, skip `run_narrative_stage()` and load the manifest from `ckpt.manifest_path`.
```python
if not ckpt.is_stage_complete("narrative"):
    # ... run_narrative_stage() ...
    ckpt.manifest_path = str(manifest_path)
    ckpt.mark_stage_complete("narrative")
    save_checkpoint(ckpt, work_dir)
else:
    manifest_path = Path(ckpt.manifest_path)
    console.print(f"[yellow]Resuming:[/] Stage 5 already complete (manifest: {manifest_path.name})\n")

trailer_manifest = load_manifest(manifest_path)
```

**6. Add Stage 6 (assembly) after Stage 5 and before the conform call:**
```python
# --- Stage 6/7: 3-act assembly and pacing enforcement (EDIT-02, EDIT-03) ---
if not ckpt.is_stage_complete("assembly"):
    console.print(f"[bold]Stage 6/{TOTAL_STAGES}:[/bold] Assembling 3-act structure...")
    with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"),
                  TimeElapsedColumn(), console=console, transient=True) as progress:
        asm_task = progress.add_task("Ordering clips and generating title card...", total=None)
        reordered_manifest, extra_paths = assemble_manifest(trailer_manifest, video, work_dir)
        progress.update(asm_task, description="Assembly complete")
    ckpt.assembly_manifest_path = str(work_dir / "ASSEMBLY_MANIFEST.json")
    ckpt.mark_stage_complete("assembly")
    save_checkpoint(ckpt, work_dir)
    console.print(f"[green]Assembly complete: {len(reordered_manifest.clips)} clips ordered\n")
else:
    from cinecut.manifest.loader import load_manifest as _lm
    reordered_manifest = _lm(Path(ckpt.assembly_manifest_path))
    _, extra_paths = assemble_manifest(trailer_manifest, video, work_dir)
    console.print(f"[yellow]Resuming:[/] Stage 6 already complete\n")
```

**7. Update the conform call** to use `reordered_manifest` (not `trailer_manifest`) and pass `extra_clip_paths`:
```python
console.print(f"[bold]Stage 7/{TOTAL_STAGES}:[/bold] Running FFmpeg conform...")
# ...
output_path = conform_manifest(reordered_manifest, video, work_dir, extra_clip_paths=extra_paths)
```

**8. Update conform_manifest() in conform/pipeline.py** to accept `extra_clip_paths: list[Path] = []`:
```python
def conform_manifest(
    manifest: TrailerManifest,
    source: Path,
    work_dir: Path,
    extra_clip_paths: list[Path] | None = None,
) -> Path:
```
After extracting all clips into `clip_output_paths`, append `extra_clip_paths` before concat:
```python
    if extra_clip_paths:
        clip_output_paths.extend(extra_clip_paths)
    final_output_path = make_output_path(source, manifest.vibe)
    concatenate_clips(clip_output_paths, final_output_path)
```

**9. Update the summary panel** at the end of the full pipeline to say "Phase 5 Complete" (not "Phase 4 Complete").

**10. For the `--manifest` shortcut path**: This path bypasses all ingestion stages. It currently skips to conform. In Phase 5, also run assembly on the loaded manifest before conform. No checkpoint needed for this shortcut path. Insert assembly stage between manifest loading and conform:
```python
# Assembly for --manifest path (no checkpoint)
reordered_manifest, extra_paths = assemble_manifest(trailer_manifest, video, work_dir)
```
Then use `reordered_manifest` in the conform call.

IMPORTANT: Write checkpoint ONLY after each stage fully completes (success path only). Never write in except handlers (Pitfall 2 from research).
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/ -x -q --ignore=tests/test_inference.py -k "not integration" 2>&1 | tail -20</automated>
  </verify>
  <done>
    - `cli.py` imports `load_checkpoint`, `save_checkpoint`, `PipelineCheckpoint`, `assemble_manifest`
    - `TOTAL_STAGES = 7` constant defined
    - All 6 stages wrapped with checkpoint guards (proxy, subtitles, keyframes, narrative, assembly — inference has TODO comment)
    - Stage labels updated to `N/7` format
    - Stage 6 calls `assemble_manifest()` and stores `assembly_manifest_path` in checkpoint
    - `conform_manifest()` in pipeline.py accepts `extra_clip_paths` parameter
    - Conform call uses `reordered_manifest` (act-sorted) not raw generator output
    - All existing non-inference tests still pass (96+)
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests/test_checkpoint.py and tests/test_assembly.py</name>
  <files>
    tests/test_checkpoint.py
    tests/test_assembly.py
  </files>
  <action>
Create two test files following the existing test patterns (class-based, pytest, no mocks for pure logic).

**`tests/test_checkpoint.py`** — unit tests for `cinecut.checkpoint`:

```python
"""Unit tests for pipeline checkpoint — PIPE-04."""
import json
import tempfile
from pathlib import Path
import pytest
from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint, CHECKPOINT_FILENAME


class TestPipelineCheckpoint:
    """PipelineCheckpoint dataclass behavior."""

    def test_initial_stages_complete_empty(self):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        assert ckpt.stages_complete == []

    def test_mark_stage_complete_appends(self):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        ckpt.mark_stage_complete("proxy")
        assert ckpt.is_stage_complete("proxy")

    def test_mark_stage_complete_idempotent(self):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        ckpt.mark_stage_complete("proxy")
        ckpt.mark_stage_complete("proxy")
        assert ckpt.stages_complete.count("proxy") == 1

    def test_is_stage_complete_false_for_unknown(self):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        assert not ckpt.is_stage_complete("inference")


class TestLoadCheckpoint:
    """load_checkpoint() behavior."""

    def test_missing_checkpoint_returns_none(self, tmp_path):
        assert load_checkpoint(tmp_path) is None

    def test_corrupt_json_returns_none(self, tmp_path):
        (tmp_path / CHECKPOINT_FILENAME).write_text("{broken", encoding="utf-8")
        assert load_checkpoint(tmp_path) is None

    def test_corrupt_type_returns_none(self, tmp_path):
        """Valid JSON but wrong structure -> TypeError -> None."""
        (tmp_path / CHECKPOINT_FILENAME).write_text(json.dumps({"bad": "data"}), encoding="utf-8")
        assert load_checkpoint(tmp_path) is None

    def test_valid_checkpoint_round_trip(self, tmp_path):
        ckpt = PipelineCheckpoint(source_file="/tmp/test.mkv", vibe="drama")
        ckpt.mark_stage_complete("proxy")
        ckpt.proxy_path = "/tmp/work/proxy.mp4"
        ckpt.dialogue_event_count = 55
        save_checkpoint(ckpt, tmp_path)

        loaded = load_checkpoint(tmp_path)
        assert loaded is not None
        assert loaded.source_file == "/tmp/test.mkv"
        assert loaded.vibe == "drama"
        assert loaded.is_stage_complete("proxy")
        assert not loaded.is_stage_complete("inference")
        assert loaded.proxy_path == "/tmp/work/proxy.mp4"
        assert loaded.dialogue_event_count == 55


class TestSaveCheckpoint:
    """save_checkpoint() atomicity guarantees."""

    def test_no_tmp_files_remain_after_save(self, tmp_path):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        save_checkpoint(ckpt, tmp_path)
        tmp_files = list(tmp_path.glob("*.ckpt.tmp"))
        assert tmp_files == [], f"Temp files not cleaned: {tmp_files}"

    def test_checkpoint_file_created(self, tmp_path):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        save_checkpoint(ckpt, tmp_path)
        assert (tmp_path / CHECKPOINT_FILENAME).exists()

    def test_overwrite_existing_checkpoint(self, tmp_path):
        ckpt = PipelineCheckpoint(source_file="/tmp/film.mkv", vibe="action")
        ckpt.mark_stage_complete("proxy")
        save_checkpoint(ckpt, tmp_path)

        ckpt.mark_stage_complete("subtitles")
        save_checkpoint(ckpt, tmp_path)

        loaded = load_checkpoint(tmp_path)
        assert loaded.is_stage_complete("proxy")
        assert loaded.is_stage_complete("subtitles")
```

**`tests/test_assembly.py`** — unit tests for `cinecut.assembly.ordering`:

```python
"""Unit tests for 3-act assembly — EDIT-02, EDIT-03."""
import pytest
from cinecut.manifest.schema import ClipEntry
from cinecut.manifest.vibes import VIBE_PROFILES
from cinecut.assembly.ordering import (
    ACT_ORDER,
    sort_clips_by_act,
    enforce_pacing_curve,
    compute_act_avg_duration,
)


def _make_clip(act: str, start: float, end: float, beat_type: str = "escalation_beat") -> ClipEntry:
    return ClipEntry(source_start_s=start, source_end_s=end, beat_type=beat_type, act=act, transition="hard_cut")


class TestSortClipsByAct:
    """EDIT-02: sort_clips_by_act() produces canonical act order."""

    def test_reorders_out_of_order_acts(self):
        clips = [
            _make_clip("act3", 100.0, 102.0),
            _make_clip("cold_open", 5.0, 9.0, "character_introduction"),
            _make_clip("act1", 30.0, 34.0),
        ]
        ordered = sort_clips_by_act(clips)
        acts = [c.act for c in ordered]
        assert acts == ["cold_open", "act1", "act3"]

    def test_within_same_act_chronological(self):
        """Clips within same act sorted by source_start_s ascending."""
        clips = [
            _make_clip("act3", 120.0, 122.0),
            _make_clip("act3", 90.0, 92.0, "money_shot"),
        ]
        ordered = sort_clips_by_act(clips)
        assert ordered[0].source_start_s == 90.0
        assert ordered[1].source_start_s == 120.0

    def test_full_act_order_sequence(self):
        """All six acts in the right order."""
        clips = [
            _make_clip("act3", 100.0, 102.0, "climax_peak"),
            _make_clip("breath", 80.0, 82.0, "breath"),
            _make_clip("act2", 60.0, 62.0),
            _make_clip("beat_drop", 45.0, 47.0, "money_shot"),
            _make_clip("act1", 20.0, 22.0, "character_introduction"),
            _make_clip("cold_open", 5.0, 7.0, "inciting_incident"),
        ]
        ordered = sort_clips_by_act(clips)
        expected_acts = ["cold_open", "act1", "beat_drop", "act2", "breath", "act3"]
        assert [c.act for c in ordered] == expected_acts

    def test_empty_clips_returns_empty(self):
        assert sort_clips_by_act([]) == []


class TestComputeActAvgDuration:
    """compute_act_avg_duration() correctness."""

    def test_returns_zero_for_missing_act(self):
        clips = [_make_clip("act1", 0.0, 5.0)]
        assert compute_act_avg_duration(clips, "act3") == 0.0

    def test_single_clip(self):
        clips = [_make_clip("act1", 10.0, 14.0)]
        assert compute_act_avg_duration(clips, "act1") == pytest.approx(4.0)

    def test_multiple_clips_average(self):
        clips = [
            _make_clip("act3", 100.0, 102.0),   # 2.0s
            _make_clip("act3", 110.0, 112.5),   # 2.5s
        ]
        avg = compute_act_avg_duration(clips, "act3")
        assert avg == pytest.approx(2.25)


class TestEnforcePacingCurve:
    """EDIT-03: enforce_pacing_curve() trims oversized act3 clips."""

    def test_no_trimming_when_within_threshold(self):
        profile = VIBE_PROFILES["action"]  # act3_avg_cut_s = 1.2, threshold = 1.8
        clips = [_make_clip("act3", 100.0, 101.5, "climax_peak")]  # 1.5s, within 1.8
        result = enforce_pacing_curve(clips, profile)
        assert result[0].source_end_s == pytest.approx(101.5)

    def test_trims_act3_clips_exceeding_threshold(self):
        """Action profile: act3_avg_cut_s=1.2, threshold=1.8. 10s clip should be trimmed."""
        profile = VIBE_PROFILES["action"]  # act3_avg_cut_s = 1.2
        clips = [
            _make_clip("act3", 100.0, 110.0, "climax_peak"),  # 10s >> 1.8 threshold
            _make_clip("act3", 120.0, 130.0, "money_shot"),   # 10s >> 1.8 threshold
        ]
        result = enforce_pacing_curve(clips, profile)
        for clip in result:
            duration = clip.source_end_s - clip.source_start_s
            assert duration <= profile.act3_avg_cut_s * 1.5 + 0.01, f"Clip too long: {duration:.2f}s"

    def test_never_trims_below_min_duration(self):
        """Min clip duration is 0.5s."""
        from cinecut.assembly.ordering import MIN_CLIP_DURATION_S
        profile = VIBE_PROFILES["action"]  # act3_avg_cut_s = 1.2
        # A clip that's already very short but would normally be trimmed further
        clips = [
            _make_clip("act3", 100.0, 110.0, "climax_peak"),  # 10s, gets trimmed to 1.2s
        ]
        result = enforce_pacing_curve(clips, profile)
        for clip in result:
            duration = clip.source_end_s - clip.source_start_s
            assert duration >= MIN_CLIP_DURATION_S

    def test_non_act3_clips_untouched(self):
        """enforce_pacing_curve() must NOT modify act1 or act2 clips."""
        profile = VIBE_PROFILES["action"]
        clips = [
            _make_clip("act1", 0.0, 20.0),   # 20s act1 clip (long but not act3)
            _make_clip("act3", 100.0, 110.0, "climax_peak"),  # gets trimmed
        ]
        result = enforce_pacing_curve(clips, profile)
        act1_result = next(c for c in result if c.act == "act1")
        assert act1_result.source_end_s == pytest.approx(20.0), "act1 clip should not be modified"

    def test_pacing_curve_decreasing_after_enforcement(self):
        """After enforcement, act1_avg > act3_avg (measurable pacing curve, EDIT-03)."""
        profile = VIBE_PROFILES["action"]
        clips = [
            _make_clip("act1", 0.0, 5.0),    # 5.0s act1 (action act1_avg_cut_s=4.0)
            _make_clip("act3", 100.0, 110.0, "climax_peak"),  # 10s -> trimmed to 1.2s
        ]
        result = enforce_pacing_curve(clips, profile)
        act1_avg = compute_act_avg_duration(result, "act1")
        act3_avg = compute_act_avg_duration(result, "act3")
        assert act1_avg > act3_avg, f"Pacing curve violated: act1={act1_avg:.2f}s, act3={act3_avg:.2f}s"
```
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_checkpoint.py tests/test_assembly.py -v 2>&1 | tail -40</automated>
  </verify>
  <done>
    - `tests/test_checkpoint.py` exists with `TestPipelineCheckpoint`, `TestLoadCheckpoint`, `TestSaveCheckpoint` classes
    - `tests/test_assembly.py` exists with `TestSortClipsByAct`, `TestComputeActAvgDuration`, `TestEnforcePacingCurve` classes
    - All tests in both files pass (0 failures)
    - Full suite still passes: `pytest tests/ -x -q --ignore=tests/test_inference.py -k "not integration"` shows green
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/adamh/ai-video-trailer

# 1. Verify imports work
python -c "
from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint
from cinecut.assembly import assemble_manifest
from cinecut.cli import app
print('All imports OK')
"

# 2. Run unit tests
python -m pytest tests/test_checkpoint.py tests/test_assembly.py -v

# 3. Full test suite (exclude inference integration tests)
python -m pytest tests/ -x -q --ignore=tests/test_inference.py -k "not integration"

# 4. Verify TOTAL_STAGES in cli.py
python -c "
import ast, pathlib
src = pathlib.Path('src/cinecut/cli.py').read_text()
assert 'TOTAL_STAGES' in src, 'TOTAL_STAGES constant missing from cli.py'
assert 'load_checkpoint' in src, 'load_checkpoint not imported in cli.py'
assert 'assemble_manifest' in src, 'assemble_manifest not imported in cli.py'
assert 'reordered_manifest' in src, 'reordered_manifest not used in cli.py'
print('cli.py structural checks PASS')
"

# 5. Verify conform_manifest accepts extra_clip_paths
python -c "
import inspect
from cinecut.conform.pipeline import conform_manifest
sig = inspect.signature(conform_manifest)
assert 'extra_clip_paths' in sig.parameters, 'extra_clip_paths param missing from conform_manifest'
print('conform_manifest signature check PASS')
"
```
</verification>

<success_criteria>
- `tests/test_checkpoint.py` and `tests/test_assembly.py` both pass with 0 failures
- Full non-inference test suite passes (96+ tests)
- `cli.py` contains `TOTAL_STAGES = 7`, `load_checkpoint`, `assemble_manifest`, `reordered_manifest`
- `conform_manifest()` accepts `extra_clip_paths` parameter
- Stage labels in CLI output updated to N/7 format
</success_criteria>

<output>
After completion, create `.planning/phases/05-trailer-assembly-and-end-to-end-pipeline/05-03-SUMMARY.md`
</output>
