---
phase: 02-manifest-contract-vibes-and-conform
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/cinecut/errors.py
  - src/cinecut/manifest/__init__.py
  - src/cinecut/manifest/schema.py
  - src/cinecut/manifest/loader.py
  - src/cinecut/manifest/vibes.py
  - src/cinecut/conform/__init__.py
  - src/cinecut/conform/luts.py
autonomous: true
requirements: [VIBE-01, VIBE-02]

must_haves:
  truths:
    - "A valid TRAILER_MANIFEST.json is accepted and parsed into a TrailerManifest object"
    - "A malformed manifest (missing required field, wrong type, invalid beat_type) is rejected with a clear ManifestError describing the field path and problem"
    - "All 18 VibeProfile instances are importable from cinecut.manifest.vibes and contain complete parameters"
    - "Calling ensure_luts(vibe_name, lut_dir) produces a .cube file that FFmpeg lut3d can consume"
    - "An identity LUT (saturation=1.0, contrast=1.0, temp_shift=0.0, brightness=0.0) produces no color change on a reference image"
  artifacts:
    - path: "src/cinecut/manifest/schema.py"
      provides: "TrailerManifest and ClipEntry Pydantic models"
      exports: ["TrailerManifest", "ClipEntry", "VALID_VIBES"]
    - path: "src/cinecut/manifest/loader.py"
      provides: "load_manifest() function"
      exports: ["load_manifest"]
    - path: "src/cinecut/manifest/vibes.py"
      provides: "VibeProfile dataclass and VIBE_PROFILES dict (18 entries)"
      exports: ["VibeProfile", "VIBE_PROFILES"]
    - path: "src/cinecut/conform/luts.py"
      provides: "ensure_luts() and generate_cube_lut() functions"
      exports: ["ensure_luts", "generate_cube_lut"]
    - path: "src/cinecut/errors.py"
      provides: "ManifestError and ConformError classes"
      contains: "class ManifestError"
  key_links:
    - from: "src/cinecut/manifest/loader.py"
      to: "pydantic.ValidationError"
      via: "model_validate_json() catch block"
      pattern: "model_validate_json"
    - from: "src/cinecut/conform/luts.py"
      to: "src/cinecut/manifest/vibes.py"
      via: "VIBE_PROFILES lookup by name"
      pattern: "VIBE_PROFILES\\["
    - from: "src/cinecut/manifest/schema.py"
      to: "src/cinecut/manifest/vibes.py"
      via: "VALID_VIBES set used in vibe field_validator"
      pattern: "VALID_VIBES"
---

<objective>
Define the manifest contract (Pydantic schema + loader), all 18 vibe profiles (dataclass instances), and the LUT generation module that produces .cube files from vibe parameters.

Purpose: Everything in Phase 2 depends on these types and data. The schema is a long-lived contract — Phase 4 will generate manifests that must satisfy it. The vibe profiles drive all color grading, audio, and pacing decisions throughout the pipeline.
Output: Importable manifest/ and conform/luts.py modules; 18 VibeProfile instances; ManifestError and ConformError in errors.py; pydantic and numpy added to pyproject.toml.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-manifest-contract-vibes-and-conform/02-RESEARCH.md

<interfaces>
<!-- Existing types the executor must NOT break -->

From src/cinecut/errors.py (extend, do not replace):
```python
class CineCutError(Exception): ...
class ProxyCreationError(CineCutError): ...
class KeyframeExtractionError(CineCutError): ...
class SubtitleParseError(CineCutError): ...
class ProxyValidationError(CineCutError): ...
# ADD: ManifestError, ConformError following same pattern
```

From src/cinecut/models.py (read-only reference):
```python
@dataclass
class DialogueEvent:
    start_ms: int; end_ms: int; start_s: float; end_s: float
    midpoint_s: float; text: str; emotion: str

@dataclass
class KeyframeRecord:
    timestamp_s: float; frame_path: str; source: str
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pydantic/numpy deps and create manifest schema + loader</name>
  <files>
    pyproject.toml
    src/cinecut/manifest/__init__.py
    src/cinecut/manifest/schema.py
    src/cinecut/manifest/loader.py
    src/cinecut/errors.py
  </files>
  <action>
    1. Update pyproject.toml: add `"pydantic>=2.12.0"` and `"numpy>=1.24.0"` to the dependencies list. Keep all existing deps unchanged.

    2. Create src/cinecut/manifest/__init__.py — empty package marker.

    3. Create src/cinecut/manifest/schema.py with Pydantic v2 models:

    ```python
    from pydantic import BaseModel, Field, field_validator, model_validator
    from typing import Literal
    from cinecut.manifest.vibes import VALID_VIBES  # imported after vibes.py is created

    class ClipEntry(BaseModel):
        source_start_s: float = Field(ge=0.0)
        source_end_s: float = Field(ge=0.0)
        beat_type: Literal[
            "inciting_incident", "character_introduction", "escalation_beat",
            "relationship_beat", "money_shot", "climax_peak", "breath"
        ]
        act: Literal[
            "cold_open", "act1", "beat_drop", "act2",
            "breath", "act3", "title_card", "button"
        ]
        transition: Literal["hard_cut", "crossfade", "fade_to_black", "fade_to_white"] = "hard_cut"
        dialogue_excerpt: str = ""

        @model_validator(mode="after")
        def end_after_start(self) -> "ClipEntry":
            if self.source_end_s <= self.source_start_s:
                raise ValueError(
                    f"source_end_s ({self.source_end_s}) must be > source_start_s ({self.source_start_s})"
                )
            return self

    class TrailerManifest(BaseModel):
        schema_version: str = "1.0"
        source_file: str
        vibe: str
        clips: list[ClipEntry] = Field(min_length=1)

        @field_validator("vibe", mode="before")
        @classmethod
        def normalize_vibe(cls, v: str) -> str:
            normalized = v.lower().replace(" ", "-")
            if normalized not in VALID_VIBES:
                raise ValueError(
                    f"Unknown vibe '{v}'. Valid vibes: {sorted(VALID_VIBES)}"
                )
            return normalized
    ```

    CRITICAL: The circular import between schema.py and vibes.py must be avoided. Move VALID_VIBES into a small constants module OR define VALID_VIBES as a module-level frozenset in schema.py directly (do not import from vibes.py — vibes.py will import from schema.py or be standalone). Best approach: define VALID_VIBES as a frozenset directly in schema.py. vibes.py does NOT import from schema.py.

    ```python
    # In schema.py — standalone, no import from vibes.py
    VALID_VIBES: frozenset[str] = frozenset({
        "action", "adventure", "animation", "comedy", "crime",
        "documentary", "drama", "family", "fantasy", "history",
        "horror", "music", "mystery", "romance", "sci-fi",
        "thriller", "war", "western",
    })
    ```

    The `normalize_vibe` validator accepts any of these case-insensitive variants: "Action", "action", "Sci-Fi", "sci-fi", "scifi" → normalize to lowercase with hyphen for multi-word. For "scifi" without hyphen, add explicit alias mapping: `{"scifi": "sci-fi"}`.

    4. Create src/cinecut/manifest/loader.py:

    ```python
    from pathlib import Path
    from pydantic import ValidationError
    from cinecut.manifest.schema import TrailerManifest
    from cinecut.errors import ManifestError

    def load_manifest(path: Path) -> TrailerManifest:
        """Load and validate TRAILER_MANIFEST.json. Raises ManifestError on failure."""
        try:
            return TrailerManifest.model_validate_json(
                path.read_text(encoding="utf-8")
            )
        except ValidationError as e:
            field_errors = "; ".join(
                f"{' -> '.join(str(x) for x in err['loc'])}: {err['msg']}"
                for err in e.errors()
            )
            raise ManifestError(path, f"Schema validation failed: {field_errors}") from e
        except (OSError, UnicodeDecodeError) as e:
            raise ManifestError(path, str(e)) from e
    ```

    5. Extend src/cinecut/errors.py: append ManifestError and ConformError classes following the existing pattern (name file, cause, corrective tip):

    ```python
    class ManifestError(CineCutError):
        def __init__(self, path: Path, detail: str) -> None:
            super().__init__(
                f"Cannot load manifest '{path.name}'.\n"
                f"  Cause: {detail}\n"
                f"  Check: Is the file valid JSON matching the TrailerManifest schema?\n"
                f"  Tip: Validate against the schema with: python -c \"from cinecut.manifest.loader import load_manifest; load_manifest('{path}')\""
            )
            self.path = path
            self.detail = detail

    class ConformError(CineCutError):
        def __init__(self, output_path: Path, detail: str) -> None:
            super().__init__(
                f"FFmpeg conform failed for '{output_path.name}'.\n"
                f"  Cause: {detail}\n"
                f"  Check: Is FFmpeg installed and in PATH? Is the source file accessible?\n"
                f"  Tip: Run the FFmpeg command manually with the same arguments to see full output."
            )
            self.output_path = output_path
            self.detail = detail
    ```

    6. Install: `pip install -e .` to make pydantic and numpy available.
  </action>
  <verify>
    ```
    python3 -c "
    import json, tempfile, pathlib
    from cinecut.manifest.schema import TrailerManifest, VALID_VIBES
    from cinecut.manifest.loader import load_manifest
    from cinecut.errors import ManifestError, ConformError

    # Valid manifest round-trip
    good = {
        'schema_version': '1.0',
        'source_file': '/films/test.mkv',
        'vibe': 'action',
        'clips': [{'source_start_s': 10.0, 'source_end_s': 14.0, 'beat_type': 'inciting_incident', 'act': 'cold_open'}]
    }
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        json.dump(good, f)
        p = pathlib.Path(f.name)
    m = load_manifest(p)
    assert m.vibe == 'action', f'expected action, got {m.vibe}'
    assert len(m.clips) == 1
    assert m.clips[0].source_start_s == 10.0
    p.unlink()

    # Vibe normalization
    m2 = TrailerManifest.model_validate({'source_file': '/f.mkv', 'vibe': 'Action', 'clips': [{'source_start_s': 0.0, 'source_end_s': 5.0, 'beat_type': 'breath', 'act': 'act1'}]})
    assert m2.vibe == 'action'

    # Reject bad manifest
    try:
        TrailerManifest.model_validate({'source_file': '/f.mkv', 'vibe': 'action', 'clips': [{'source_start_s': 5.0, 'source_end_s': 3.0, 'beat_type': 'breath', 'act': 'act1'}]})
        assert False, 'should have raised'
    except Exception:
        pass  # expected

    # VALID_VIBES has all 18
    assert len(VALID_VIBES) == 18, f'expected 18, got {len(VALID_VIBES)}'
    print('Task 1 PASS')
    "
    ```
  </verify>
  <done>
    - pyproject.toml declares pydantic>=2.12.0 and numpy>=1.24.0
    - TrailerManifest and ClipEntry Pydantic v2 models exist in schema.py
    - VALID_VIBES frozenset contains exactly 18 entries
    - load_manifest() loads valid JSON and raises ManifestError on bad JSON/validation failure
    - ManifestError and ConformError exist in errors.py following the existing error pattern
    - vibe field normalizes "Action" → "action", "Sci-Fi" → "sci-fi", "scifi" → "sci-fi"
    - ClipEntry rejects source_end_s <= source_start_s
  </done>
</task>

<task type="auto">
  <name>Task 2: Create VibeProfile dataclass with all 18 profiles</name>
  <files>
    src/cinecut/manifest/vibes.py
  </files>
  <action>
    Create src/cinecut/manifest/vibes.py with the VibeProfile frozen dataclass and all 18 vibe instances in a VIBE_PROFILES dict keyed by the normalized vibe name (lowercase, hyphenated).

    The dataclass (from research):
    ```python
    from dataclasses import dataclass

    @dataclass(frozen=True)
    class VibeProfile:
        name: str                    # canonical lowercase (e.g. "action", "sci-fi")
        temp_shift: float            # +warm/-cool applied to R and B channels
        saturation: float            # 1.0 = no change
        contrast: float              # 1.0 = no change, pivot at 0.5
        brightness: float            # uniform offset
        lufs_target: float           # integrated loudness target (negative)
        act1_avg_cut_s: float        # seconds per cut, Act 1
        act2_avg_cut_s: float        # seconds per cut, Act 2
        act3_avg_cut_s: float        # seconds per cut, Act 3
        clip_count_min: int
        clip_count_max: int
        dialogue_ratio: float        # 0.0 = all visual; 1.0 = all dialogue clips
        primary_transition: str      # "hard_cut" | "crossfade" | "fade_to_black"
        secondary_transition: str    # used at act boundaries
        lut_filename: str            # e.g. "action_teal_orange.cube"
        pacing_curve: str            # human description
    ```

    VIBE_PROFILES dict with all 18 entries using values from research:

    | Vibe       | temp   | sat   | con  | bri   | lufs  | a1   | a2   | a3   | min | max | dia  | primary     | secondary        | lut_file                  | curve                      |
    |------------|--------|-------|------|-------|-------|------|------|------|-----|-----|------|-------------|------------------|---------------------------|----------------------------|
    | action     | -0.05  | 1.15  | 1.20 | 0.00  | -14.0 | 4.0  | 2.5  | 1.2  | 25  | 35  | 0.25 | hard_cut    | hard_cut         | action_teal_orange.cube   | moderate → fast → montage  |
    | adventure  | 0.03   | 1.10  | 1.10 | 0.02  | -14.0 | 5.0  | 3.5  | 2.0  | 20  | 30  | 0.35 | crossfade   | fade_to_black    | adventure_warm.cube       | steady → brisk → swift     |
    | animation  | 0.00   | 1.25  | 1.00 | 0.03  | -16.0 | 5.0  | 3.5  | 2.5  | 18  | 25  | 0.40 | hard_cut    | crossfade        | animation_vivid.cube      | steady → brisk → punchy    |
    | comedy     | 0.05   | 1.10  | 0.90 | 0.03  | -16.0 | 5.0  | 4.0  | 3.0  | 15  | 22  | 0.55 | hard_cut    | crossfade        | comedy_warm_soft.cube     | relaxed → moderate → lively|
    | crime      | -0.05  | 0.75  | 1.25 | -0.02 | -18.0 | 5.0  | 3.5  | 2.0  | 20  | 28  | 0.40 | hard_cut    | fade_to_black    | crime_noir.cube           | measured → taut → sharp    |
    | documentary| 0.00   | 0.90  | 1.00 | 0.00  | -20.0 | 7.0  | 5.0  | 4.0  | 12  | 18  | 0.60 | crossfade   | crossfade        | documentary_neutral.cube  | slow → steady → deliberate |
    | drama      | -0.02  | 0.85  | 1.15 | -0.01 | -18.0 | 7.0  | 5.0  | 3.5  | 14  | 20  | 0.55 | crossfade   | fade_to_black    | drama_intimate.cube       | slow → steady → purposeful |
    | family     | 0.05   | 1.10  | 0.90 | 0.03  | -16.0 | 5.0  | 4.0  | 3.0  | 16  | 22  | 0.45 | crossfade   | crossfade        | family_warm.cube          | relaxed → moderate → lively|
    | fantasy    | 0.00   | 1.15  | 1.10 | 0.02  | -16.0 | 6.0  | 4.0  | 2.5  | 18  | 26  | 0.35 | crossfade   | fade_to_black    | fantasy_rich.cube         | measured → brisk → swift   |
    | history    | 0.07   | 0.80  | 1.15 | -0.02 | -18.0 | 7.0  | 5.0  | 3.5  | 14  | 20  | 0.55 | crossfade   | fade_to_black    | history_sepia.cube        | slow → steady → purposeful |
    | horror     | -0.03  | 0.70  | 1.35 | -0.05 | -20.0 | 6.0  | 4.0  | 1.8  | 20  | 28  | 0.30 | hard_cut    | fade_to_black    | horror_dark.cube          | tense → jarring → barrage  |
    | music      | 0.00   | 1.20  | 0.95 | 0.02  | -14.0 | 4.0  | 3.0  | 2.0  | 20  | 28  | 0.20 | hard_cut    | hard_cut         | music_vivid.cube          | brisk → fast → montage     |
    | mystery    | -0.04  | 0.75  | 1.20 | -0.03 | -18.0 | 6.0  | 4.5  | 3.0  | 16  | 22  | 0.45 | crossfade   | fade_to_black    | mystery_muted.cube        | measured → taut → deliberate|
    | romance    | 0.07   | 1.05  | 0.85 | 0.04  | -18.0 | 7.0  | 5.0  | 4.0  | 12  | 18  | 0.55 | crossfade   | fade_to_black    | romance_warm.cube         | slow → steady → tender     |
    | sci-fi     | -0.08  | 0.90  | 1.25 | -0.02 | -14.0 | 5.0  | 3.5  | 2.0  | 22  | 30  | 0.35 | hard_cut    | fade_to_black    | scifi_cold.cube           | measured → brisk → rapid   |
    | thriller   | -0.04  | 0.85  | 1.30 | -0.03 | -16.0 | 5.0  | 3.0  | 1.5  | 25  | 35  | 0.30 | hard_cut    | fade_to_black    | thriller_tense.cube       | taut → fast → barrage      |
    | war        | -0.02  | 0.70  | 1.20 | -0.03 | -16.0 | 5.0  | 3.0  | 1.5  | 25  | 35  | 0.25 | hard_cut    | hard_cut         | war_desaturated.cube      | heavy → fast → assault     |
    | western    | 0.08   | 0.85  | 1.15 | -0.01 | -18.0 | 6.0  | 4.5  | 3.0  | 16  | 22  | 0.45 | crossfade   | fade_to_black    | western_amber.cube        | steady → measured → purposeful|

    The dict key must exactly match an entry in schema.py's VALID_VIBES. Use the lowercase hyphenated form as the key (e.g., `"sci-fi"`, not `"scifi"`).
  </action>
  <verify>
    ```
    python3 -c "
    from cinecut.manifest.vibes import VIBE_PROFILES, VibeProfile
    from cinecut.manifest.schema import VALID_VIBES

    # All 18 vibes present
    assert len(VIBE_PROFILES) == 18, f'expected 18, got {len(VIBE_PROFILES)}'

    # Keys match VALID_VIBES
    assert set(VIBE_PROFILES.keys()) == VALID_VIBES, f'key mismatch: {set(VIBE_PROFILES.keys()) ^ VALID_VIBES}'

    # Spot-check action profile
    a = VIBE_PROFILES['action']
    assert a.lufs_target == -14.0
    assert a.saturation == 1.15
    assert a.lut_filename == 'action_teal_orange.cube'
    assert a.act1_avg_cut_s == 4.0
    assert a.act3_avg_cut_s == 1.2

    # Spot-check horror (darkest profile)
    h = VIBE_PROFILES['horror']
    assert h.brightness == -0.05
    assert h.contrast == 1.35

    # sci-fi key is hyphenated
    assert 'sci-fi' in VIBE_PROFILES

    # All profiles are frozen dataclass instances
    for name, profile in VIBE_PROFILES.items():
        assert isinstance(profile, VibeProfile), f'{name} is not VibeProfile'
        assert profile.name == name, f'profile.name {profile.name!r} != key {name!r}'

    print('Task 2 PASS')
    "
    ```
  </verify>
  <done>
    - VIBE_PROFILES dict contains exactly 18 entries keyed by lowercase vibe name
    - All keys match VALID_VIBES frozenset from schema.py
    - Each VibeProfile has correct color params, lufs_target, pacing params, and lut_filename matching the research tables
    - VibeProfile instances are frozen (immutable)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create LUT generation module (conform/luts.py)</name>
  <files>
    src/cinecut/conform/__init__.py
    src/cinecut/conform/luts.py
  </files>
  <action>
    Create src/cinecut/conform/__init__.py — empty package marker.

    Create src/cinecut/conform/luts.py with two public functions:

    **generate_cube_lut(title, size, temp_shift, saturation, contrast, brightness, output_path) -> Path**
    Generates a .cube LUT file using NumPy. CRITICAL loop order (from research anti-patterns): iterate `for bi in range(size): for gi in range(size): for ri in range(size):` and index arrays as `[ri, gi, bi]`. R is FASTEST (innermost), B is SLOWEST (outermost).

    Algorithm (from research Pattern 2):
    1. Build identity grid: `vals = np.linspace(0.0, 1.0, size)`, then `r, g, b = np.meshgrid(vals, vals, vals, indexing='ij')`
    2. Apply saturation (pivot around luma): `luma = 0.299*r + 0.587*g + 0.114*b`
    3. Apply contrast (pivot at 0.5)
    4. Apply temp_shift (add to R, subtract from B)
    5. Apply brightness (add uniformly)
    6. Clamp to [0, 1] with `np.clip`
    7. Write header then data in B-outer G-middle R-inner order

    .cube file format:
    ```
    TITLE "title"
    LUT_3D_SIZE 33
    DOMAIN_MIN 0.0 0.0 0.0
    DOMAIN_MAX 1.0 1.0 1.0
    <r g b triplets, one per line, 6 decimal places>
    ```

    Use size=33 (research recommendation: professional standard, fast with NumPy vectorization).

    **ensure_luts(vibe_name: str, lut_dir: Path) -> Path**
    - Looks up vibe_name (normalized lowercase) in VIBE_PROFILES
    - Constructs output_path = lut_dir / profile.lut_filename
    - If output_path already exists, returns it immediately (idempotent)
    - Otherwise calls generate_cube_lut() with the profile's color parameters
    - Creates lut_dir if it does not exist
    - Returns the .cube file Path

    Error handling: if vibe_name not in VIBE_PROFILES, raise ValueError (not ConformError — this is a programming error, not a runtime failure).

    Full implementation of luts.py:
    ```python
    import numpy as np
    from pathlib import Path
    from cinecut.manifest.vibes import VIBE_PROFILES

    LUT_SIZE = 33

    def generate_cube_lut(
        title: str,
        size: int,
        temp_shift: float,
        saturation: float,
        contrast: float,
        brightness: float,
        output_path: Path,
    ) -> Path:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        vals = np.linspace(0.0, 1.0, size)
        r, g, b = np.meshgrid(vals, vals, vals, indexing='ij')
        # Saturation: pivot around luma
        luma = 0.299 * r + 0.587 * g + 0.114 * b
        r_out = luma + saturation * (r - luma)
        g_out = luma + saturation * (g - luma)
        b_out = luma + saturation * (b - luma)
        # Contrast: pivot at 0.5
        r_out = (r_out - 0.5) * contrast + 0.5
        g_out = (g_out - 0.5) * contrast + 0.5
        b_out = (b_out - 0.5) * contrast + 0.5
        # Temperature shift
        r_out = r_out + temp_shift
        b_out = b_out - temp_shift
        # Brightness
        r_out = r_out + brightness
        g_out = g_out + brightness
        b_out = b_out + brightness
        # Clamp
        r_out = np.clip(r_out, 0.0, 1.0)
        g_out = np.clip(g_out, 0.0, 1.0)
        b_out = np.clip(b_out, 0.0, 1.0)
        with open(output_path, "w") as f:
            f.write(f'TITLE "{title}"\n')
            f.write(f"LUT_3D_SIZE {size}\n")
            f.write("DOMAIN_MIN 0.0 0.0 0.0\n")
            f.write("DOMAIN_MAX 1.0 1.0 1.0\n")
            # CRITICAL: R fastest (innermost), B slowest (outermost)
            for bi in range(size):
                for gi in range(size):
                    for ri in range(size):
                        f.write(f"{r_out[ri, gi, bi]:.6f} {g_out[ri, gi, bi]:.6f} {b_out[ri, gi, bi]:.6f}\n")
        return output_path

    def ensure_luts(vibe_name: str, lut_dir: Path) -> Path:
        if vibe_name not in VIBE_PROFILES:
            raise ValueError(f"Unknown vibe '{vibe_name}'. Available: {sorted(VIBE_PROFILES)}")
        profile = VIBE_PROFILES[vibe_name]
        output_path = lut_dir / profile.lut_filename
        if output_path.exists():
            return output_path
        lut_dir.mkdir(parents=True, exist_ok=True)
        return generate_cube_lut(
            title=profile.lut_filename.replace(".cube", ""),
            size=LUT_SIZE,
            temp_shift=profile.temp_shift,
            saturation=profile.saturation,
            contrast=profile.contrast,
            brightness=profile.brightness,
            output_path=output_path,
        )
    ```
  </action>
  <verify>
    ```
    python3 -c "
    import tempfile, pathlib
    from cinecut.conform.luts import ensure_luts, generate_cube_lut, LUT_SIZE

    tmpdir = pathlib.Path(tempfile.mkdtemp())

    # Identity LUT: verify file format
    identity_path = tmpdir / 'identity.cube'
    generate_cube_lut('identity', 2, 0.0, 1.0, 1.0, 0.0, identity_path)
    lines = identity_path.read_text().splitlines()
    assert lines[0] == 'TITLE \"identity\"'
    assert lines[1] == 'LUT_3D_SIZE 2'
    assert lines[2] == 'DOMAIN_MIN 0.0 0.0 0.0'
    assert lines[3] == 'DOMAIN_MAX 1.0 1.0 1.0'
    # size=2: 2^3 = 8 triplets
    data_lines = [l for l in lines[4:] if l.strip()]
    assert len(data_lines) == 8, f'expected 8 data lines, got {len(data_lines)}'
    # First triplet (R=0,G=0,B=0) -> 0.000000 0.000000 0.000000
    assert data_lines[0] == '0.000000 0.000000 0.000000', f'got: {data_lines[0]}'
    # Second triplet (R=1,G=0,B=0) -> 1.000000 0.000000 0.000000 (R fastest)
    assert data_lines[1] == '1.000000 0.000000 0.000000', f'got: {data_lines[1]}'

    # ensure_luts: action profile
    lut_path = ensure_luts('action', tmpdir)
    assert lut_path.exists(), 'action LUT not created'
    assert lut_path.name == 'action_teal_orange.cube'
    # Idempotent: calling again returns same path
    lut_path2 = ensure_luts('action', tmpdir)
    assert lut_path2 == lut_path

    # LUT_SIZE is 33
    assert LUT_SIZE == 33

    # ensure_luts with full 33^3: file has 33^3 + 4 lines
    lines33 = lut_path.read_text().splitlines()
    data33 = [l for l in lines33[4:] if l.strip()]
    assert len(data33) == 33**3, f'expected {33**3} lines, got {len(data33)}'

    print('Task 3 PASS')
    "
    ```
  </verify>
  <done>
    - conform/__init__.py exists
    - generate_cube_lut() writes valid .cube format: header (TITLE, LUT_3D_SIZE, DOMAIN_MIN, DOMAIN_MAX) + 33^3 RGB triplets with R as innermost loop
    - Identity LUT (saturation=1.0, contrast=1.0, temp_shift=0.0, brightness=0.0): first triplet is "0.000000 0.000000 0.000000", second is "1.000000 0.000000 0.000000" (R fastest)
    - ensure_luts() is idempotent; creates lut_dir if needed; returns .cube Path for any valid vibe name
    - ensure_luts('action', dir) produces a file named "action_teal_orange.cube"
  </done>
</task>

</tasks>

<verification>
All three tasks complete:
- `python3 -c "from cinecut.manifest.schema import TrailerManifest, VALID_VIBES; from cinecut.manifest.loader import load_manifest; from cinecut.manifest.vibes import VIBE_PROFILES; from cinecut.conform.luts import ensure_luts; assert len(VALID_VIBES) == 18; assert len(VIBE_PROFILES) == 18; print('OK')"`
- pyproject.toml contains pydantic>=2.12.0 and numpy>=1.24.0
- errors.py contains ManifestError and ConformError
</verification>

<success_criteria>
- Pydantic v2 TrailerManifest and ClipEntry models load valid manifests and reject malformed ones with field-level error messages
- VALID_VIBES frozenset has exactly 18 entries
- VIBE_PROFILES dict has exactly 18 entries keyed by lowercase vibe name, all matching VALID_VIBES
- All VibeProfile instances have correct parameters per research tables
- generate_cube_lut() produces .cube files with correct R-inner B-outer data ordering
- ensure_luts() is idempotent and generates a 33^3 LUT for any of the 18 vibes
- ManifestError and ConformError follow the existing error pattern in errors.py
</success_criteria>

<output>
After completion, create `.planning/phases/02-manifest-contract-vibes-and-conform/02-01-SUMMARY.md`
</output>
