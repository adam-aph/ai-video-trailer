---
phase: 02-manifest-contract-vibes-and-conform
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/cinecut/conform/pipeline.py
  - src/cinecut/cli.py
autonomous: true
requirements: [EDIT-04, EDIT-05, VIBE-03, VIBE-04, CLI-04]

must_haves:
  truths:
    - "Given a hand-crafted manifest, conform_manifest() extracts all clips, applies the vibe LUT and LUFS normalization, and concatenates them into a single MP4"
    - "Each extracted clip begins at exactly the requested source_start_s timecode (frame-accurate, not nearest keyframe)"
    - "The output file is named <source_basename>_trailer_<vibe>.mp4 at source resolution"
    - "With --review flag, the CLI prints the manifest path and waits for user confirmation before running conform"
    - "With --manifest flag and no --review, the CLI runs conform immediately and produces the output MP4"
    - "Short clips < 3.0s use a fixed volume filter instead of two-pass loudnorm"
    - "Clips longer than 3.0s use two-pass loudnorm for linear audio normalization"
  artifacts:
    - path: "src/cinecut/conform/pipeline.py"
      provides: "conform_manifest() orchestrator and extract_and_grade_clip() helper"
      exports: ["conform_manifest", "extract_and_grade_clip", "concatenate_clips"]
    - path: "src/cinecut/cli.py"
      provides: "Extended CLI with --manifest and --review conform stages"
      contains: "manifest"
  key_links:
    - from: "src/cinecut/conform/pipeline.py"
      to: "src/cinecut/conform/luts.py"
      via: "ensure_luts(vibe_name, work_dir/luts)"
      pattern: "ensure_luts"
    - from: "src/cinecut/conform/pipeline.py"
      to: "src/cinecut/manifest/schema.py"
      via: "TrailerManifest.clips iteration"
      pattern: "manifest\\.clips"
    - from: "src/cinecut/cli.py"
      to: "src/cinecut/conform/pipeline.py"
      via: "conform_manifest(manifest, source, vibe_profile, work_dir)"
      pattern: "conform_manifest"
    - from: "src/cinecut/cli.py"
      to: "typer.confirm"
      via: "--review pause before conform"
      pattern: "typer\\.confirm"
---

<objective>
Build the FFmpeg conform pipeline (per-clip extraction + lut3d + two-pass loudnorm + concat) and wire it into the CLI with --manifest and --review flags.

Purpose: This is the delivery mechanism — it turns a manifest and vibe profile into a final trailer MP4. Without this, the schema and vibe profiles in plan 02-01 have no runtime effect.
Output: conform/pipeline.py with conform_manifest(); updated cli.py accepting --manifest and --review that runs the full conform pipeline.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-manifest-contract-vibes-and-conform/02-RESEARCH.md
@.planning/phases/02-manifest-contract-vibes-and-conform/02-01-SUMMARY.md

<interfaces>
<!-- Contracts from plan 02-01 that this plan builds against -->

From src/cinecut/manifest/schema.py:
```python
from typing import Literal
from pydantic import BaseModel, Field

class ClipEntry(BaseModel):
    source_start_s: float
    source_end_s: float
    beat_type: Literal["inciting_incident", "character_introduction", "escalation_beat",
                       "relationship_beat", "money_shot", "climax_peak", "breath"]
    act: Literal["cold_open", "act1", "beat_drop", "act2", "breath", "act3", "title_card", "button"]
    transition: Literal["hard_cut", "crossfade", "fade_to_black", "fade_to_white"] = "hard_cut"
    dialogue_excerpt: str = ""

class TrailerManifest(BaseModel):
    schema_version: str
    source_file: str
    vibe: str  # normalized lowercase
    clips: list[ClipEntry]
```

From src/cinecut/manifest/loader.py:
```python
def load_manifest(path: Path) -> TrailerManifest: ...
```

From src/cinecut/manifest/vibes.py:
```python
@dataclass(frozen=True)
class VibeProfile:
    name: str
    temp_shift: float; saturation: float; contrast: float; brightness: float
    lufs_target: float
    act1_avg_cut_s: float; act2_avg_cut_s: float; act3_avg_cut_s: float
    clip_count_min: int; clip_count_max: int
    dialogue_ratio: float
    primary_transition: str; secondary_transition: str
    lut_filename: str; pacing_curve: str

VIBE_PROFILES: dict[str, VibeProfile]  # 18 entries, keyed by normalized name
```

From src/cinecut/conform/luts.py:
```python
def ensure_luts(vibe_name: str, lut_dir: Path) -> Path: ...
```

From src/cinecut/errors.py:
```python
class ConformError(CineCutError):
    def __init__(self, output_path: Path, detail: str) -> None: ...
class ManifestError(CineCutError):
    def __init__(self, path: Path, detail: str) -> None: ...
```

From src/cinecut/cli.py (existing Phase 1 structure):
- app = typer.Typer(name="cinecut")
- console = Console(); err_console = Console(stderr=True)
- _setup_work_dir(source: Path) -> Path  (already creates work_dir/keyframes/)
- main() has: video, subtitle, vibe, review params already declared
- All Phase 1 stages are in main() try block
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build FFmpeg conform pipeline</name>
  <files>
    src/cinecut/conform/pipeline.py
  </files>
  <action>
    Create src/cinecut/conform/pipeline.py implementing three functions:

    **extract_and_grade_clip(source, start_s, end_s, lut_path, lufs_target, output_path) -> Path**

    Frame-accurate clip extraction with lut3d + two-pass loudnorm. From research Pattern 3:
    - duration = end_s - start_s
    - If duration < 3.0: skip loudnorm two-pass; use `-af "volume=0dB"` (no-op gain) in a single FFmpeg call that still applies the LUT. This handles Act 3 montage clips (avg 1.2-1.8s) per research open question #3.
    - If duration >= 3.0: run loudnorm two-pass:
      - Pass 1: `ffmpeg -ss {start_s} -i {source} -t {duration} -af loudnorm=I={lufs_target}:LRA=7:tp=-2:print_format=json -f null -`
      - Parse JSON from stderr using `re.search(r'\{[^}]+\}', stderr, re.DOTALL)` — extract `input_i`, `input_lra`, `input_tp`, `input_thresh`, `target_offset`
      - Pass 2: `ffmpeg -y -ss {start_s} -i {source} -t {duration} -vf lut3d=file={lut_path} -af loudnorm=I=... -c:v libx264 -crf 18 -preset veryfast -c:a aac -ar 48000 -avoid_negative_ts make_zero {output_path}`
      - If pass 1 JSON not found: raise ConformError(output_path, "loudnorm pass 1 did not produce JSON stats")
      - If pass 2 returncode != 0: raise ConformError(output_path, result.stderr[-500:])
    - For the short-clip path (< 3.0s), single FFmpeg call:
      `ffmpeg -y -ss {start_s} -i {source} -t {duration} -vf lut3d=file={lut_path} -af volume=0dB -c:v libx264 -crf 18 -preset veryfast -c:a aac -ar 48000 -avoid_negative_ts make_zero {output_path}`
    - Always use subprocess.run(cmd, capture_output=True, text=True, check=False) — never shell=True

    **concatenate_clips(clip_paths: list[Path], output_path: Path) -> Path**

    Concat demuxer approach from research Pattern 4:
    - Write concat list file at output_path.parent / "_concat_list.txt"
    - Escape single quotes in paths: `str(p).replace("'", "'\\''")`
    - Command: `ffmpeg -y -f concat -safe 0 -i {concat_list} -c copy {output_path}`
    - If returncode != 0: raise ConformError(output_path, result.stderr[-500:])
    - Delete concat_list.txt after success: `concat_list.unlink(missing_ok=True)`
    - Return output_path

    **conform_manifest(manifest: TrailerManifest, source: Path, work_dir: Path) -> Path**

    Main orchestrator:
    1. Look up vibe profile: `profile = VIBE_PROFILES[manifest.vibe]` (vibe already normalized by schema)
    2. Ensure LUT: `lut_path = ensure_luts(manifest.vibe, work_dir / "luts")`
    3. Create clips output dir: `clips_dir = work_dir / "conform_clips"`, create it
    4. For each clip in manifest.clips (enumerate for naming):
       - output = clips_dir / f"clip_{i:04d}.mp4"
       - call extract_and_grade_clip(source, clip.source_start_s, clip.source_end_s, lut_path, profile.lufs_target, output)
    5. Build output name per CLI-04: `make_output_path(source, manifest.vibe)` where:
       `vibe_slug = manifest.vibe.replace("-", "_"); return source.parent / f"{source.stem}_trailer_{vibe_slug}.mp4"`
    6. Call concatenate_clips([clip paths in order], final_output_path)
    7. Return final_output_path

    Import all needed symbols. Full imports:
    ```python
    import json
    import re
    import subprocess
    from pathlib import Path
    from cinecut.manifest.schema import TrailerManifest
    from cinecut.manifest.vibes import VIBE_PROFILES
    from cinecut.conform.luts import ensure_luts
    from cinecut.errors import ConformError
    ```

    Minimum clip duration constant: `MIN_LOUDNORM_DURATION_S = 3.0`
  </action>
  <verify>
    ```
    python3 -c "
    import inspect
    from cinecut.conform.pipeline import conform_manifest, extract_and_grade_clip, concatenate_clips

    # Verify all three functions are importable and have correct signatures
    sig = inspect.signature(conform_manifest)
    params = list(sig.parameters.keys())
    assert 'manifest' in params, f'manifest not in conform_manifest params: {params}'
    assert 'source' in params, f'source not in params: {params}'
    assert 'work_dir' in params, f'work_dir not in params: {params}'

    sig2 = inspect.signature(extract_and_grade_clip)
    params2 = list(sig2.parameters.keys())
    assert 'lut_path' in params2, f'lut_path not in extract_and_grade_clip params: {params2}'
    assert 'lufs_target' in params2, f'lufs_target not in params: {params2}'

    from cinecut.conform.pipeline import MIN_LOUDNORM_DURATION_S
    assert MIN_LOUDNORM_DURATION_S == 3.0

    print('Task 1 PASS (import and signature check)')
    "
    ```
    Note: Full end-to-end FFmpeg testing happens in plan 02-03 (human-verify checkpoint). This task verify covers correctness of the Python structure. If FFmpeg is available, also manually verify: `ffmpeg -version | head -1` to confirm it is installed.
  </verify>
  <done>
    - conform/pipeline.py imports cleanly with no errors
    - conform_manifest(), extract_and_grade_clip(), and concatenate_clips() all exist with correct signatures
    - MIN_LOUDNORM_DURATION_S = 3.0 constant exists
    - Short clips (< 3.0s) use single-pass with volume=0dB
    - Long clips (>= 3.0s) use two-pass loudnorm with JSON stat extraction from stderr
    - All FFmpeg commands use list form (never shell=True), -ss before -i, re-encode with libx264 crf 18
    - concatenate_clips() uses concat demuxer with -safe 0 and escaped paths
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --manifest and --review into CLI</name>
  <files>
    src/cinecut/cli.py
  </files>
  <action>
    Extend src/cinecut/cli.py to add conform stages (Phase 2) while preserving all Phase 1 ingestion stages intact.

    Changes needed:

    1. Add imports at top of file:
    ```python
    from cinecut.manifest.loader import load_manifest
    from cinecut.conform.pipeline import conform_manifest
    from cinecut.errors import ManifestError, ConformError
    ```

    2. Add --manifest optional parameter to main():
    ```python
    manifest: Annotated[
        Optional[Path],
        typer.Option(
            "--manifest", "-m",
            file_okay=True,
            dir_okay=False,
            resolve_path=True,
            help="Path to TRAILER_MANIFEST.json. Skips ingestion stages and runs conform directly.",
        ),
    ] = None,
    ```
    Also add `from typing import Optional` to imports if not already present, or use `Path | None` with Python 3.10+ union syntax.

    3. Add vibe validation in main() BEFORE any stage runs, immediately after the existing extension/existence checks:
    ```python
    from cinecut.manifest.vibes import VIBE_PROFILES
    vibe_normalized = vibe.lower().replace(" ", "-")
    if vibe_normalized not in VIBE_PROFILES:
        err_console.print(Panel(
            f"Unknown vibe: [bold]{vibe}[/bold]\n"
            f"Valid vibes: {', '.join(sorted(VIBE_PROFILES))}",
            title="[red]Input Error[/red]",
            border_style="red",
        ))
        raise typer.Exit(1)
    ```

    4. After Phase 1 ingestion stages (or after vibe validation if --manifest is provided), add the conform logic. Structure the flow:

    ```python
    # If --manifest provided, skip ingestion stages (load manifest and jump to conform)
    if manifest is not None:
        # Validate manifest file existence and extension
        if not manifest.exists():
            err_console.print(Panel(f"Manifest file not found: {manifest}", title="[red]Input Error[/red]", border_style="red"))
            raise typer.Exit(1)
        # Load and validate manifest
        trailer_manifest = load_manifest(manifest)
        # Validate manifest vibe matches CLI vibe
        if trailer_manifest.vibe != vibe_normalized:
            err_console.print(Panel(
                f"Manifest vibe '[bold]{trailer_manifest.vibe}[/bold]' does not match --vibe '[bold]{vibe}[/bold]'.\n"
                f"Either update the manifest or pass --vibe {trailer_manifest.vibe}",
                title="[red]Input Error[/red]",
                border_style="red",
            ))
            raise typer.Exit(1)
    else:
        trailer_manifest = None  # will be set by Phase 4 in future phases
    ```

    5. After the Phase 1 ingestion block (inside the existing try block), add conform stage:

    ```python
    # --- Stage 4: Conform (EDIT-05 / CLI-04) ---
    if trailer_manifest is not None:
        # --review pause (EDIT-04)
        if review:
            console.print(f"\n[bold yellow]Review mode:[/bold yellow] Manifest loaded from:\n  {manifest}")
            console.print("[dim]Inspect clip decisions in the manifest, then confirm to continue.[/dim]\n")
            typer.confirm("Proceed with FFmpeg conform?", abort=True)

        console.print("[bold]Stage 4/4:[/bold] Running FFmpeg conform...")
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            TimeElapsedColumn(),
            console=console,
        ) as progress:
            conform_task = progress.add_task(
                f"Processing {len(trailer_manifest.clips)} clips...", total=None
            )
            output_path = conform_manifest(trailer_manifest, video, work_dir)
            progress.update(conform_task, description="Conform complete")

        console.print(Panel(
            f"[bold green]Conform complete[/bold green]\n\n"
            f"  Output: [dim]{output_path}[/dim]\n"
            f"  Clips:  {len(trailer_manifest.clips)}\n"
            f"  Vibe:   {trailer_manifest.vibe}",
            title="[green]Trailer Ready[/green]",
            border_style="green",
        ))
    ```

    6. Extend the existing except block to also catch ManifestError and ConformError (they already inherit from CineCutError so the existing `except CineCutError` block handles them — verify this is the case; if so, no change needed to the except clause).

    The updated main() signature will have params: video, subtitle, vibe, review, manifest.

    IMPORTANT: Preserve ALL Phase 1 code exactly as written. Only ADD new code — do not modify existing proxy/subtitle/keyframe stages. The --manifest flag causes ingestion to be skipped via the `if manifest is not None` branch at the top of the try block.

    Structure of updated main() flow:
    ```
    [validate video extension + existence]
    [validate subtitle extension + existence]
    [validate vibe]
    [setup work_dir]
    try:
        if manifest is not None:
            [load and validate manifest]
            [check vibe consistency]
        else:
            [Stage 1: proxy creation]  <- Phase 1 (unchanged)
            [Stage 2: subtitle parsing]  <- Phase 1 (unchanged)
            [Stage 3: keyframe extraction]  <- Phase 1 (unchanged)
            [Phase 1 summary panel]

        if trailer_manifest is not None:
            [--review pause if review=True]
            [Stage 4: conform]
            [conform summary panel]
    except CineCutError as e:
        [Rich error panel]
        raise typer.Exit(1)
    ```
  </action>
  <verify>
    ```
    python3 -c "
    import subprocess, sys
    # Verify CLI loads without import errors
    result = subprocess.run(
        [sys.executable, '-c', 'from cinecut.cli import app; print(\"CLI imports OK\")'],
        capture_output=True, text=True
    )
    print(result.stdout.strip())
    if result.returncode != 0:
        print('FAIL:', result.stderr)
        exit(1)
    "
    # Verify --help shows --manifest and --review options
    cinecut --help
    ```
    Also verify: `cinecut --help` output includes `--manifest`, `--review`, and `--vibe` options.
  </verify>
  <done>
    - cli.py imports cleanly: from cinecut.manifest.loader import load_manifest; from cinecut.conform.pipeline import conform_manifest
    - cinecut --help shows --manifest/-m option and --review option
    - All Phase 1 ingestion stages are unchanged (proxy, subtitles, keyframes)
    - With --manifest flag pointing to a valid JSON, CLI loads manifest and conditionally runs conform
    - With --review flag, CLI prints manifest path and calls typer.confirm(abort=True) before conform
    - Invalid vibe name shows Rich error panel listing valid vibes and exits 1
    - ManifestError and ConformError are caught by existing except CineCutError block
  </done>
</task>

</tasks>

<verification>
Both tasks complete:
- `python3 -c "from cinecut.conform.pipeline import conform_manifest, extract_and_grade_clip, concatenate_clips, MIN_LOUDNORM_DURATION_S; print('pipeline OK')"`
- `python3 -c "from cinecut.cli import app; print('CLI OK')"`
- `cinecut --help` shows --manifest and --review options
</verification>

<success_criteria>
- conform/pipeline.py implements frame-accurate FFmpeg extraction (-ss before -i, re-encode) with lut3d and two-pass loudnorm
- Short clips < 3.0s use volume=0dB instead of loudnorm two-pass
- concatenate_clips() uses concat demuxer with -safe 0 and single-quote escaping
- Output path follows CLI-04 pattern: {source.stem}_trailer_{vibe}.mp4
- CLI accepts --manifest flag pointing to a TRAILER_MANIFEST.json
- With --review, CLI pauses with typer.confirm(abort=True) before conform
- All Phase 1 stages remain unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-manifest-contract-vibes-and-conform/02-02-SUMMARY.md`
</output>
