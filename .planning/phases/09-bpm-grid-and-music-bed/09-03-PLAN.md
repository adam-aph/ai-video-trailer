---
phase: 09-bpm-grid-and-music-bed
plan: "03"
type: execute
wave: 2
depends_on:
  - "09-01"
  - "09-02"
files_modified:
  - src/cinecut/assembly/ordering.py
  - src/cinecut/assembly/__init__.py
  - src/cinecut/cli.py
  - tests/test_bpm.py
  - tests/test_music.py
autonomous: true
requirements:
  - EORD-04
  - BPMG-01
  - BPMG-02
  - BPMG-03
  - MUSC-01
  - MUSC-02
  - MUSC-03

must_haves:
  truths:
    - "A 4-second black video + silent audio segment is inserted between the last ESCALATION-zone clip and the first CLIMAX-zone clip in the assembled output"
    - "Music fetch and BPM detection run as Stage 7 in cli.py before conform (Stage 8)"
    - "Clip start points are snapped to the beat grid after fetch (assemble_manifest returns snapped clips)"
    - "Pipeline continues to produce a trailer even when music fetch returns None (MUSC-03)"
    - "BpmGrid and MusicBed metadata are recorded in TrailerManifest before manifest is written"
    - "Unit tests cover: generate_silence_segment file exists, snap_clips_to_grid snapping, resolve_bpm guards, fetch_music_for_vibe None return"
  artifacts:
    - path: "src/cinecut/assembly/ordering.py"
      provides: "generate_silence_segment() and insert_silence_at_zone_boundary() functions"
      exports:
        - SILENCE_DURATION_S
        - generate_silence_segment
        - insert_silence_at_zone_boundary
    - path: "src/cinecut/assembly/__init__.py"
      provides: "assemble_manifest updated to: fetch music, detect BPM, snap clip starts, insert silence segment, record manifest metadata"
    - path: "src/cinecut/cli.py"
      provides: "Stage 7 (music+BPM) added; TOTAL_STAGES bumped to 8; Stage 8 conform"
    - path: "tests/test_bpm.py"
      provides: "Unit tests for resolve_bpm guards, beat snapping, generate_beat_grid vibe_default fallback"
    - path: "tests/test_music.py"
      provides: "Unit tests for fetch_music_for_vibe graceful None, MusicBed cache hit path, atomic download logic"
  key_links:
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/music.py fetch_music_for_vibe()"
      via: "music_bed = fetch_music_for_vibe(manifest.vibe) called inside assemble_manifest"
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/bpm.py generate_beat_grid()"
      via: "bpm_grid = generate_beat_grid(music_bed.local_path, vibe, trailer_duration_s) when music_bed is not None"
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/ordering.py insert_silence_at_zone_boundary()"
      via: "silence_path = insert_silence_at_zone_boundary(paced_clips, work_dir, width, height, frame_rate)"
    - from: "assembly/ordering.py generate_silence_segment()"
      to: "conform/pipeline.py concat demuxer"
      via: "silence_path added to extra_paths list returned from assemble_manifest"
    - from: "cli.py Stage 7"
      to: "assembly/__init__.py assemble_manifest()"
      via: "reordered_manifest, extra_paths = assemble_manifest(trailer_manifest, video, work_dir); now includes music+BPM inside assemble_manifest"
---

<objective>
Wire BPM detection and music fetching into assemble_manifest(). Insert the 4-second Act 2-to-Act 3 silence
segment. Add Stage 7 (music+BPM) in cli.py and bump TOTAL_STAGES to 8. Write unit tests for all Phase 9
pure functions.

Purpose: This is the integration plan — Plans 01 and 02 create the modules; Plan 03 connects them into
the pipeline. After this plan, running cinecut on a film produces a trailer with a music bed, beat-snapped
clip starts, and a deliberate silence at the Act 2-to-Act 3 boundary.
Output: silence insertion in ordering.py, updated assemble_manifest in __init__.py, Stage 7 in cli.py,
unit tests for bpm.py and music.py.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-bpm-grid-and-music-bed/09-RESEARCH.md
@.planning/phases/09-bpm-grid-and-music-bed/09-01-SUMMARY.md
@.planning/phases/09-bpm-grid-and-music-bed/09-02-SUMMARY.md

<interfaces>
From src/cinecut/assembly/bpm.py (Plan 01 output):
  @dataclass
  class BpmGrid:
      bpm: float
      beat_times_s: list[float]
      source: str
      beat_count: int = 0

  VIBE_BPM_DEFAULTS: dict[str, float]   # 18 vibes
  def resolve_bpm(raw_bpm: float, vibe: str) -> float: ...
  def generate_beat_grid(audio_path: str, vibe: str, duration_s: float) -> BpmGrid: ...
  def snap_to_nearest_beat(start_s: float, beat_times_s: list[float], bpm: float) -> float: ...

From src/cinecut/assembly/music.py (Plan 02 output):
  @dataclass
  class MusicBed:
      track_id: str; track_name: str; artist_name: str; license_ccurl: str
      local_path: str
      bpm: Optional[float] = None

  def fetch_music_for_vibe(vibe: str) -> Optional[MusicBed]: ...   # Returns None on any failure

From src/cinecut/manifest/schema.py (Plan 01 additions):
  class BpmGrid(BaseModel):   # Pydantic — for manifest JSON
      bpm: float; beat_count: int; source: str

  class MusicBed(BaseModel):  # Pydantic — for manifest JSON
      track_id: str; track_name: str; artist_name: str; license_ccurl: str
      local_path: str; bpm: Optional[float] = None

  class TrailerManifest(BaseModel):
      ...
      bpm_grid: Optional[BpmGrid] = None
      music_bed: Optional[MusicBed] = None

From src/cinecut/assembly/__init__.py (current):
  def assemble_manifest(manifest: TrailerManifest, source_file: Path, work_dir: Path
  ) -> tuple[TrailerManifest, list[Path]]:
      # Steps: sort_clips_by_act, enforce_pacing_curve, generate title_card+button,
      # write ASSEMBLY_MANIFEST.json, return (reordered_manifest, [title_card_path, button_path])

From src/cinecut/assembly/ordering.py (current):
  ACT_ORDER = ["cold_open", "act1", "beat_drop", "act2", "breath", "act3"]
  MIN_CLIP_DURATION_S = 0.5
  def sort_clips_by_act(clips) -> list[ClipEntry]: ...
  def enforce_pacing_curve(clips, profile) -> list[ClipEntry]: ...

From src/cinecut/assembly/title_card.py (reference for get_video_dimensions):
  def get_video_dimensions(video_path: Path) -> tuple[int, int]: ...  # returns (width, height)

From src/cinecut/cli.py (current key constants):
  TOTAL_STAGES = 7   # bump to 8
  # Stages: proxy(1), subtitles(2), keyframes(3), inference(4), narrative(5), assembly(6), conform(7)
  # Phase 9 adds: music+BPM(7), conform becomes(8)
  # checkpoint stage names: "proxy", "subtitles", "keyframes", "narrative", "assembly"
  # Phase 9 adds: "music" checkpoint stage

From src/cinecut/errors.py (for silence generation error handling):
  class ConformError(CineCutError): ...
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add silence segment generation to ordering.py and update assemble_manifest in __init__.py</name>
  <files>src/cinecut/assembly/ordering.py, src/cinecut/assembly/__init__.py</files>
  <action>
**Part A: ordering.py additions**

Read the current ordering.py. Add the following to it without changing any existing code:

New imports at top (add to existing imports):
  import subprocess
  from pathlib import Path
  from cinecut.errors import ConformError

New constant after MIN_CLIP_DURATION_S:
  SILENCE_DURATION_S = 4.0   # Deliberate black silence at Act 2->3 boundary (EORD-04)

New function generate_silence_segment():
  def generate_silence_segment(
      work_dir: Path,
      width: int,
      height: int,
      frame_rate: str,
      duration_s: float = SILENCE_DURATION_S,
  ) -> Path:
      """Generate black video + silent audio MP4 for Act 2->3 boundary (EORD-04).

      Resolution must match source clips to avoid concat demuxer resolution mismatch (PITFALL 4).
      Returns path to silence_act2_act3.mp4 in work_dir.
      Raises ConformError if FFmpeg fails.
      """
      output_path = work_dir / "silence_act2_act3.mp4"
      cmd = [
          "ffmpeg", "-y",
          "-f", "lavfi", "-i", f"color=c=black:s={width}x{height}:r={frame_rate}:d={duration_s}",
          "-f", "lavfi", "-i", "anullsrc=r=48000:cl=stereo",
          "-shortest",
          "-c:v", "libx264", "-crf", "18", "-preset", "veryfast",
          "-c:a", "aac", "-ar", "48000",
          str(output_path),
      ]
      result = subprocess.run(cmd, capture_output=True, text=True, check=False)
      if result.returncode != 0:
          raise ConformError(output_path, result.stderr[-500:])
      return output_path

New function insert_silence_at_zone_boundary():
  def insert_silence_at_zone_boundary(
      clips: list[ClipEntry],
      work_dir: Path,
      width: int,
      height: int,
      frame_rate: str = "24",
  ) -> Path | None:
      """Generate and return silence segment path if ESCALATION and CLIMAX zones both exist.

      Returns None if only one zone is present (no boundary to insert at).
      Requires clips to have narrative_zone field set (Phase 8 output).
      The returned path must be inserted between ESCALATION and CLIMAX clips by the caller.
      """
      has_escalation = any(getattr(c, "narrative_zone", None) == "ESCALATION" for c in clips)
      has_climax = any(getattr(c, "narrative_zone", None) == "CLIMAX" for c in clips)
      if not (has_escalation and has_climax):
          return None   # No zone boundary to insert — skip silence
      return generate_silence_segment(work_dir, width, height, frame_rate)

**Part B: assembly/__init__.py update**

Read the current __init__.py carefully. Rewrite assemble_manifest() to incorporate Phase 9 steps.
Keep all existing imports. Add new imports:
  from cinecut.assembly.bpm import generate_beat_grid, snap_to_nearest_beat, BpmGrid as BpmGridDC
  from cinecut.assembly.music import fetch_music_for_vibe, MusicBed as MusicBedDC
  from cinecut.assembly.ordering import generate_silence_segment, insert_silence_at_zone_boundary
  from cinecut.manifest.schema import BpmGrid as BpmGridModel, MusicBed as MusicBedModel
  import logging
  _logger = logging.getLogger("cinecut")

Updated assemble_manifest() — same signature, extended body:

  def assemble_manifest(
      manifest: TrailerManifest,
      source_file: Path,
      work_dir: Path,
  ) -> tuple[TrailerManifest, list[Path]]:
      """Apply 3-act ordering, pacing, music bed, BPM snap, silence insertion, and title card.

      Steps:
      1. Sort clips into canonical ACT_ORDER
      2. Enforce pacing curve (trim act3 clips)
      3. Fetch music for vibe (MUSC-01/02/03 — returns None on failure, pipeline continues)
      4. Detect BPM and generate beat grid (BPMG-01/03 — uses vibe default on failure)
      5. Snap clip start points to beat grid (BPMG-02)
      6. Insert silence segment at ESCALATION->CLIMAX zone boundary (EORD-04)
      7. Generate title card and button segments
      8. Record BpmGrid and MusicBed metadata in manifest
      9. Write ASSEMBLY_MANIFEST.json
      10. Return (reordered_manifest, extra_paths) where extra_paths = [silence_path*, title_card, button]
          (* silence_path is only present if both ESCALATION and CLIMAX zones exist)
      """
      profile = VIBE_PROFILES[manifest.vibe]

      # Step 1: Sort into canonical act order
      ordered_clips = sort_clips_by_act(manifest.clips)

      # Step 2: Enforce pacing curve on act3 clips
      paced_clips = enforce_pacing_curve(ordered_clips, profile)

      # Step 3: Fetch music for vibe (MUSC-01, MUSC-02, MUSC-03)
      music_bed_dc: MusicBedDC | None = fetch_music_for_vibe(manifest.vibe)

      # Step 4: Detect BPM and generate beat grid (BPMG-01, BPMG-03)
      bpm_grid_dc: BpmGridDC | None = None
      if music_bed_dc is not None:
          # Estimate trailer duration from total clip durations
          trailer_duration_s = sum(c.source_end_s - c.source_start_s for c in paced_clips)
          bpm_grid_dc = generate_beat_grid(music_bed_dc.local_path, manifest.vibe, trailer_duration_s)
          music_bed_dc.bpm = bpm_grid_dc.bpm   # Store resolved BPM in music bed

      # Step 5: Snap clip start points to beat grid (BPMG-02)
      if bpm_grid_dc is not None and bpm_grid_dc.beat_times_s:
          snapped = []
          for clip in paced_clips:
              snapped_start = snap_to_nearest_beat(
                  clip.source_start_s, bpm_grid_dc.beat_times_s, bpm_grid_dc.bpm
              )
              # Recalculate end to preserve clip duration after snap
              original_duration = clip.source_end_s - clip.source_start_s
              new_end = max(snapped_start + original_duration, snapped_start + 0.5)
              snapped.append(clip.model_copy(update={
                  "source_start_s": snapped_start,
                  "source_end_s": new_end,
              }))
          paced_clips = snapped

      # Step 6: Generate video dimensions for silence and title card
      width, height = get_video_dimensions(source_file)
      frame_rate = "24"

      # Step 6: Insert silence at ESCALATION->CLIMAX boundary (EORD-04)
      silence_path = insert_silence_at_zone_boundary(paced_clips, work_dir, width, height, frame_rate)

      # Step 7: Generate title card and button
      title_card_path = generate_title_card(
          title_text="",
          width=width,
          height=height,
          duration_s=5.0,
          output_path=work_dir / "title_card.mp4",
      )
      button_path = generate_title_card(
          title_text="",
          width=width,
          height=height,
          duration_s=2.0,
          output_path=work_dir / "button.mp4",
      )

      # Step 8: Build manifest metadata models for BpmGrid and MusicBed
      bpm_grid_model = None
      if bpm_grid_dc is not None:
          bpm_grid_model = BpmGridModel(
              bpm=bpm_grid_dc.bpm,
              beat_count=bpm_grid_dc.beat_count,
              source=bpm_grid_dc.source,
          )

      music_bed_model = None
      if music_bed_dc is not None:
          music_bed_model = MusicBedModel(
              track_id=music_bed_dc.track_id,
              track_name=music_bed_dc.track_name,
              artist_name=music_bed_dc.artist_name,
              license_ccurl=music_bed_dc.license_ccurl,
              local_path=music_bed_dc.local_path,
              bpm=music_bed_dc.bpm,
          )

      # Step 9: Build reordered manifest with Phase 9 metadata
      reordered_manifest = manifest.model_copy(update={
          "clips": paced_clips,
          "bpm_grid": bpm_grid_model,
          "music_bed": music_bed_model,
      })
      assembly_manifest_path = work_dir / "ASSEMBLY_MANIFEST.json"
      assembly_manifest_path.write_text(
          reordered_manifest.model_dump_json(indent=2), encoding="utf-8"
      )

      # Step 10: Build extra_paths — silence (if present) then title_card, button
      extra_paths: list[Path] = []
      if silence_path is not None:
          extra_paths.append(silence_path)
      extra_paths.extend([title_card_path, button_path])

      return reordered_manifest, extra_paths

IMPORTANT: The silence_path is inserted into extra_paths BEFORE title_card and button.
The conform pipeline appends extra_paths AFTER act3 clips. So the assembly order becomes:
  [...act3 clips...] + [silence_act2_act3.mp4] + [title_card.mp4] + [button.mp4]
This is intentional — the silence marks the end of the Act 2-to-Act 3 transition, which
in non-linear zone ordering appears between the last ESCALATION clip and first CLIMAX clip.
NOTE: Silence is appended at the end of extra_paths here because conform appends extra_paths
after all clips. Phase 10 may refine the exact insertion position within the clip list.
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.ordering import generate_silence_segment, insert_silence_at_zone_boundary, SILENCE_DURATION_S
from cinecut.assembly import assemble_manifest
print('ordering.py additions importable: OK')
assert SILENCE_DURATION_S == 4.0, f'SILENCE_DURATION_S wrong: {SILENCE_DURATION_S}'
print('SILENCE_DURATION_S: OK')
" && python -m pytest tests/test_assembly.py -v -q</verify>
  <done>generate_silence_segment and insert_silence_at_zone_boundary importable from ordering.py; assemble_manifest in __init__.py updated to include music+BPM steps; existing test_assembly.py tests still pass</done>
</task>

<task type="auto">
  <name>Task 2: Add Stage 7 (music+BPM) to cli.py; write unit tests for bpm.py and music.py</name>
  <files>src/cinecut/cli.py, tests/test_bpm.py, tests/test_music.py</files>
  <action>
**Part A: cli.py — add Stage 7 (music+BPM checkpoint), bump TOTAL_STAGES to 8**

Read cli.py. Make these targeted changes:

1. Change TOTAL_STAGES = 7 to TOTAL_STAGES = 8 at the top.

2. After Stage 6 assembly block (after the ckpt.mark_stage_complete("assembly") save and before the
   existing Summary panel), add a new Stage 7 block:

   # --- Stage 7/8: Music fetch and BPM detection (MUSC-01, MUSC-02, BPMG-01) ---
   if not ckpt.is_stage_complete("music"):
       console.print(f"[bold]Stage 7/{TOTAL_STAGES}:[/bold] Fetching music bed and detecting BPM...")
       with Progress(
           SpinnerColumn(),
           TextColumn("[progress.description]{task.description}"),
           TimeElapsedColumn(),
           console=console,
           transient=True,
       ) as progress:
           asm_task = progress.add_task("Fetching music for vibe...", total=None)
           # assemble_manifest already ran music+BPM in Stage 6; here we just mark checkpoint
           # and log the result from the reordered_manifest
           progress.update(asm_task, description="Music stage complete")
       ckpt.mark_stage_complete("music")
       save_checkpoint(ckpt, work_dir)
       if reordered_manifest.bpm_grid is not None:
           console.print(
               f"[green]BPM detected:[/] {reordered_manifest.bpm_grid.bpm:.1f} BPM "
               f"({reordered_manifest.bpm_grid.source}) — "
               f"{reordered_manifest.bpm_grid.beat_count} beats\n"
           )
       else:
           console.print("[yellow]Music bed:[/] unavailable — trailer proceeds without music\n")
   else:
       console.print(f"[yellow]Resuming:[/] Stage 7 already complete (music/BPM)\n")

3. Update the Stage 7/7 conform heading to Stage 8/8:
   Change: f"[bold]Stage 7/{TOTAL_STAGES}:[/bold] Running FFmpeg conform..."
   To:     f"[bold]Stage 8/{TOTAL_STAGES}:[/bold] Running FFmpeg conform..."

4. Update the Summary panel text from "Phase 5 Complete" to "Phase 9 Complete" (or keep generic).
   Update the summary panel to include BPM info:
   Add line after Assembly line:
     f"  BPM:        {reordered_manifest.bpm_grid.bpm:.1f} ({reordered_manifest.bpm_grid.source})\n" if reordered_manifest.bpm_grid else ""

**Part B: tests/test_bpm.py — unit tests for bpm.py pure functions**

Create tests/test_bpm.py:

  import pytest
  import numpy as np
  from cinecut.assembly.bpm import (
      resolve_bpm, snap_to_nearest_beat, VIBE_BPM_DEFAULTS, VIBE_BPM_RANGES, BpmGrid
  )


  class TestResolveBpm:
      """BPMG-03: 0-BPM guard, octave correction, vibe-default fallback."""

      def test_zero_bpm_returns_vibe_default(self):
          assert resolve_bpm(0.0, "action") == pytest.approx(VIBE_BPM_DEFAULTS["action"])

      def test_very_low_bpm_returns_vibe_default(self):
          assert resolve_bpm(5.0, "drama") == pytest.approx(VIBE_BPM_DEFAULTS["drama"])

      def test_half_tempo_doubled(self):
          """Action range 100-160; 64 BPM is half of 128 — should be doubled to 128."""
          result = resolve_bpm(64.0, "action")
          assert result == pytest.approx(128.0)

      def test_double_tempo_halved(self):
          """Action range 100-160; 256 BPM is double of 128 — should be halved to 128."""
          result = resolve_bpm(256.0, "action")
          assert result == pytest.approx(128.0)

      def test_in_range_passes_through(self):
          result = resolve_bpm(120.0, "action")
          assert result == pytest.approx(120.0)

      def test_out_of_range_no_octave_match_returns_default(self):
          """300 BPM for action: halved=150 which is in range [100,160], so halved."""
          # Actually 300/2=150 IS in action range (100-160), so it should halve, not return default
          result = resolve_bpm(300.0, "action")
          assert result == pytest.approx(150.0)

      def test_unknown_vibe_uses_fallback_range(self):
          """Unknown vibe uses (60.0, 160.0) range and 100.0 default."""
          result = resolve_bpm(0.0, "unknown_vibe")
          assert result == pytest.approx(100.0)

      def test_all_18_vibes_have_defaults(self):
          for vibe in VIBE_BPM_DEFAULTS:
              d = resolve_bpm(0.0, vibe)
              assert d == pytest.approx(VIBE_BPM_DEFAULTS[vibe])


  class TestSnapToNearestBeat:
      """BPMG-02: clip start snapping within +/-1 beat tolerance."""

      def test_empty_beat_grid_returns_original(self):
          assert snap_to_nearest_beat(5.0, [], 120.0) == pytest.approx(5.0)

      def test_snaps_to_nearest_beat_within_tolerance(self):
          """Beat at 0.5s; start at 0.3s; tolerance = 60/120 = 0.5s; 0.3 is within 0.5 of 0.5."""
          beats = [0.0, 0.5, 1.0, 1.5]
          result = snap_to_nearest_beat(0.3, beats, 120.0)
          assert result == pytest.approx(0.5)

      def test_no_beat_within_tolerance_returns_original(self):
          """Start at 5.0; nearest beat is 3.0; tolerance = 0.5s (120 BPM); 2.0s away."""
          beats = [0.0, 1.0, 2.0, 3.0]
          result = snap_to_nearest_beat(5.0, beats, 120.0)
          assert result == pytest.approx(5.0)

      def test_result_never_negative(self):
          """Negative beats filtered; snapped result clamped >= 0.0."""
          beats = [0.0, 0.5, 1.0]
          result = snap_to_nearest_beat(0.1, beats, 120.0)
          assert result >= 0.0

      def test_snaps_to_beat_at_zero(self):
          beats = [0.0, 0.5, 1.0]
          result = snap_to_nearest_beat(0.2, beats, 120.0)
          assert result == pytest.approx(0.0)


  class TestBpmGridDataclass:
      def test_construct_with_defaults(self):
          bg = BpmGrid(bpm=128.0, beat_times_s=[0.0, 0.5, 1.0], source="librosa")
          assert bg.beat_count == 0   # default — caller sets this
          assert bg.bpm == 128.0
          assert bg.source == "librosa"

**Part C: tests/test_music.py — unit tests for music.py pure functions**

Create tests/test_music.py:

  import os
  import pytest
  from pathlib import Path
  from unittest.mock import patch, MagicMock
  from cinecut.assembly.music import (
      MusicBed, fetch_music_for_vibe, get_music_cache_dir, VIBE_TO_JAMENDO_TAG
  )


  class TestMusicBedDataclass:
      def test_construct_minimal(self):
          mb = MusicBed(
              track_id="1", track_name="Test Track", artist_name="Artist",
              license_ccurl="https://creativecommons.org/licenses/by/4.0/",
              local_path="/home/user/.cinecut/music/action.mp3",
          )
          assert mb.bpm is None
          assert mb.local_path.endswith(".mp3")

      def test_bpm_assignable(self):
          mb = MusicBed(track_id="1", track_name="T", artist_name="A", license_ccurl="", local_path="/tmp/x.mp3")
          mb.bpm = 128.0
          assert mb.bpm == 128.0


  class TestVibeTagMapping:
      def test_all_vibes_mapped(self):
          expected_vibes = {
              "action", "adventure", "animation", "comedy", "crime", "documentary",
              "drama", "family", "fantasy", "history", "horror", "music",
              "mystery", "romance", "sci-fi", "thriller", "war", "western",
          }
          assert set(VIBE_TO_JAMENDO_TAG.keys()) == expected_vibes

      def test_tags_are_strings(self):
          for vibe, tag in VIBE_TO_JAMENDO_TAG.items():
              assert isinstance(tag, str) and len(tag) > 0, f"Empty tag for vibe '{vibe}'"


  class TestFetchMusicGracefulDegradation:
      """MUSC-03: fetch_music_for_vibe returns None on any failure."""

      def test_returns_none_when_client_id_missing(self, monkeypatch):
          monkeypatch.delenv("JAMENDO_CLIENT_ID", raising=False)
          result = fetch_music_for_vibe("action")
          assert result is None

      def test_returns_none_on_network_error(self, monkeypatch, tmp_path):
          monkeypatch.setenv("JAMENDO_CLIENT_ID", "test-id")
          # Ensure no cache exists
          monkeypatch.setattr("cinecut.assembly.music.get_music_cache_dir", lambda: tmp_path)
          with patch("cinecut.assembly.music.requests.get", side_effect=ConnectionError("timeout")):
              result = fetch_music_for_vibe("action")
          assert result is None

      def test_returns_cached_musicbed_on_cache_hit(self, monkeypatch, tmp_path):
          """MUSC-02: cache hit returns MusicBed without API call."""
          # Create a fake cached file
          cached_file = tmp_path / "action.mp3"
          cached_file.write_bytes(b"fake-mp3-content")
          monkeypatch.setattr("cinecut.assembly.music.get_music_cache_dir", lambda: tmp_path)

          result = fetch_music_for_vibe("action")
          assert result is not None
          assert result.track_id == "cached"
          assert result.local_path == str(cached_file)
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_bpm.py tests/test_music.py -v && python -m pytest tests/ -x -q</verify>
  <done>tests/test_bpm.py and tests/test_music.py pass; cli.py compiles (python -c "from cinecut.cli import app"); TOTAL_STAGES == 8 in cli.py; all existing tests still pass</done>
</task>

</tasks>

<verification>
Full test suite:
  cd /home/adamh/ai-video-trailer && python -m pytest tests/ -v

CLI import check:
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.cli import app, TOTAL_STAGES; assert TOTAL_STAGES == 8, f'TOTAL_STAGES={TOTAL_STAGES}'; print('TOTAL_STAGES=8 OK')"

Silence import:
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.assembly.ordering import generate_silence_segment, insert_silence_at_zone_boundary, SILENCE_DURATION_S; assert SILENCE_DURATION_S == 4.0; print('Silence segment integration OK')"

End-to-end assembly (no video needed — tests module structure):
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.assembly import assemble_manifest; print('assemble_manifest with Phase 9 OK')"
</verification>

<success_criteria>
- ordering.py: generate_silence_segment and insert_silence_at_zone_boundary importable; SILENCE_DURATION_S = 4.0
- assembly/__init__.py: assemble_manifest calls fetch_music_for_vibe, generate_beat_grid, snap_to_nearest_beat, and insert_silence_at_zone_boundary; returns silence_path in extra_paths when zones present
- cli.py: TOTAL_STAGES = 8; Stage 7 (music) checkpoint added; Stage 8 conform
- tests/test_bpm.py: all tests pass (covers resolve_bpm guards, snap_to_nearest_beat, BpmGrid dataclass)
- tests/test_music.py: all tests pass (covers MusicBed dataclass, VIBE_TO_JAMENDO_TAG, graceful None returns, cache hit)
- python -m pytest tests/ -x exits 0 — all tests pass including existing suite
</success_criteria>

<output>
After completion, create .planning/phases/09-bpm-grid-and-music-bed/09-03-SUMMARY.md
</output>
