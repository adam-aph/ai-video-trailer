---
phase: 09-bpm-grid-and-music-bed
plan: "03"
type: execute
wave: 2
depends_on:
  - "09-01"
  - "09-02"
files_modified:
  - src/cinecut/assembly/ordering.py
  - src/cinecut/assembly/__init__.py
  - src/cinecut/conform/pipeline.py
  - src/cinecut/cli.py
  - tests/test_bpm.py
  - tests/test_music.py
autonomous: true
requirements:
  - EORD-04
  - BPMG-01
  - BPMG-02
  - BPMG-03
  - MUSC-01
  - MUSC-02
  - MUSC-03

must_haves:
  truths:
    - "A 4-second black video + silent audio segment is inserted between the last ESCALATION-zone clip and the first CLIMAX-zone clip in the assembled output"
    - "Music fetch and BPM detection run as Stage 7 in cli.py before conform (Stage 8)"
    - "Clip start points are snapped to the beat grid after fetch (assemble_manifest returns snapped clips)"
    - "Pipeline continues to produce a trailer even when music fetch returns None (MUSC-03)"
    - "BpmGrid and MusicBed metadata are recorded in TrailerManifest before manifest is written"
    - "Unit tests cover: generate_silence_segment file exists, snap_clips_to_grid snapping, resolve_bpm guards, fetch_music_for_vibe None return"
  artifacts:
    - path: "src/cinecut/assembly/ordering.py"
      provides: "generate_silence_segment(), insert_silence_at_zone_boundary() returning (Path|None, int)"
      exports:
        - SILENCE_DURATION_S
        - generate_silence_segment
        - insert_silence_at_zone_boundary
    - path: "src/cinecut/assembly/__init__.py"
      provides: "assemble_manifest updated to: fetch music, detect BPM, snap clip starts, insert silence at boundary, record manifest metadata; returns (manifest, extra_paths, silence_injection)"
    - path: "src/cinecut/conform/pipeline.py"
      provides: "conform_manifest extended with inject_after_clip and inject_paths parameters for mid-list silence insertion"
    - path: "src/cinecut/cli.py"
      provides: "Stage 7 (music+BPM) added; TOTAL_STAGES bumped to 8; Stage 8 conform; call site updated for new assemble_manifest return type"
    - path: "tests/test_bpm.py"
      provides: "Unit tests for resolve_bpm guards, beat snapping, generate_beat_grid vibe_default fallback"
    - path: "tests/test_music.py"
      provides: "Unit tests for fetch_music_for_vibe graceful None, MusicBed cache hit path, atomic download logic"
  key_links:
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/music.py fetch_music_for_vibe()"
      via: "music_bed = fetch_music_for_vibe(manifest.vibe) called inside assemble_manifest"
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/bpm.py generate_beat_grid()"
      via: "bpm_grid = generate_beat_grid(music_bed.local_path, vibe, trailer_duration_s) when music_bed is not None"
    - from: "assembly/__init__.py assemble_manifest()"
      to: "assembly/ordering.py insert_silence_at_zone_boundary()"
      via: "silence_path, boundary_idx = insert_silence_at_zone_boundary(paced_clips, work_dir, width, height, frame_rate)"
    - from: "assembly/ordering.py generate_silence_segment()"
      to: "conform/pipeline.py conform_manifest() inject_after_clip parameter"
      via: "silence_path injected at boundary_idx via inject_after_clip=boundary_idx, inject_paths=[silence_path]"
    - from: "cli.py Stage 7"
      to: "assembly/__init__.py assemble_manifest()"
      via: "reordered_manifest, extra_paths, silence_injection = assemble_manifest(trailer_manifest, video, work_dir)"
    - from: "cli.py Stage 8 conform"
      to: "conform/pipeline.py conform_manifest()"
      via: "conform_manifest(manifest, source, work_dir, extra_clip_paths=extra_paths, inject_after_clip=silence_injection['index'], inject_paths=silence_injection['paths']) if silence_injection else conform_manifest(...)"
---

<objective>
Wire BPM detection and music fetching into assemble_manifest(). Insert the 4-second Act 2-to-Act 3 silence
segment AT the correct position — between the last ESCALATION-zone clip and the first CLIMAX-zone clip.
Add Stage 7 (music+BPM) in cli.py and bump TOTAL_STAGES to 8. Write unit tests for all Phase 9 pure functions.

Purpose: This is the integration plan — Plans 01 and 02 create the modules; Plan 03 connects them into
the pipeline. The silence segment must appear at the correct boundary (EORD-04), not appended after all
clips. This requires extending conform_manifest to support mid-list injection at a specific clip index.
Output: silence insertion in ordering.py, updated assemble_manifest in __init__.py, inject_after_clip
support in conform/pipeline.py, Stage 7 in cli.py, unit tests for bpm.py and music.py.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-bpm-grid-and-music-bed/09-RESEARCH.md
@.planning/phases/09-bpm-grid-and-music-bed/09-01-SUMMARY.md
@.planning/phases/09-bpm-grid-and-music-bed/09-02-SUMMARY.md

<interfaces>
From src/cinecut/assembly/bpm.py (Plan 01 output):
  @dataclass
  class BpmGrid:
      bpm: float
      beat_times_s: list[float]
      source: str
      beat_count: int = 0

  VIBE_BPM_DEFAULTS: dict[str, float]   # 18 vibes
  def resolve_bpm(raw_bpm: float, vibe: str) -> float: ...
  def generate_beat_grid(audio_path: str, vibe: str, duration_s: float) -> BpmGrid: ...
  def snap_to_nearest_beat(start_s: float, beat_times_s: list[float], bpm: float) -> float: ...

From src/cinecut/assembly/music.py (Plan 02 output):
  @dataclass
  class MusicBed:
      track_id: str; track_name: str; artist_name: str; license_ccurl: str
      local_path: str
      bpm: Optional[float] = None

  def fetch_music_for_vibe(vibe: str) -> Optional[MusicBed]: ...   # Returns None on any failure

From src/cinecut/manifest/schema.py (Plan 01 additions):
  class BpmGrid(BaseModel):   # Pydantic — for manifest JSON
      bpm: float; beat_count: int; source: str

  class MusicBed(BaseModel):  # Pydantic — for manifest JSON
      track_id: str; track_name: str; artist_name: str; license_ccurl: str
      local_path: str; bpm: Optional[float] = None

  class TrailerManifest(BaseModel):
      ...
      bpm_grid: Optional[BpmGrid] = None
      music_bed: Optional[MusicBed] = None

From src/cinecut/assembly/__init__.py (current):
  def assemble_manifest(manifest: TrailerManifest, source_file: Path, work_dir: Path
  ) -> tuple[TrailerManifest, list[Path]]:
      # Steps: sort_clips_by_act, enforce_pacing_curve, generate title_card+button,
      # write ASSEMBLY_MANIFEST.json, return (reordered_manifest, [title_card_path, button_path])

From src/cinecut/assembly/ordering.py (current):
  ACT_ORDER = ["cold_open", "act1", "beat_drop", "act2", "breath", "act3"]
  MIN_CLIP_DURATION_S = 0.5
  def sort_clips_by_act(clips) -> list[ClipEntry]: ...
  def enforce_pacing_curve(clips, profile) -> list[ClipEntry]: ...

From src/cinecut/conform/pipeline.py (current — MUST be extended):
  def conform_manifest(
      manifest: TrailerManifest,
      source: Path,
      work_dir: Path,
      extra_clip_paths: list[Path] | None = None,   # appended AFTER all manifest clips
  ) -> Path:
      # Extracts each clip in manifest.clips, then extends with extra_clip_paths
      # PROBLEM: extra_clip_paths always goes at the end — cannot insert mid-list
      # FIX: add inject_after_clip: int | None = None, inject_paths: list[Path] | None = None

From src/cinecut/assembly/title_card.py (reference for get_video_dimensions):
  def get_video_dimensions(video_path: Path) -> tuple[int, int]: ...  # returns (width, height)

From src/cinecut/cli.py (current key constants):
  TOTAL_STAGES = 7   # bump to 8
  # Stages: proxy(1), subtitles(2), keyframes(3), inference(4), narrative(5), assembly(6), conform(7)
  # Phase 9 adds: music+BPM(7), conform becomes(8)

From src/cinecut/errors.py (for silence generation error handling):
  class ConformError(CineCutError): ...
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add silence generation to ordering.py; extend conform_manifest with inject_after_clip; update assemble_manifest to insert silence at the correct boundary</name>
  <files>src/cinecut/assembly/ordering.py, src/cinecut/conform/pipeline.py, src/cinecut/assembly/__init__.py</files>
  <action>
**Part A: ordering.py additions**

Read the current ordering.py. Add the following without changing any existing code:

New imports at top (add to existing imports):
  import subprocess
  from pathlib import Path
  from cinecut.errors import ConformError

New constant after MIN_CLIP_DURATION_S:
  SILENCE_DURATION_S = 4.0   # Deliberate black silence at Act 2->3 boundary (EORD-04)

New function generate_silence_segment():
  def generate_silence_segment(
      work_dir: Path,
      width: int,
      height: int,
      frame_rate: str,
      duration_s: float = SILENCE_DURATION_S,
  ) -> Path:
      """Generate black video + silent audio MP4 for Act 2->3 boundary (EORD-04).

      Resolution must match source clips to avoid concat demuxer resolution mismatch (PITFALL 4).
      Returns path to silence_act2_act3.mp4 in work_dir.
      Raises ConformError if FFmpeg fails.
      """
      output_path = work_dir / "silence_act2_act3.mp4"
      cmd = [
          "ffmpeg", "-y",
          "-f", "lavfi", "-i", f"color=c=black:s={width}x{height}:r={frame_rate}:d={duration_s}",
          "-f", "lavfi", "-i", "anullsrc=r=48000:cl=stereo",
          "-shortest",
          "-c:v", "libx264", "-crf", "18", "-preset", "veryfast",
          "-c:a", "aac", "-ar", "48000",
          str(output_path),
      ]
      result = subprocess.run(cmd, capture_output=True, text=True, check=False)
      if result.returncode != 0:
          raise ConformError(output_path, result.stderr[-500:])
      return output_path

New function insert_silence_at_zone_boundary():
  def insert_silence_at_zone_boundary(
      clips: list[ClipEntry],
      work_dir: Path,
      width: int,
      height: int,
      frame_rate: str = "24",
  ) -> tuple[Path | None, int]:
      """Generate silence segment if ESCALATION and CLIMAX zones both exist.

      Returns (silence_path, boundary_index) where:
        - silence_path is the generated silence_act2_act3.mp4
        - boundary_index is the number of clips that come BEFORE the silence
          (i.e., silence is inserted AFTER clips[:boundary_index] and BEFORE clips[boundary_index:])

      Returns (None, 0) if only one zone is present or clips have no zone annotation.

      The silence must be inserted BETWEEN the last ESCALATION clip and first CLIMAX clip.
      The caller is responsible for passing boundary_index to conform_manifest via
      inject_after_clip=boundary_index, inject_paths=[silence_path].
      """
      # Find the index of the last ESCALATION clip (boundary_index = that index + 1)
      boundary_index = 0
      has_escalation = False
      has_climax = False
      for i, clip in enumerate(clips):
          zone = getattr(clip, "narrative_zone", None)
          if zone == "ESCALATION":
              has_escalation = True
              boundary_index = i + 1   # silence goes AFTER this clip
          elif zone == "CLIMAX":
              has_climax = True
      if not (has_escalation and has_climax):
          return None, 0   # No zone boundary to insert — skip silence
      return generate_silence_segment(work_dir, width, height, frame_rate), boundary_index

**Part B: conform/pipeline.py extension**

Read the current conform/pipeline.py. Make ONE targeted change to conform_manifest():
Add two new optional parameters after extra_clip_paths:

  def conform_manifest(
      manifest: TrailerManifest,
      source: Path,
      work_dir: Path,
      extra_clip_paths: list[Path] | None = None,
      inject_after_clip: int | None = None,
      inject_paths: list[Path] | None = None,
  ) -> Path:

Update the docstring's Args section to document the new parameters:
  inject_after_clip: If provided, inject_paths are inserted into the concat list
      AFTER the Nth extracted clip (0-indexed). Used for EORD-04 silence segment
      at the ESCALATION->CLIMAX boundary.
  inject_paths: Pre-encoded clip paths to inject at inject_after_clip position.
      Ignored if inject_after_clip is None.

In the clip extraction loop body (where clip_output_paths is built), AFTER appending
each extracted clip path, check if the current loop index equals inject_after_clip
and if so extend clip_output_paths with inject_paths:

  for i, clip in enumerate(manifest.clips):
      output = clips_dir / f"clip_{i:04d}.mp4"
      extract_and_grade_clip(
          source=source,
          start_s=clip.source_start_s,
          end_s=clip.source_end_s,
          lut_path=lut_path,
          lufs_target=profile.lufs_target,
          output_path=output,
      )
      clip_output_paths.append(output)
      # EORD-04: inject silence (or other pre-encoded clips) after specified clip index
      if inject_after_clip is not None and inject_paths and i == inject_after_clip - 1:
          clip_output_paths.extend(inject_paths)

The condition `i == inject_after_clip - 1` because inject_after_clip is a 1-based count
(number of clips before the insertion point), and loop index i is 0-based.
If inject_after_clip is 0 (insert before all clips), handle this as a special pre-loop
prepend: before the loop, if inject_after_clip == 0 and inject_paths:
  clip_output_paths.extend(inject_paths)
Then in the loop, skip the inject check when inject_after_clip == 0.

IMPORTANT: Do NOT change any other existing code in conform/pipeline.py.
All existing tests must still pass since inject_after_clip defaults to None.

**Part C: assembly/__init__.py update**

Read the current __init__.py carefully. Rewrite assemble_manifest() to incorporate Phase 9 steps.

Change the return type annotation to:
  tuple[TrailerManifest, list[Path], dict | None]
  (dict is either None or {"index": int, "paths": list[Path]} for the silence injection)

Keep all existing imports. Add new imports:
  from cinecut.assembly.bpm import generate_beat_grid, snap_to_nearest_beat, BpmGrid as BpmGridDC
  from cinecut.assembly.music import fetch_music_for_vibe, MusicBed as MusicBedDC
  from cinecut.assembly.ordering import generate_silence_segment, insert_silence_at_zone_boundary
  from cinecut.manifest.schema import BpmGrid as BpmGridModel, MusicBed as MusicBedModel
  import logging
  _logger = logging.getLogger("cinecut")

Updated assemble_manifest() body:

  def assemble_manifest(
      manifest: TrailerManifest,
      source_file: Path,
      work_dir: Path,
  ) -> tuple[TrailerManifest, list[Path], dict | None]:
      """Apply 3-act ordering, pacing, music bed, BPM snap, silence insertion, and title card.

      Steps:
      1. Sort clips into canonical ACT_ORDER
      2. Enforce pacing curve (trim act3 clips)
      3. Fetch music for vibe (MUSC-01/02/03 — returns None on failure, pipeline continues)
      4. Detect BPM and generate beat grid (BPMG-01/03 — uses vibe default on failure)
      5. Snap clip start points to beat grid (BPMG-02)
      6. Detect ESCALATION->CLIMAX zone boundary and generate silence segment (EORD-04)
      7. Generate title card and button segments
      8. Record BpmGrid and MusicBed metadata in manifest
      9. Write ASSEMBLY_MANIFEST.json
      10. Return (reordered_manifest, extra_paths, silence_injection) where:
          - extra_paths = [title_card_path, button_path]   (appended after all clips by conform)
          - silence_injection = {"index": boundary_index, "paths": [silence_path]} or None
            (passed to conform_manifest as inject_after_clip=..., inject_paths=...)
      """
      profile = VIBE_PROFILES[manifest.vibe]

      # Step 1: Sort into canonical act order
      ordered_clips = sort_clips_by_act(manifest.clips)

      # Step 2: Enforce pacing curve on act3 clips
      paced_clips = enforce_pacing_curve(ordered_clips, profile)

      # Step 3: Fetch music for vibe (MUSC-01, MUSC-02, MUSC-03)
      music_bed_dc: MusicBedDC | None = fetch_music_for_vibe(manifest.vibe)

      # Step 4: Detect BPM and generate beat grid (BPMG-01, BPMG-03)
      bpm_grid_dc: BpmGridDC | None = None
      if music_bed_dc is not None:
          # Estimate trailer duration from total clip durations
          trailer_duration_s = sum(c.source_end_s - c.source_start_s for c in paced_clips)
          bpm_grid_dc = generate_beat_grid(music_bed_dc.local_path, manifest.vibe, trailer_duration_s)
          music_bed_dc.bpm = bpm_grid_dc.bpm   # Store resolved BPM in music bed

      # Step 5: Snap clip start points to beat grid (BPMG-02)
      if bpm_grid_dc is not None and bpm_grid_dc.beat_times_s:
          snapped = []
          for clip in paced_clips:
              snapped_start = snap_to_nearest_beat(
                  clip.source_start_s, bpm_grid_dc.beat_times_s, bpm_grid_dc.bpm
              )
              # Recalculate end to preserve clip duration after snap
              original_duration = clip.source_end_s - clip.source_start_s
              new_end = max(snapped_start + original_duration, snapped_start + 0.5)
              snapped.append(clip.model_copy(update={
                  "source_start_s": snapped_start,
                  "source_end_s": new_end,
              }))
          paced_clips = snapped

      # Step 6: Generate video dimensions; detect zone boundary and generate silence (EORD-04)
      width, height = get_video_dimensions(source_file)
      frame_rate = "24"
      silence_path, boundary_index = insert_silence_at_zone_boundary(
          paced_clips, work_dir, width, height, frame_rate
      )
      # Build silence_injection dict for conform_manifest (None if no zone boundary detected)
      silence_injection: dict | None = None
      if silence_path is not None:
          silence_injection = {"index": boundary_index, "paths": [silence_path]}

      # Step 7: Generate title card and button
      title_card_path = generate_title_card(
          title_text="",
          width=width,
          height=height,
          duration_s=5.0,
          output_path=work_dir / "title_card.mp4",
      )
      button_path = generate_title_card(
          title_text="",
          width=width,
          height=height,
          duration_s=2.0,
          output_path=work_dir / "button.mp4",
      )

      # Step 8: Build manifest metadata models for BpmGrid and MusicBed
      bpm_grid_model = None
      if bpm_grid_dc is not None:
          bpm_grid_model = BpmGridModel(
              bpm=bpm_grid_dc.bpm,
              beat_count=bpm_grid_dc.beat_count,
              source=bpm_grid_dc.source,
          )

      music_bed_model = None
      if music_bed_dc is not None:
          music_bed_model = MusicBedModel(
              track_id=music_bed_dc.track_id,
              track_name=music_bed_dc.track_name,
              artist_name=music_bed_dc.artist_name,
              license_ccurl=music_bed_dc.license_ccurl,
              local_path=music_bed_dc.local_path,
              bpm=music_bed_dc.bpm,
          )

      # Step 9: Build reordered manifest with Phase 9 metadata
      reordered_manifest = manifest.model_copy(update={
          "clips": paced_clips,
          "bpm_grid": bpm_grid_model,
          "music_bed": music_bed_model,
      })
      assembly_manifest_path = work_dir / "ASSEMBLY_MANIFEST.json"
      assembly_manifest_path.write_text(
          reordered_manifest.model_dump_json(indent=2), encoding="utf-8"
      )

      # Step 10: extra_paths = title_card + button (appended AFTER all clips by conform_manifest)
      # Silence is NOT in extra_paths — it is passed separately via silence_injection
      # so conform_manifest can insert it at the correct position within the clip list
      extra_paths: list[Path] = [title_card_path, button_path]

      return reordered_manifest, extra_paths, silence_injection
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.ordering import generate_silence_segment, insert_silence_at_zone_boundary, SILENCE_DURATION_S
from cinecut.assembly import assemble_manifest
from cinecut.conform.pipeline import conform_manifest
import inspect
print('All imports OK')
assert SILENCE_DURATION_S == 4.0, f'SILENCE_DURATION_S wrong: {SILENCE_DURATION_S}'
# insert_silence_at_zone_boundary returns tuple (Path|None, int)
sig = inspect.signature(insert_silence_at_zone_boundary)
print(f'insert_silence_at_zone_boundary signature: {sig}')
# assemble_manifest returns 3-tuple
sig2 = inspect.signature(assemble_manifest)
print(f'assemble_manifest signature: {sig2}')
# conform_manifest has inject_after_clip parameter
sig3 = inspect.signature(conform_manifest)
params = list(sig3.parameters)
assert 'inject_after_clip' in params, f'inject_after_clip not in conform_manifest params: {params}'
assert 'inject_paths' in params, f'inject_paths not in conform_manifest params: {params}'
print('conform_manifest inject params: OK')
print('Task 1 PASS')
" && python -m pytest tests/test_assembly.py -v -q</verify>
  <done>
- ordering.py: generate_silence_segment and insert_silence_at_zone_boundary importable; SILENCE_DURATION_S = 4.0
- insert_silence_at_zone_boundary returns (Path|None, int) tuple — the int is the boundary_index (clips before silence)
- conform_manifest has inject_after_clip: int | None = None and inject_paths: list[Path] | None = None parameters; injects paths into concat list after clip at inject_after_clip-1 (0-based) so silence appears between ESCALATION and CLIMAX clips
- assemble_manifest returns 3-tuple: (TrailerManifest, list[Path], dict|None) where dict is {"index": N, "paths": [silence_path]} or None
- Silence injection dict is NOT in extra_paths — it is separate so conform can place it at the correct position
- Existing test_assembly.py tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Stage 7 (music+BPM) to cli.py; write unit tests for bpm.py and music.py</name>
  <files>src/cinecut/cli.py, tests/test_bpm.py, tests/test_music.py</files>
  <action>
**Part A: cli.py — add Stage 7 (music+BPM checkpoint), bump TOTAL_STAGES to 8, update conform call**

Read cli.py. Make these targeted changes:

1. Change TOTAL_STAGES = 7 to TOTAL_STAGES = 8 at the top.

2. Update the assemble_manifest call site to unpack three values instead of two:
   BEFORE: reordered_manifest, extra_paths = assemble_manifest(trailer_manifest, video, work_dir)
   AFTER:  reordered_manifest, extra_paths, silence_injection = assemble_manifest(trailer_manifest, video, work_dir)

3. After Stage 6 assembly block (after the ckpt.mark_stage_complete("assembly") save and before the
   existing Summary panel or Stage 7 conform block), add a new Stage 7 block:

   # --- Stage 7/8: Music fetch and BPM detection (MUSC-01, MUSC-02, BPMG-01) ---
   if not ckpt.is_stage_complete("music"):
       console.print(f"[bold]Stage 7/{TOTAL_STAGES}:[/bold] Fetching music bed and detecting BPM...")
       with Progress(
           SpinnerColumn(),
           TextColumn("[progress.description]{task.description}"),
           TimeElapsedColumn(),
           console=console,
           transient=True,
       ) as progress:
           asm_task = progress.add_task("Fetching music for vibe...", total=None)
           # Music and BPM ran inside assemble_manifest (Stage 6); here we checkpoint the result
           progress.update(asm_task, description="Music stage complete")
       ckpt.mark_stage_complete("music")
       save_checkpoint(ckpt, work_dir)
       if reordered_manifest.bpm_grid is not None:
           console.print(
               f"[green]BPM detected:[/] {reordered_manifest.bpm_grid.bpm:.1f} BPM "
               f"({reordered_manifest.bpm_grid.source}) — "
               f"{reordered_manifest.bpm_grid.beat_count} beats\n"
           )
       else:
           console.print("[yellow]Music bed:[/] unavailable — trailer proceeds without music\n")
   else:
       console.print(f"[yellow]Resuming:[/] Stage 7 already complete (music/BPM)\n")

4. Update the conform call to pass the silence injection:
   BEFORE:
     conform_manifest(reordered_manifest, video, work_dir, extra_clip_paths=extra_paths)
   AFTER:
     conform_manifest(
         reordered_manifest,
         video,
         work_dir,
         extra_clip_paths=extra_paths,
         inject_after_clip=silence_injection["index"] if silence_injection else None,
         inject_paths=silence_injection["paths"] if silence_injection else None,
     )

5. Update the Stage 7/7 conform heading to Stage 8/8:
   Change: f"[bold]Stage 7/{TOTAL_STAGES}:[/bold] Running FFmpeg conform..."
   To:     f"[bold]Stage 8/{TOTAL_STAGES}:[/bold] Running FFmpeg conform..."

6. Update the Summary panel to include BPM info after the Assembly line:
   Add:
     f"  BPM:        {reordered_manifest.bpm_grid.bpm:.1f} ({reordered_manifest.bpm_grid.source})\n" if reordered_manifest.bpm_grid else ""

**Part B: tests/test_bpm.py — unit tests for bpm.py pure functions**

Create tests/test_bpm.py:

  import pytest
  import numpy as np
  from cinecut.assembly.bpm import (
      resolve_bpm, snap_to_nearest_beat, VIBE_BPM_DEFAULTS, VIBE_BPM_RANGES, BpmGrid
  )


  class TestResolveBpm:
      """BPMG-03: 0-BPM guard, octave correction, vibe-default fallback."""

      def test_zero_bpm_returns_vibe_default(self):
          assert resolve_bpm(0.0, "action") == pytest.approx(VIBE_BPM_DEFAULTS["action"])

      def test_very_low_bpm_returns_vibe_default(self):
          assert resolve_bpm(5.0, "drama") == pytest.approx(VIBE_BPM_DEFAULTS["drama"])

      def test_half_tempo_doubled(self):
          """Action range 100-160; 64 BPM is half of 128 — should be doubled to 128."""
          result = resolve_bpm(64.0, "action")
          assert result == pytest.approx(128.0)

      def test_double_tempo_halved(self):
          """Action range 100-160; 256 BPM is double of 128 — should be halved to 128."""
          result = resolve_bpm(256.0, "action")
          assert result == pytest.approx(128.0)

      def test_in_range_passes_through(self):
          result = resolve_bpm(120.0, "action")
          assert result == pytest.approx(120.0)

      def test_out_of_range_no_octave_match_returns_default(self):
          """300 BPM for action: halved=150 which is in range [100,160], so halved."""
          # Actually 300/2=150 IS in action range (100-160), so it should halve, not return default
          result = resolve_bpm(300.0, "action")
          assert result == pytest.approx(150.0)

      def test_unknown_vibe_uses_fallback_range(self):
          """Unknown vibe uses (60.0, 160.0) range and 100.0 default."""
          result = resolve_bpm(0.0, "unknown_vibe")
          assert result == pytest.approx(100.0)

      def test_all_18_vibes_have_defaults(self):
          for vibe in VIBE_BPM_DEFAULTS:
              d = resolve_bpm(0.0, vibe)
              assert d == pytest.approx(VIBE_BPM_DEFAULTS[vibe])


  class TestSnapToNearestBeat:
      """BPMG-02: clip start snapping within +/-1 beat tolerance."""

      def test_empty_beat_grid_returns_original(self):
          assert snap_to_nearest_beat(5.0, [], 120.0) == pytest.approx(5.0)

      def test_snaps_to_nearest_beat_within_tolerance(self):
          """Beat at 0.5s; start at 0.3s; tolerance = 60/120 = 0.5s; 0.3 is within 0.5 of 0.5."""
          beats = [0.0, 0.5, 1.0, 1.5]
          result = snap_to_nearest_beat(0.3, beats, 120.0)
          assert result == pytest.approx(0.5)

      def test_no_beat_within_tolerance_returns_original(self):
          """Start at 5.0; nearest beat is 3.0; tolerance = 0.5s (120 BPM); 2.0s away."""
          beats = [0.0, 1.0, 2.0, 3.0]
          result = snap_to_nearest_beat(5.0, beats, 120.0)
          assert result == pytest.approx(5.0)

      def test_result_never_negative(self):
          """Negative beats filtered; snapped result clamped >= 0.0."""
          beats = [0.0, 0.5, 1.0]
          result = snap_to_nearest_beat(0.1, beats, 120.0)
          assert result >= 0.0

      def test_snaps_to_beat_at_zero(self):
          beats = [0.0, 0.5, 1.0]
          result = snap_to_nearest_beat(0.2, beats, 120.0)
          assert result == pytest.approx(0.0)


  class TestBpmGridDataclass:
      def test_construct_with_defaults(self):
          bg = BpmGrid(bpm=128.0, beat_times_s=[0.0, 0.5, 1.0], source="librosa")
          assert bg.beat_count == 0   # default — caller sets this
          assert bg.bpm == 128.0
          assert bg.source == "librosa"


  class TestInsertSilenceAtZoneBoundary:
      """EORD-04: silence inserted BETWEEN last ESCALATION and first CLIMAX clip."""

      def test_returns_none_when_no_zone_annotations(self):
          from cinecut.assembly.ordering import insert_silence_at_zone_boundary
          from unittest.mock import MagicMock
          # ClipEntry mocks with no narrative_zone
          clips = [MagicMock(spec=[]), MagicMock(spec=[])]
          for c in clips:
              del c.narrative_zone  # ensure attribute absent
          result_path, result_idx = insert_silence_at_zone_boundary(clips, None, 1920, 1080)
          assert result_path is None
          assert result_idx == 0

      def test_boundary_index_points_to_gap_between_escalation_and_climax(self):
          from cinecut.assembly.ordering import insert_silence_at_zone_boundary
          from unittest.mock import MagicMock, patch
          from pathlib import Path

          # 4 clips: [BEGINNING, ESCALATION, ESCALATION, CLIMAX]
          # boundary_index should be 3 (silence inserted AFTER index 2, the last ESCALATION clip)
          clips = []
          for zone in ["BEGINNING", "ESCALATION", "ESCALATION", "CLIMAX"]:
              c = MagicMock()
              c.narrative_zone = zone
              clips.append(c)

          fake_path = Path("/tmp/silence_act2_act3.mp4")
          with patch("cinecut.assembly.ordering.generate_silence_segment", return_value=fake_path):
              result_path, result_idx = insert_silence_at_zone_boundary(
                  clips, Path("/tmp"), 1920, 1080
              )
          assert result_path == fake_path
          assert result_idx == 3  # first 3 clips are before the silence; CLIMAX clip at index 3 comes after

**Part C: tests/test_music.py — unit tests for music.py pure functions**

Create tests/test_music.py:

  import os
  import pytest
  from pathlib import Path
  from unittest.mock import patch, MagicMock
  from cinecut.assembly.music import (
      MusicBed, fetch_music_for_vibe, get_music_cache_dir, VIBE_TO_JAMENDO_TAG
  )


  class TestMusicBedDataclass:
      def test_construct_minimal(self):
          mb = MusicBed(
              track_id="1", track_name="Test Track", artist_name="Artist",
              license_ccurl="https://creativecommons.org/licenses/by/4.0/",
              local_path="/home/user/.cinecut/music/action.mp3",
          )
          assert mb.bpm is None
          assert mb.local_path.endswith(".mp3")

      def test_bpm_assignable(self):
          mb = MusicBed(track_id="1", track_name="T", artist_name="A", license_ccurl="", local_path="/tmp/x.mp3")
          mb.bpm = 128.0
          assert mb.bpm == 128.0


  class TestVibeTagMapping:
      def test_all_vibes_mapped(self):
          expected_vibes = {
              "action", "adventure", "animation", "comedy", "crime", "documentary",
              "drama", "family", "fantasy", "history", "horror", "music",
              "mystery", "romance", "sci-fi", "thriller", "war", "western",
          }
          assert set(VIBE_TO_JAMENDO_TAG.keys()) == expected_vibes

      def test_tags_are_strings(self):
          for vibe, tag in VIBE_TO_JAMENDO_TAG.items():
              assert isinstance(tag, str) and len(tag) > 0, f"Empty tag for vibe '{vibe}'"


  class TestFetchMusicGracefulDegradation:
      """MUSC-03: fetch_music_for_vibe returns None on any failure."""

      def test_returns_none_when_client_id_missing(self, monkeypatch):
          monkeypatch.delenv("JAMENDO_CLIENT_ID", raising=False)
          result = fetch_music_for_vibe("action")
          assert result is None

      def test_returns_none_on_network_error(self, monkeypatch, tmp_path):
          monkeypatch.setenv("JAMENDO_CLIENT_ID", "test-id")
          # Ensure no cache exists
          monkeypatch.setattr("cinecut.assembly.music.get_music_cache_dir", lambda: tmp_path)
          with patch("cinecut.assembly.music.requests.get", side_effect=ConnectionError("timeout")):
              result = fetch_music_for_vibe("action")
          assert result is None

      def test_returns_cached_musicbed_on_cache_hit(self, monkeypatch, tmp_path):
          """MUSC-02: cache hit returns MusicBed without API call."""
          # Create a fake cached file
          cached_file = tmp_path / "action.mp3"
          cached_file.write_bytes(b"fake-mp3-content")
          monkeypatch.setattr("cinecut.assembly.music.get_music_cache_dir", lambda: tmp_path)

          result = fetch_music_for_vibe("action")
          assert result is not None
          assert result.track_id == "cached"
          assert result.local_path == str(cached_file)
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_bpm.py tests/test_music.py -v && python -m pytest tests/ -x -q && python -c "from cinecut.cli import app, TOTAL_STAGES; assert TOTAL_STAGES == 8, f'TOTAL_STAGES={TOTAL_STAGES}'; print('TOTAL_STAGES=8 OK')"</verify>
  <done>
- tests/test_bpm.py and tests/test_music.py pass
- TestInsertSilenceAtZoneBoundary.test_boundary_index_points_to_gap_between_escalation_and_climax confirms boundary_index=3 for [BEGINNING, ESCALATION, ESCALATION, CLIMAX] — silence goes BETWEEN clip index 2 and 3
- cli.py TOTAL_STAGES == 8
- assemble_manifest call site unpacks three values (manifest, extra_paths, silence_injection)
- conform_manifest call passes inject_after_clip and inject_paths from silence_injection
- All existing tests still pass
  </done>
</task>

</tasks>

<verification>
Full test suite:
  cd /home/adamh/ai-video-trailer && python -m pytest tests/ -v

CLI import check:
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.cli import app, TOTAL_STAGES; assert TOTAL_STAGES == 8, f'TOTAL_STAGES={TOTAL_STAGES}'; print('TOTAL_STAGES=8 OK')"

Silence placement correctness check:
  cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.ordering import insert_silence_at_zone_boundary, SILENCE_DURATION_S
from unittest.mock import MagicMock, patch
from pathlib import Path

# Simulate [ESCALATION, ESCALATION, CLIMAX] clips — boundary_index should be 2
clips = []
for zone in ['ESCALATION', 'ESCALATION', 'CLIMAX']:
    c = MagicMock(); c.narrative_zone = zone; clips.append(c)

fake_path = Path('/tmp/silence_act2_act3.mp4')
with patch('cinecut.assembly.ordering.generate_silence_segment', return_value=fake_path):
    silence_path, idx = insert_silence_at_zone_boundary(clips, Path('/tmp'), 1920, 1080)

assert silence_path == fake_path, 'silence_path not returned'
assert idx == 2, f'boundary_index should be 2 (after 2 ESCALATION clips), got {idx}'
print(f'Silence boundary_index={idx}: CORRECT — silence placed between ESCALATION and CLIMAX clips')
"

Conform inject parameter smoke test:
  cd /home/adamh/ai-video-trailer && python -c "
import inspect
from cinecut.conform.pipeline import conform_manifest
sig = inspect.signature(conform_manifest)
params = dict(sig.parameters)
assert 'inject_after_clip' in params, 'inject_after_clip missing from conform_manifest'
assert params['inject_after_clip'].default is None, 'inject_after_clip default should be None'
assert 'inject_paths' in params, 'inject_paths missing from conform_manifest'
assert params['inject_paths'].default is None, 'inject_paths default should be None'
print('conform_manifest inject params: OK — backward compatible (defaults to None)')
"
</verification>

<success_criteria>
- ordering.py: generate_silence_segment and insert_silence_at_zone_boundary importable; SILENCE_DURATION_S = 4.0; insert_silence_at_zone_boundary returns (Path|None, int) where int is boundary_index
- boundary_index correctness: for clips [ESCALATION, ESCALATION, CLIMAX], boundary_index == 2 (silence injected after clip index 1, before clip index 2 which is CLIMAX)
- conform/pipeline.py: conform_manifest has inject_after_clip: int | None = None and inject_paths: list[Path] | None = None; injects inject_paths into concat list at the correct position; all existing calls with only extra_clip_paths still work (backward compatible)
- assembly/__init__.py: assemble_manifest returns 3-tuple (TrailerManifest, list[Path], dict|None); silence_injection is {"index": N, "paths": [silence_path]} when zones present; silence path is NOT in extra_paths
- cli.py: TOTAL_STAGES = 8; Stage 7 (music) checkpoint added; Stage 8 conform; conform_manifest called with inject_after_clip and inject_paths from silence_injection
- tests/test_bpm.py: all tests pass (covers resolve_bpm guards, snap_to_nearest_beat, BpmGrid dataclass, insert_silence_at_zone_boundary boundary index)
- tests/test_music.py: all tests pass (covers MusicBed dataclass, VIBE_TO_JAMENDO_TAG, graceful None returns, cache hit)
- python -m pytest tests/ -x exits 0 — all tests pass including existing suite
- ROADMAP success criterion 4 satisfied: silence appears BETWEEN last ESCALATION clip and first CLIMAX clip in the output trailer
</success_criteria>

<output>
After completion, create .planning/phases/09-bpm-grid-and-music-bed/09-03-SUMMARY.md
</output>
