---
phase: 05-trailer-assembly-and-end-to-end-pipeline
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cinecut/assembly/__init__.py
  - src/cinecut/assembly/ordering.py
  - src/cinecut/assembly/title_card.py
autonomous: true
requirements:
  - EDIT-02
  - EDIT-03

must_haves:
  truths:
    - "Clips are assembled in canonical 3-act order: cold_open → act1 → beat_drop → act2 → breath → act3"
    - "Average cut duration is measurably shorter in act3 than act1 (pacing curve enforced)"
    - "Title card and button segments are generated FFmpeg lavfi black clips, not source film extractions"
    - "A reordered TrailerManifest can be written to disk for inspection before conform"
  artifacts:
    - path: "src/cinecut/assembly/__init__.py"
      provides: "Assembly package exports"
      exports: ["assemble_manifest"]
    - path: "src/cinecut/assembly/ordering.py"
      provides: "sort_clips_by_act(), enforce_pacing_curve(), compute_act_avg_duration()"
      exports: ["ACT_ORDER", "sort_clips_by_act", "enforce_pacing_curve", "compute_act_avg_duration"]
    - path: "src/cinecut/assembly/title_card.py"
      provides: "generate_title_card(), get_video_dimensions()"
      exports: ["generate_title_card", "get_video_dimensions"]
  key_links:
    - from: "sort_clips_by_act()"
      to: "ACT_ORDER priority list"
      via: "sorted(clips, key=lambda c: (act_priority.get(c.act, 999), c.source_start_s))"
      pattern: "act_priority\\.get"
    - from: "enforce_pacing_curve()"
      to: "clip.model_copy(update={'source_end_s': new_end})"
      via: "Pydantic v2 model_copy for immutable trim"
      pattern: "model_copy"
    - from: "generate_title_card()"
      to: "FFmpeg lavfi color source"
      via: "subprocess.run(['ffmpeg', '-f', 'lavfi', ...])"
      pattern: "lavfi"
---

<objective>
Create the `cinecut/assembly/` package implementing 3-act clip ordering, pacing curve enforcement, and FFmpeg-generated title card/button segments.

Purpose: EDIT-02 requires canonical act ordering before conform. EDIT-03 requires measurable pacing curve (act1 avg duration > act3 avg duration). Both are pure Python + FFmpeg subprocess — no new dependencies.

Output: `assembly/` package with `ordering.py` (sort + pacing), `title_card.py` (FFmpeg lavfi), and `__init__.py` exporting `assemble_manifest()`.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types from existing codebase the assembly package must use -->

From src/cinecut/manifest/schema.py:
```python
class ClipEntry(BaseModel):
    source_start_s: float
    source_end_s: float
    beat_type: Literal["inciting_incident", "character_introduction", "escalation_beat",
                       "relationship_beat", "money_shot", "climax_peak", "breath"]
    act: Literal["cold_open", "act1", "beat_drop", "act2", "breath", "act3",
                 "title_card", "button"]
    transition: Literal["hard_cut", "crossfade", "fade_to_black", "fade_to_white"] = "hard_cut"
    dialogue_excerpt: str = ""
    reasoning: Optional[str] = None
    visual_analysis: Optional[str] = None
    subtitle_analysis: Optional[str] = None
    money_shot_score: Optional[float] = None

    # ClipEntry is a Pydantic BaseModel — use .model_copy(update={...}) for immutable updates

class TrailerManifest(BaseModel):
    schema_version: str = "1.0"
    source_file: str
    vibe: str
    clips: list[ClipEntry]
```

From src/cinecut/manifest/vibes.py:
```python
@dataclass(frozen=True)
class VibeProfile:
    act1_avg_cut_s: float   # e.g. 4.0 for action
    act2_avg_cut_s: float   # e.g. 2.5 for action
    act3_avg_cut_s: float   # e.g. 1.2 for action
    primary_transition: str
    secondary_transition: str
    lufs_target: float
    # ... (other fields)

VIBE_PROFILES: dict[str, VibeProfile]  # keyed by canonical vibe name
```

From src/cinecut/errors.py:
```python
class ConformError(CineCutError):
    def __init__(self, output_path: Path, detail: str) -> None: ...
```

CRITICAL anti-pattern from research:
- title_card and button must NOT be ClipEntry objects — they have no source timecode
- Never create ClipEntry(act="title_card", source_start_s=0, source_end_s=5) — this extracts film frames
- Generate them as pre-encoded MP4 files in work_dir and inject paths into concat list directly
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assembly/ordering.py — ACT_ORDER sort and pacing curve enforcement</name>
  <files>
    src/cinecut/assembly/__init__.py
    src/cinecut/assembly/ordering.py
  </files>
  <action>
Create `src/cinecut/assembly/` directory with `__init__.py` and `ordering.py`.

**`src/cinecut/assembly/ordering.py`:**

```python
"""3-act clip ordering and pacing curve enforcement for trailer assembly."""
from cinecut.manifest.schema import ClipEntry, TrailerManifest
from cinecut.manifest.vibes import VibeProfile

# Canonical act sequence for a trailer.
# title_card and button are generated segments — NOT present in the input clips list.
ACT_ORDER = [
    "cold_open",
    "act1",
    "beat_drop",
    "act2",
    "breath",
    "act3",
]

MIN_CLIP_DURATION_S = 0.5  # Never trim below 0.5s to avoid empty clips


def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort clips into canonical 3-act trailer order.

    Within the same act, preserve chronological order (source_start_s ascending).
    Does NOT include title_card or button — those are generated by title_card.py.
    """
    act_priority = {act: i for i, act in enumerate(ACT_ORDER)}
    return sorted(
        clips,
        key=lambda c: (act_priority.get(c.act, 999), c.source_start_s),
    )


def compute_act_avg_duration(clips: list[ClipEntry], act: str) -> float:
    """Return mean clip duration for a specific act. Returns 0.0 if no clips for that act."""
    act_clips = [c for c in clips if c.act == act]
    if not act_clips:
        return 0.0
    return sum(c.source_end_s - c.source_start_s for c in act_clips) / len(act_clips)


def enforce_pacing_curve(
    clips: list[ClipEntry],
    profile: VibeProfile,
) -> list[ClipEntry]:
    """Trim act3 clips to enforce measurable pacing curve (act1_avg > act3_avg).

    If measured act3 average duration exceeds profile.act3_avg_cut_s * 1.5,
    each act3 clip is trimmed to profile.act3_avg_cut_s by adjusting source_end_s.
    Uses model_copy() (Pydantic v2) since ClipEntry is a BaseModel.
    Minimum clip duration: MIN_CLIP_DURATION_S (0.5s) — never trim below this.
    """
    result = list(clips)
    measured_act3_avg = compute_act_avg_duration(result, "act3")
    if measured_act3_avg <= profile.act3_avg_cut_s * 1.5:
        return result  # Already within acceptable range — no trimming needed

    for i, clip in enumerate(result):
        if clip.act == "act3":
            duration = clip.source_end_s - clip.source_start_s
            target = profile.act3_avg_cut_s
            if duration > target * 1.5:
                new_end = clip.source_start_s + max(target, MIN_CLIP_DURATION_S)
                result[i] = clip.model_copy(update={"source_end_s": new_end})
    return result
```

**`src/cinecut/assembly/__init__.py`:**

Export the public surface. `assemble_manifest()` is the entry point called by cli.py:

```python
"""Assembly package: 3-act ordering, pacing enforcement, title card generation."""
import json
from pathlib import Path

from cinecut.assembly.ordering import sort_clips_by_act, enforce_pacing_curve
from cinecut.assembly.title_card import generate_title_card, get_video_dimensions
from cinecut.manifest.schema import TrailerManifest
from cinecut.manifest.vibes import VIBE_PROFILES


def assemble_manifest(
    manifest: TrailerManifest,
    source_file: Path,
    work_dir: Path,
) -> tuple[TrailerManifest, list[Path]]:
    """Apply 3-act ordering and pacing enforcement to a TrailerManifest.

    Steps:
    1. Sort clips into canonical ACT_ORDER (cold_open → act1 → beat_drop → act2 → breath → act3)
    2. Enforce pacing curve (trim act3 clips if average duration > profile.act3_avg_cut_s * 1.5)
    3. Generate title_card.mp4 and button.mp4 as pre-encoded FFmpeg lavfi segments
    4. Write ASSEMBLY_MANIFEST.json (reordered clips only, excludes generated segments)
    5. Return (reordered_manifest, [title_card_path, button_path])

    The returned list of extra_paths must be appended AFTER act3 clips in the concat list
    by the caller (cli.py). They are NOT ClipEntry objects.

    Args:
        manifest: Original TrailerManifest from run_narrative_stage().
        source_file: Original video file (for resolution detection).
        work_dir: Working directory for ASSEMBLY_MANIFEST.json and generated segments.

    Returns:
        (reordered_manifest, extra_paths) where extra_paths = [title_card_path, button_path]
    """
    profile = VIBE_PROFILES[manifest.vibe]

    # Step 1: Sort into canonical act order
    ordered_clips = sort_clips_by_act(manifest.clips)

    # Step 2: Enforce pacing curve on act3 clips
    paced_clips = enforce_pacing_curve(ordered_clips, profile)

    # Step 3: Generate title card (5s black) and button (2s black fade-out)
    width, height = get_video_dimensions(source_file)
    title_card_path = generate_title_card(
        title_text="",       # Plain black card per research recommendation
        width=width,
        height=height,
        duration_s=5.0,
        output_path=work_dir / "title_card.mp4",
    )
    button_path = generate_title_card(
        title_text="",
        width=width,
        height=height,
        duration_s=2.0,
        output_path=work_dir / "button.mp4",
    )

    # Step 4: Build and write reordered manifest (source clips only)
    reordered_manifest = manifest.model_copy(update={"clips": paced_clips})
    assembly_manifest_path = work_dir / "ASSEMBLY_MANIFEST.json"
    assembly_manifest_path.write_text(
        reordered_manifest.model_dump_json(indent=2), encoding="utf-8"
    )

    return reordered_manifest, [title_card_path, button_path]
```
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.ordering import sort_clips_by_act, enforce_pacing_curve, compute_act_avg_duration, ACT_ORDER
from cinecut.manifest.schema import ClipEntry

# Build test clips in wrong act order
clips = [
    ClipEntry(source_start_s=60.0, source_end_s=64.0, beat_type='escalation_beat', act='act1', transition='hard_cut'),
    ClipEntry(source_start_s=10.0, source_end_s=14.0, beat_type='character_introduction', act='cold_open', transition='hard_cut'),
    ClipEntry(source_start_s=100.0, source_end_s=102.0, beat_type='climax_peak', act='act3', transition='hard_cut'),
    ClipEntry(source_start_s=90.0, source_end_s=92.0, beat_type='money_shot', act='act3', transition='hard_cut'),
]
ordered = sort_clips_by_act(clips)
assert ordered[0].act == 'cold_open', f'Expected cold_open first, got {ordered[0].act}'
assert ordered[1].act == 'act1', f'Expected act1 second, got {ordered[1].act}'
assert ordered[2].act == 'act3', f'Expected act3 third, got {ordered[2].act}'
assert ordered[2].source_start_s == 90.0, 'act3 clips should be chronological'
print('PASS: sort_clips_by_act')

# Pacing enforcement
from cinecut.manifest.vibes import VIBE_PROFILES
profile = VIBE_PROFILES['action']  # act3_avg_cut_s = 1.2
long_act3_clips = [
    ClipEntry(source_start_s=100.0, source_end_s=110.0, beat_type='climax_peak', act='act3', transition='hard_cut'),
    ClipEntry(source_start_s=120.0, source_end_s=130.0, beat_type='money_shot', act='act3', transition='hard_cut'),
]
paced = enforce_pacing_curve(long_act3_clips, profile)
act3_avg = compute_act_avg_duration(paced, 'act3')
assert act3_avg <= profile.act3_avg_cut_s * 1.5 + 0.01, f'Pacing not enforced: avg={act3_avg}'
print(f'PASS: enforce_pacing_curve (act3_avg={act3_avg:.2f}s)')
print('ALL ORDERING TESTS PASS')
"
</automated>
  </verify>
  <done>
    - `src/cinecut/assembly/__init__.py` exists with `assemble_manifest()` exported
    - `src/cinecut/assembly/ordering.py` exists with `ACT_ORDER`, `sort_clips_by_act`, `enforce_pacing_curve`, `compute_act_avg_duration`
    - Sort test passes: cold_open comes before act1 comes before act3
    - Pacing enforcement test passes: act3 avg duration reduced to ≤ act3_avg_cut_s * 1.5
  </done>
</task>

<task type="auto">
  <name>Task 2: Create assembly/title_card.py — FFmpeg lavfi black segment generation</name>
  <files>src/cinecut/assembly/title_card.py</files>
  <action>
Create `src/cinecut/assembly/title_card.py`:

```python
"""FFmpeg lavfi-based title card and button segment generation."""
import json
import subprocess
from pathlib import Path

from cinecut.errors import ConformError


def get_video_dimensions(source: Path) -> tuple[int, int]:
    """Return (width, height) of first video stream via ffprobe JSON output.

    Falls back to (1920, 1080) if ffprobe fails (Pitfall 6: ffprobe may not be in PATH
    on some installs; both ffmpeg and ffprobe are confirmed present on this machine).
    """
    cmd = [
        "ffprobe", "-v", "quiet",
        "-print_format", "json",
        "-show_streams",
        "-select_streams", "v:0",
        str(source),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=False)
    if result.returncode != 0:
        return (1920, 1080)
    try:
        data = json.loads(result.stdout)
        streams = data.get("streams", [])
        if streams:
            return (int(streams[0]["width"]), int(streams[0]["height"]))
    except (json.JSONDecodeError, KeyError, ValueError):
        pass
    return (1920, 1080)


def generate_title_card(
    title_text: str,
    width: int,
    height: int,
    duration_s: float,
    output_path: Path,
    font_size: int = 64,
) -> Path:
    """Generate a pre-encoded black MP4 segment via FFmpeg lavfi color source.

    For Phase 5, title_text="" generates a plain black frame (no text overlay).
    Uses the same codec/framerate as extract_and_grade_clip() to ensure concat
    demuxer compatibility: libx264 crf=18 preset=veryfast, aac 48000Hz.

    Args:
        title_text: Text to overlay on black. Empty string = plain black card.
        width: Video width in pixels (match source resolution).
        height: Video height in pixels.
        duration_s: Duration of the segment in seconds.
        output_path: Destination .mp4 path.
        font_size: drawtext font size (only used when title_text is non-empty).

    Returns:
        output_path on success.

    Raises:
        ConformError: If FFmpeg lavfi generation fails.
    """
    if title_text:
        vf = (
            f"color=c=black:s={width}x{height}:r=24,"
            f"drawtext=text='{title_text}':fontsize={font_size}"
            f":fontcolor=white:x=(w-text_w)/2:y=(h-text_h)/2"
        )
    else:
        vf = f"color=c=black:s={width}x{height}:r=24"

    cmd = [
        "ffmpeg", "-y",
        "-f", "lavfi", "-i", vf,
        "-t", str(duration_s),
        "-f", "lavfi", "-i", f"anullsrc=channel_layout=stereo:sample_rate=48000",
        "-c:v", "libx264",
        "-crf", "18",
        "-preset", "veryfast",
        "-c:a", "aac",
        "-ar", "48000",
        "-t", str(duration_s),
        str(output_path),
    ]
    result = subprocess.run(cmd, capture_output=True, text=True, check=False)
    if result.returncode != 0:
        raise ConformError(output_path, result.stderr[-500:])
    return output_path
```

CRITICAL: Do NOT create ClipEntry objects for title_card or button acts. These segments are generated standalone files injected into the FFmpeg concat list directly by `conform_manifest()` or the caller. Passing them as ClipEntry with fake source timecodes would extract 5 seconds of film from the beginning (Pitfall 1 from research).
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
import tempfile
from pathlib import Path
from cinecut.assembly.title_card import generate_title_card, get_video_dimensions

tmp = Path(tempfile.mkdtemp())
out = tmp / 'test_title_card.mp4'
result = generate_title_card(title_text='', width=1920, height=1080, duration_s=2.0, output_path=out)
assert out.exists(), 'title_card.mp4 not created'
assert out.stat().st_size > 1000, f'title_card.mp4 too small: {out.stat().st_size} bytes'
print(f'PASS: title_card generated ({out.stat().st_size} bytes)')
"
</automated>
  </verify>
  <done>
    - `src/cinecut/assembly/title_card.py` exists with `generate_title_card()` and `get_video_dimensions()`
    - `generate_title_card()` uses FFmpeg lavfi (not PIL/Pillow), raises `ConformError` on failure
    - Smoke test: 2-second 1920x1080 black MP4 generated successfully, file size > 1000 bytes
    - `from cinecut.assembly import assemble_manifest` imports without error
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly import assemble_manifest
from cinecut.assembly.ordering import sort_clips_by_act, enforce_pacing_curve, compute_act_avg_duration, ACT_ORDER
from cinecut.assembly.title_card import generate_title_card, get_video_dimensions
print('All assembly imports OK')

# Verify ACT_ORDER is correct sequence
assert ACT_ORDER == ['cold_open', 'act1', 'beat_drop', 'act2', 'breath', 'act3']
print('ACT_ORDER correct')

# Verify pacing curve helper
from cinecut.manifest.schema import ClipEntry
clips = [
    ClipEntry(source_start_s=0.0, source_end_s=4.0, beat_type='character_introduction', act='act1', transition='hard_cut'),
    ClipEntry(source_start_s=50.0, source_end_s=53.0, beat_type='escalation_beat', act='act2', transition='hard_cut'),
    ClipEntry(source_start_s=100.0, source_end_s=101.5, beat_type='climax_peak', act='act3', transition='hard_cut'),
]
act1_avg = compute_act_avg_duration(clips, 'act1')
act3_avg = compute_act_avg_duration(clips, 'act3')
assert act1_avg > act3_avg, f'Pacing curve check: act1={act1_avg:.2f} act3={act3_avg:.2f}'
print(f'Pacing curve natural: act1={act1_avg:.2f}s > act3={act3_avg:.2f}s')
print('ALL ASSEMBLY VERIFICATION PASS')
"
```
</verification>

<success_criteria>
- `src/cinecut/assembly/__init__.py`, `ordering.py`, `title_card.py` all exist
- `from cinecut.assembly import assemble_manifest` imports cleanly
- `sort_clips_by_act()` produces canonical act order
- `enforce_pacing_curve()` trims act3 clips exceeding 1.5x the vibe target
- `generate_title_card()` produces a playable MP4 via FFmpeg lavfi
- No title_card or button ClipEntry objects created (generated files only)
</success_criteria>

<output>
After completion, create `.planning/phases/05-trailer-assembly-and-end-to-end-pipeline/05-02-SUMMARY.md`
</output>
