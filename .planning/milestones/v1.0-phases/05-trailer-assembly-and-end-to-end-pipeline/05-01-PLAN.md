---
phase: 05-trailer-assembly-and-end-to-end-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cinecut/checkpoint.py
autonomous: true
requirements:
  - PIPE-04

must_haves:
  truths:
    - "Pipeline stage completion is persisted to disk after each stage completes"
    - "A crashed or interrupted run can resume by loading the checkpoint and skipping completed stages"
    - "Checkpoint file is either intact or absent — never corrupt (atomic write)"
    - "Checkpoint with a different source_file is ignored (triggers clean restart)"
  artifacts:
    - path: "src/cinecut/checkpoint.py"
      provides: "PipelineCheckpoint dataclass, load_checkpoint(), save_checkpoint()"
      exports: ["PipelineCheckpoint", "load_checkpoint", "save_checkpoint"]
  key_links:
    - from: "save_checkpoint()"
      to: "work_dir/pipeline_checkpoint.json"
      via: "tempfile.mkstemp(dir=work_dir) + os.replace()"
      pattern: "os\\.replace"
    - from: "load_checkpoint()"
      to: "PipelineCheckpoint"
      via: "json.loads + PipelineCheckpoint(**data)"
      pattern: "PipelineCheckpoint\\(\\*\\*data\\)"
---

<objective>
Create `src/cinecut/checkpoint.py` implementing atomic JSON checkpoint read/write for the CineCut pipeline.

Purpose: Stage-based resumability (PIPE-04) — when a 30-60 minute pipeline crashes, the next run skips already-completed stages instead of restarting from scratch.

Output: `PipelineCheckpoint` dataclass + `load_checkpoint()` + `save_checkpoint()` using POSIX-atomic `os.replace()` pattern.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types from existing codebase that checkpoint.py must align with -->

From src/cinecut/errors.py:
```python
class CineCutError(Exception): ...
# (checkpoint.py does NOT raise CineCutError — corrupt checkpoint returns None)
```

Checkpoint file location convention:
- `work_dir` = `<source_stem>_cinecut_work/` (created by `_setup_work_dir()` in cli.py)
- Checkpoint file: `work_dir / "pipeline_checkpoint.json"`

Stage name strings (keys used in `stages_complete` list):
- "proxy", "subtitles", "keyframes", "inference", "narrative", "assembly"
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement checkpoint.py — PipelineCheckpoint dataclass and atomic read/write</name>
  <files>src/cinecut/checkpoint.py</files>
  <action>
Create `src/cinecut/checkpoint.py` with the following exact implementation:

```python
"""Atomic pipeline checkpoint for CineCut stage-based resumability (PIPE-04)."""
import json
import os
import tempfile
from dataclasses import dataclass, asdict, field
from pathlib import Path
from typing import Optional

CHECKPOINT_FILENAME = "pipeline_checkpoint.json"


@dataclass
class PipelineCheckpoint:
    """Persisted state across all pipeline stages. Written atomically after each stage."""
    source_file: str          # Absolute path to source video (used to detect stale checkpoint)
    vibe: str                 # Normalized vibe name

    stages_complete: list[str] = field(default_factory=list)

    # Stage outputs (None until stage completes and checkpoint is saved)
    proxy_path: Optional[str] = None
    keyframe_count: Optional[int] = None
    dialogue_event_count: Optional[int] = None
    inference_complete: Optional[bool] = None
    manifest_path: Optional[str] = None
    assembly_manifest_path: Optional[str] = None

    def is_stage_complete(self, stage: str) -> bool:
        """Return True if the given stage name is in stages_complete."""
        return stage in self.stages_complete

    def mark_stage_complete(self, stage: str) -> None:
        """Append stage to stages_complete if not already present."""
        if stage not in self.stages_complete:
            self.stages_complete.append(stage)
```

Then add `load_checkpoint()`:
- Accepts `work_dir: Path`
- Builds `ckpt_path = work_dir / CHECKPOINT_FILENAME`
- If `ckpt_path` does not exist, return `None`
- `try: data = json.loads(ckpt_path.read_text(encoding="utf-8")); return PipelineCheckpoint(**data)`
- `except (json.JSONDecodeError, TypeError): return None` — corrupt checkpoint: triggers clean restart (Pitfall 4 from research)

Then add `save_checkpoint()`:
- Accepts `checkpoint: PipelineCheckpoint, work_dir: Path`
- `ckpt_path = work_dir / CHECKPOINT_FILENAME`
- `data = json.dumps(asdict(checkpoint), indent=2).encode("utf-8")`
- `fd, tmp_path = tempfile.mkstemp(dir=work_dir, suffix=".ckpt.tmp")` — MUST be in same dir for POSIX atomicity
- In try block: `os.write(fd, data)` → `os.fsync(fd)` → `os.close(fd)` → `os.replace(tmp_path, ckpt_path)`
- In except block: `os.close(fd); os.unlink(tmp_path); raise`

Do NOT use `Path.write_text()` for the checkpoint — it is NOT atomic (truncates then writes). The `os.replace()` pattern is power-loss safe.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint; import tempfile, pathlib; d = pathlib.Path(tempfile.mkdtemp()); ckpt = PipelineCheckpoint(source_file='/tmp/film.mkv', vibe='action'); ckpt.mark_stage_complete('proxy'); ckpt.proxy_path='/tmp/work/film.mp4'; save_checkpoint(ckpt, d); loaded = load_checkpoint(d); assert loaded.stages_complete == ['proxy']; assert loaded.proxy_path == '/tmp/work/film.mp4'; print('PASS: checkpoint round-trip')"</automated>
  </verify>
  <done>
    - `src/cinecut/checkpoint.py` exists with `PipelineCheckpoint`, `load_checkpoint`, `save_checkpoint` exported
    - `load_checkpoint()` returns `None` for missing or corrupt checkpoint files
    - `save_checkpoint()` uses `tempfile.mkstemp(dir=work_dir)` + `os.replace()` (not `Path.write_text`)
    - Round-trip test passes: save checkpoint, load checkpoint, fields match
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/adamh/ai-video-trailer && python -c "
from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint
import tempfile, pathlib, json

d = pathlib.Path(tempfile.mkdtemp())

# Test 1: missing checkpoint returns None
assert load_checkpoint(d) is None, 'missing -> None'

# Test 2: corrupt checkpoint returns None (not crash)
(d / 'pipeline_checkpoint.json').write_text('{broken json', encoding='utf-8')
assert load_checkpoint(d) is None, 'corrupt -> None'

# Test 3: round-trip save/load
ckpt = PipelineCheckpoint(source_file='/tmp/film.mkv', vibe='action')
ckpt.mark_stage_complete('proxy')
ckpt.proxy_path = '/tmp/work/proxy.mp4'
ckpt.mark_stage_complete('subtitles')
ckpt.dialogue_event_count = 42
save_checkpoint(ckpt, d)
loaded = load_checkpoint(d)
assert loaded.source_file == '/tmp/film.mkv'
assert loaded.vibe == 'action'
assert loaded.is_stage_complete('proxy')
assert loaded.is_stage_complete('subtitles')
assert not loaded.is_stage_complete('keyframes')
assert loaded.proxy_path == '/tmp/work/proxy.mp4'
assert loaded.dialogue_event_count == 42

# Test 4: save uses os.replace (check no .tmp files remain)
import os
remaining = list(d.glob('*.tmp'))
assert remaining == [], f'Temp files not cleaned up: {remaining}'

print('ALL CHECKPOINT TESTS PASS')
"
```
</verification>

<success_criteria>
- `src/cinecut/checkpoint.py` exists
- `from cinecut.checkpoint import PipelineCheckpoint, load_checkpoint, save_checkpoint` imports without error
- All four inline verification assertions pass
- No `.ckpt.tmp` files remain after save (atomic cleanup confirmed)
</success_criteria>

<output>
After completion, create `.planning/phases/05-trailer-assembly-and-end-to-end-pipeline/05-01-SUMMARY.md`
</output>
