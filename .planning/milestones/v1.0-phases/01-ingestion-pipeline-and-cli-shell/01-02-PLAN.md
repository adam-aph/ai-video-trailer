---
phase: 01-ingestion-pipeline-and-cli-shell
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/cinecut/ingestion/subtitles.py
  - src/cinecut/ingestion/proxy.py
  - tests/test_subtitles.py
  - tests/test_proxy.py
autonomous: true
requirements:
  - PIPE-02
  - NARR-01

must_haves:
  truths:
    - "Given a valid SRT file, `parse_subtitles()` returns a list of `DialogueEvent` objects with correct PTS seconds and emotion labels"
    - "Given a valid ASS file, `parse_subtitles()` returns the same structured output (no format-specific code paths)"
    - "Given a non-UTF-8 subtitle file, `parse_subtitles()` detects the encoding with charset-normalizer and retries rather than silently returning an empty list"
    - "Given a valid source video, `create_proxy()` produces a 420p CFR MP4 at 24fps in the work directory"
    - "Given a corrupt or incomplete proxy, `validate_proxy()` raises `ProxyValidationError` with a human-readable message"
    - "FFmpeg stderr is never surfaced directly to the caller — all failures raise typed errors"
  artifacts:
    - path: "src/cinecut/ingestion/subtitles.py"
      provides: "SRT/ASS subtitle parser with emotion classification"
      exports: ["parse_subtitles", "classify_emotion"]
    - path: "src/cinecut/ingestion/proxy.py"
      provides: "FFmpeg proxy creation, ffprobe metadata extraction, proxy validation"
      exports: ["create_proxy", "probe_video", "validate_proxy"]
    - path: "tests/test_subtitles.py"
      provides: "Unit tests for subtitle parsing and emotion classification"
    - path: "tests/test_proxy.py"
      provides: "Unit tests for ffprobe parsing and proxy validation logic"
  key_links:
    - from: "src/cinecut/ingestion/subtitles.py"
      to: "src/cinecut/models.py:DialogueEvent"
      via: "import and instantiation"
      pattern: "from.*models.*import.*DialogueEvent"
    - from: "src/cinecut/ingestion/proxy.py"
      to: "src/cinecut/errors.py:ProxyCreationError"
      via: "raise on FFmpeg failure"
      pattern: "raise ProxyCreationError"
    - from: "src/cinecut/ingestion/proxy.py"
      to: "src/cinecut/errors.py:ProxyValidationError"
      via: "raise on corrupt proxy detection"
      pattern: "raise ProxyValidationError"
---

<objective>
Implement the two core ingestion modules: the subtitle parser (NARR-01) and the FFmpeg proxy creator (PIPE-02), both built against the contracts established in plan 01.

Purpose: The subtitle parser produces `DialogueEvent` lists that the keyframe extractor (plan 03) uses for primary timestamp selection. The proxy creator produces the CFR 420p video that all downstream analysis runs against. Both modules must handle their failure modes explicitly — encoding errors for subtitles, corrupt output for proxy — so the CLI (plan 03) can surface clean error messages per CLI-03.

Output: `ingestion/subtitles.py`, `ingestion/proxy.py`, and unit tests for both.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-RESEARCH.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-01-SUMMARY.md

<interfaces>
<!-- Contracts from plan 01 that these modules must use. -->

From src/cinecut/models.py:
```python
from dataclasses import dataclass

@dataclass
class DialogueEvent:
    start_ms: int          # pysubs2 native unit (milliseconds)
    end_ms: int
    start_s: float         # PTS seconds for downstream use
    end_s: float
    midpoint_s: float      # Used as primary keyframe timestamp (PIPE-03)
    text: str              # Cleaned, ASS-tag-stripped text
    emotion: str           # "positive" | "negative" | "neutral" | "intense" | "comedic" | "romantic"

@dataclass
class KeyframeRecord:
    timestamp_s: float     # PTS seconds in the proxy
    frame_path: str        # Absolute path to the JPEG file
    source: str            # "subtitle_midpoint" | "scene_change" | "interval_fallback"
```

From src/cinecut/errors.py:
```python
class ProxyCreationError(CineCutError):
    def __init__(self, source: Path, detail: str) -> None: ...

class ProxyValidationError(CineCutError):
    def __init__(self, proxy_path: Path, detail: str) -> None: ...

class SubtitleParseError(CineCutError):
    def __init__(self, path: Path, detail: str) -> None: ...
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement subtitle parser with emotion classification</name>
  <files>
    src/cinecut/ingestion/subtitles.py
    tests/test_subtitles.py
  </files>
  <action>
**`src/cinecut/ingestion/subtitles.py`**:

Implement `parse_subtitles(subtitle_path: Path) -> list[DialogueEvent]` using pysubs2 1.8.0.

Key implementation rules:
1. First attempt `pysubs2.load(str(subtitle_path), encoding="utf-8")`
2. On `UnicodeDecodeError`, use `charset_normalizer.from_path(subtitle_path)` to detect encoding. If a result is found, retry with the best-match encoding. If charset-normalizer also fails, raise `SubtitleParseError(subtitle_path, "Could not determine file encoding. Re-save as UTF-8.")`. Never use `errors='ignore'` — silent drops are worse than explicit failures (Pitfall 4).
3. Skip events where `event.is_comment` is True or `event.plaintext.strip()` is empty.
4. Use `event.plaintext` (not `event.text`) — pysubs2 plaintext property strips ASS override tags.
5. Compute `start_s = event.start / 1000.0`, `end_s = event.end / 1000.0`, `midpoint_s = round((start_s + end_s) / 2.0, 3)`.
6. Store emotion from `classify_emotion(text)`.

Implement `classify_emotion(text: str) -> str`:
- Input is lowercased and split into words
- Check against this keyword dictionary (in priority order: intense > romantic > comedic > negative > positive > neutral):
  ```python
  _EMOTION_KEYWORDS: dict[str, set[str]] = {
      "intense":  {"now", "run", "fight", "stop", "must", "war", "attack", "danger", "kill", "die"},
      "romantic": {"heart", "together", "always", "forever", "kiss", "love", "feel"},
      "comedic":  {"ha", "funny", "joke", "laugh", "silly", "weird", "crazy"},
      "negative": {"hate", "lost", "never", "dead", "fail", "cry", "wrong", "afraid"},
      "positive": {"happy", "wonderful", "hope", "proud", "yes", "win", "joy", "great", "safe"},
  }
  ```
- Return the first matching label, or `"neutral"` if no keywords match.
- Note: "love" appears in both `intense` and `romantic` keyword sets; `intense` is checked first, so "love" alone → romantic; "love" + "kill" → intense.
- Note: "love" should only be in `romantic`. Keep it clean: `intense` has kill/die/war/attack/fight/stop/must/run/now/danger; `romantic` has heart/together/always/forever/kiss/love/feel.

**`tests/test_subtitles.py`**:

Write unit tests using pytest (no external fixtures needed — create test data inline as strings, write to tmp_path):

```python
# Tests to include:
# test_parse_srt_basic: Write a minimal SRT string to tmp_path, call parse_subtitles, assert DialogueEvent count and field values
# test_parse_ass_basic: Write a minimal ASS string to tmp_path (with [Script Info] and [Events] sections), call parse_subtitles
# test_skips_empty_events: SRT with blank lines between events produces no empty DialogueEvents
# test_classify_neutral: text with no keywords → "neutral"
# test_classify_intense: text containing "fight" → "intense"
# test_classify_romantic: text containing "forever" → "romantic"
# test_midpoint_calculation: event start=0ms end=2000ms → midpoint_s=1.0
# test_pts_seconds: start_ms=5000 → start_s=5.0
```

Use `tmp_path` pytest fixture to write test subtitle files. Do not depend on any real media file.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_subtitles.py -v --tb=short 2>&1 | tail -20</automated>
  </verify>
  <done>
All tests in `tests/test_subtitles.py` pass. `parse_subtitles()` handles both SRT and ASS inputs, skips empty/comment events, produces `DialogueEvent` objects with correct PTS seconds and midpoint, and `classify_emotion()` returns correct labels for the keyword sets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FFmpeg proxy creation with validation</name>
  <files>
    src/cinecut/ingestion/proxy.py
    tests/test_proxy.py
  </files>
  <action>
**`src/cinecut/ingestion/proxy.py`**:

Implement three functions:

**`probe_video(source: Path) -> dict`**:
- Run `ffprobe -v quiet -print_format json -show_streams -select_streams v:0 <source>`
- Parse JSON output, extract `streams[0]`
- Return `{"duration_seconds": float(stream.get("duration", 0)), "r_frame_rate": stream["r_frame_rate"]}`
- Wrap `subprocess.CalledProcessError` in `ProxyCreationError(source, "ffprobe failed: ...")` — do not let raw subprocess errors escape.

**`create_proxy(source: Path, work_dir: Path, progress_callback=None) -> Path`**:
- Compute `proxy_path = work_dir / f"{source.stem}_proxy.mp4"`
- If `proxy_path` exists and is valid (call `validate_proxy()` without raising), return it immediately (idempotent re-runs).
- Build FFmpeg command:
  ```python
  [
      "ffmpeg", "-y",
      "-i", str(source),
      "-vf", "scale=-2:420,fps=24",
      "-vsync", "cfr",          # Works on all FFmpeg versions; emits deprecation on 5.1+ (acceptable)
      "-c:v", "libx264",
      "-crf", "28",
      "-preset", "fast",
      "-an",                    # No audio — proxy is for visual analysis only
      str(proxy_path),
  ]
  ```
- Use `better_ffmpeg_progress.FfmpegProcess` to run the command so Rich progress is available to callers.
- Catch `FfmpegProcessError` → raise `ProxyCreationError(source, str(e))`.
- After the process completes, call `validate_proxy(proxy_path, source)` to detect Pitfall 3 (corrupt proxy).
- Return `proxy_path`.

**`validate_proxy(proxy_path: Path, source: Path) -> None`**:
- Run `ffprobe -v quiet -print_format json -show_streams -select_streams v:0 <proxy_path>`
- Parse JSON. Validate:
  - `streams` list is non-empty
  - `streams[0]["codec_type"] == "video"`
  - `float(streams[0].get("duration", 0)) > 0`
- If any check fails, raise `ProxyValidationError(proxy_path, "<specific reason>")` and delete the corrupt proxy file so the next run re-encodes it.

**`tests/test_proxy.py`**:

Write unit tests using pytest and `unittest.mock`:

```python
# Tests to include (no real FFmpeg calls — mock subprocess):
# test_probe_video_parses_json: mock subprocess.run to return known JSON; assert duration_seconds and r_frame_rate
# test_probe_video_raises_on_failure: mock subprocess.run to raise CalledProcessError; assert ProxyCreationError raised
# test_validate_proxy_passes_good_output: mock ffprobe JSON with valid video stream; assert no exception
# test_validate_proxy_raises_on_empty_streams: mock ffprobe JSON with empty streams list; assert ProxyValidationError
# test_validate_proxy_raises_on_zero_duration: mock ffprobe JSON with duration "0"; assert ProxyValidationError
# test_create_proxy_idempotent: if proxy exists and validates, create_proxy returns early without calling FfmpegProcess
```

For the idempotency test: create a real file at the proxy path, mock `validate_proxy` to succeed, mock `FfmpegProcess`, assert `FfmpegProcess` was not called.

These tests validate the logic layer without requiring FFmpeg to be installed in the test environment.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_proxy.py -v --tb=short 2>&1 | tail -20</automated>
  </verify>
  <done>
All tests in `tests/test_proxy.py` pass. `probe_video()` correctly parses ffprobe JSON and raises `ProxyCreationError` on subprocess failure. `validate_proxy()` raises `ProxyValidationError` for empty streams and zero duration. `create_proxy()` is idempotent (returns cached proxy without calling FFmpeg again when a valid proxy exists).
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
- `python -m pytest tests/test_subtitles.py tests/test_proxy.py -v` passes all tests
- `python -c "from cinecut.ingestion.subtitles import parse_subtitles; from cinecut.ingestion.proxy import create_proxy, probe_video, validate_proxy"` succeeds without ImportError
- `classify_emotion("I must fight")` returns `"intense"`
- `classify_emotion("hello world")` returns `"neutral"`
</verification>

<success_criteria>
`parse_subtitles()` handles SRT and ASS files, skips blank/comment events, and returns `DialogueEvent` objects with correct PTS seconds, midpoint timestamps, and emotion labels. `create_proxy()` uses `better-ffmpeg-progress` for the FFmpeg call, is idempotent on re-runs, and validates proxy integrity after creation. All failure paths raise typed `CineCutError` subclasses — no raw subprocess output escapes to callers. Unit tests pass without requiring real FFmpeg or media files.
</success_criteria>

<output>
After completion, create `.planning/phases/01-ingestion-pipeline-and-cli-shell/01-02-SUMMARY.md` following the summary template.
</output>
