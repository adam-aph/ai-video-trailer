---
phase: 01-ingestion-pipeline-and-cli-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/cinecut/__init__.py
  - src/cinecut/models.py
  - src/cinecut/errors.py
autonomous: true
requirements:
  - PIPE-01
  - CLI-03

must_haves:
  truths:
    - "The `cinecut` package is pip-installable from the project root"
    - "Importing `cinecut.models` yields `DialogueEvent` and `KeyframeRecord` dataclasses"
    - "Importing `cinecut.errors` yields `ProxyCreationError`, `KeyframeExtractionError`, and `SubtitleParseError` with human-readable messages"
    - "All three error classes produce messages that name the file, describe the cause, and offer a corrective suggestion"
  artifacts:
    - path: "pyproject.toml"
      provides: "Package metadata, dependencies, and cinecut entry point declaration"
      contains: "[project.scripts]"
    - path: "src/cinecut/__init__.py"
      provides: "Package root marker"
    - path: "src/cinecut/models.py"
      provides: "Shared dataclasses DialogueEvent and KeyframeRecord"
      exports: ["DialogueEvent", "KeyframeRecord"]
    - path: "src/cinecut/errors.py"
      provides: "Human-readable error translation layer"
      exports: ["ProxyCreationError", "KeyframeExtractionError", "SubtitleParseError"]
  key_links:
    - from: "src/cinecut/errors.py"
      to: "CLI-03 requirement"
      via: "Human-readable __str__ on each exception class"
      pattern: "class.*Error.*Exception"
    - from: "pyproject.toml"
      to: "src/cinecut/cli:app"
      via: "[project.scripts] cinecut entry point"
      pattern: "cinecut.*cinecut\\.cli:app"
---

<objective>
Establish the Python package scaffold, shared data contracts, and error translation layer that every subsequent ingestion module will import.

Purpose: Before any feature module can be written, the package must be installable (so `from cinecut.models import ...` works), the data structures must be defined (so subtitles.py, keyframes.py, and cli.py all share the same types), and the error layer must exist (so CLI-03 is implementable from day one rather than retrofitted).

Output: An installable `cinecut` package with `models.py` (shared dataclasses) and `errors.py` (human-readable exceptions). No business logic yet — only contracts.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-ingestion-pipeline-and-cli-shell/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pyproject.toml and package skeleton</name>
  <files>
    pyproject.toml
    src/cinecut/__init__.py
    src/cinecut/ingestion/__init__.py
    tests/__init__.py
  </files>
  <action>
Create `pyproject.toml` at the project root with:
- `[build-system]`: `hatchling` as build backend (`requires = ["hatchling"]`, `build-backend = "hatchling.build"`)
- `[project]` section:
  - `name = "cinecut"`
  - `version = "0.1.0"`
  - `requires-python = ">=3.10"`
  - `dependencies`:
    - `"typer>=0.12.0"`
    - `"rich>=13.0.0"`
    - `"pysubs2==1.8.0"`
    - `"scenedetect[opencv-headless]==0.6.7.1"`
    - `"better-ffmpeg-progress==4.0.1"`
    - `"charset-normalizer>=3.0.0"`
- `[project.scripts]` section: `cinecut = "cinecut.cli:app"`
- `[tool.hatch.build.targets.wheel]` section: `packages = ["src/cinecut"]`

Create the directory structure:
- `src/cinecut/__init__.py` — empty file (package marker)
- `src/cinecut/ingestion/__init__.py` — empty file (subpackage marker)
- `tests/__init__.py` — empty file

Install the package in editable mode: `pip install -e .`

Use `hatchling` not `setuptools` — it handles `src/` layout automatically with the `packages` config. Do NOT add `[tool.setuptools]` sections.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && pip install -e . --quiet && python -c "import cinecut; print('OK')"</automated>
  </verify>
  <done>
`pip install -e .` exits 0 and `python -c "import cinecut"` executes without ImportError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create models.py and errors.py</name>
  <files>
    src/cinecut/models.py
    src/cinecut/errors.py
  </files>
  <action>
**`src/cinecut/models.py`** — Shared data contracts using stdlib `dataclasses` (not Pydantic — validation overhead is not needed at ingestion layer; Pydantic is reserved for Phase 2 manifest work):

```python
from dataclasses import dataclass

@dataclass
class DialogueEvent:
    """A single subtitle dialogue event with timestamps and emotional classification."""
    start_ms: int          # pysubs2 native unit (milliseconds)
    end_ms: int
    start_s: float         # PTS seconds for downstream use
    end_s: float
    midpoint_s: float      # Used as primary keyframe timestamp (PIPE-03)
    text: str              # Cleaned, ASS-tag-stripped text
    emotion: str           # "positive" | "negative" | "neutral" | "intense" | "comedic" | "romantic"

@dataclass
class KeyframeRecord:
    """A single extracted keyframe with its source timestamp."""
    timestamp_s: float     # PTS seconds in the proxy
    frame_path: str        # Absolute path to the JPEG file
    source: str            # "subtitle_midpoint" | "scene_change" | "interval_fallback"
```

**`src/cinecut/errors.py`** — Human-readable error translation layer implementing CLI-03. Each class produces a message that names the file, describes the cause, and offers a corrective suggestion — never exposing raw FFmpeg stderr:

```python
from pathlib import Path


class CineCutError(Exception):
    """Base class for all CineCut errors."""


class ProxyCreationError(CineCutError):
    def __init__(self, source: Path, detail: str) -> None:
        super().__init__(
            f"Failed to create analysis proxy from '{source.name}'.\n"
            f"  Cause: {detail}\n"
            f"  Check: Is FFmpeg installed and in PATH? Is '{source.name}' a valid MKV/AVI/MP4 file?\n"
            f"  Tip: Run `ffprobe '{source}' -v quiet -show_streams` to verify the file is readable."
        )
        self.source = source
        self.detail = detail


class KeyframeExtractionError(CineCutError):
    def __init__(self, timestamp_s: float, detail: str) -> None:
        super().__init__(
            f"Failed to extract keyframe at {timestamp_s:.2f}s.\n"
            f"  Cause: {detail}\n"
            f"  Check: Does the proxy file exist and is it a valid video?"
        )
        self.timestamp_s = timestamp_s
        self.detail = detail


class SubtitleParseError(CineCutError):
    def __init__(self, path: Path, detail: str) -> None:
        super().__init__(
            f"Cannot parse subtitle file '{path.name}'.\n"
            f"  Cause: {detail}\n"
            f"  Check: Is the file valid SRT or ASS format?\n"
            f"  Tip: Try re-saving the file as UTF-8 in a text editor."
        )
        self.path = path
        self.detail = detail


class ProxyValidationError(CineCutError):
    def __init__(self, proxy_path: Path, detail: str) -> None:
        super().__init__(
            f"Proxy file '{proxy_path.name}' failed post-creation validation.\n"
            f"  Cause: {detail}\n"
            f"  Check: Was there sufficient disk space during encoding? Is the source file complete?"
        )
        self.proxy_path = proxy_path
        self.detail = detail
```

Note: `ProxyValidationError` is included to handle Pitfall 3 (FFmpeg exits 0 but proxy is corrupt) identified in the research. It will be raised in plan 02 after proxy creation.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.models import DialogueEvent, KeyframeRecord
from cinecut.errors import ProxyCreationError, KeyframeExtractionError, SubtitleParseError, ProxyValidationError
from pathlib import Path

# Verify model fields
de = DialogueEvent(start_ms=0, end_ms=1000, start_s=0.0, end_s=1.0, midpoint_s=0.5, text='hello', emotion='neutral')
kr = KeyframeRecord(timestamp_s=0.5, frame_path='/tmp/f.jpg', source='subtitle_midpoint')
assert de.midpoint_s == 0.5
assert kr.source == 'subtitle_midpoint'

# Verify error messages are human-readable (no raw subprocess content)
e = ProxyCreationError(Path('film.mkv'), 'permission denied')
msg = str(e)
assert 'film.mkv' in msg
assert 'permission denied' in msg
assert 'FFmpeg' in msg

print('ALL OK')
"</automated>
  </verify>
  <done>
All four error classes and two dataclasses import cleanly. `DialogueEvent` and `KeyframeRecord` have the correct fields. All three error classes produce messages containing the filename, cause, and corrective guidance.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
- `pip show cinecut` shows the installed package
- `python -c "from cinecut.models import DialogueEvent, KeyframeRecord"` succeeds
- `python -c "from cinecut.errors import ProxyCreationError, KeyframeExtractionError, SubtitleParseError"` succeeds
- `cinecut --help` resolves the entry point (will error on missing cli.py, but the script binding must resolve)
</verification>

<success_criteria>
Package is pip-installable. `cinecut.models` exports `DialogueEvent` and `KeyframeRecord` with all required fields. `cinecut.errors` exports four exception classes with human-readable multi-line messages that include filename, cause, and corrective suggestion. No business logic exists yet — only contracts.
</success_criteria>

<output>
After completion, create `.planning/phases/01-ingestion-pipeline-and-cli-shell/01-01-SUMMARY.md` following the summary template.
</output>
