---
phase: 08-zone-matching-and-non-linear-ordering
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified:
  - src/cinecut/assembly/ordering.py
  - src/cinecut/narrative/generator.py
  - tests/test_assembly.py
autonomous: true
requirements: [EORD-01, EORD-02, EORD-03]

must_haves:
  truths:
    - "Output trailer clips appear in BEGINNING → ESCALATION → CLIMAX order regardless of source timestamps"
    - "Within each zone, the clip with the highest money_shot_score appears first"
    - "CLIMAX zone clips are trimmed to act3_avg_cut_s targets (montage density) while BEGINNING clips are not trimmed"
    - "generator.py calls run_zone_matching after scoring and attaches narrative_zone to each ClipEntry before writing the manifest"
    - "title_card and button clips (narrative_zone=None) appear after all zone-assigned clips — not interleaved"
  artifacts:
    - path: "src/cinecut/assembly/ordering.py"
      provides: "sort_clips_by_zone(), enforce_zone_pacing_curve(), ZONE_ORDER dict"
      exports: ["sort_clips_by_zone", "enforce_zone_pacing_curve", "ZONE_ORDER"]
    - path: "src/cinecut/narrative/generator.py"
      provides: "run_zone_matching() invoked after scoring loop; ClipEntry constructed with narrative_zone=zones[idx]; sort_clips_by_zone used instead of chronological sort for final manifest"
      contains: "run_zone_matching"
  key_links:
    - from: "src/cinecut/narrative/generator.py run_narrative_stage"
      to: "src/cinecut/narrative/zone_matching.py run_zone_matching"
      via: "called after scoring loop, before ClipEntry construction"
      pattern: "run_zone_matching"
    - from: "src/cinecut/narrative/generator.py ClipEntry construction"
      to: "zones list from run_zone_matching"
      via: "narrative_zone=zones[idx] in ClipEntry(...) kwargs"
      pattern: "narrative_zone=zones"
    - from: "src/cinecut/assembly/ordering.py sort_clips_by_zone"
      to: "src/cinecut/manifest/schema.py NarrativeZone"
      via: "ZONE_ORDER dict mapping NarrativeZone to int priority"
      pattern: "ZONE_ORDER"
    - from: "src/cinecut/assembly/ordering.py enforce_zone_pacing_curve"
      to: "src/cinecut/manifest/schema.py NarrativeZone.CLIMAX"
      via: "c.narrative_zone == NarrativeZone.CLIMAX condition"
      pattern: "NarrativeZone\\.CLIMAX"
---

<objective>
Wire zone matching into the narrative generator and implement zone-first ordering + pacing enforcement in assembly/ordering.py — making BEGINNING → ESCALATION → CLIMAX the core ordering principle for v2.0 trailers.

Purpose: Plan 08-01 created zone_matching.py and the schema extension. This plan completes Phase 8 by: (1) adding sort_clips_by_zone and enforce_zone_pacing_curve to ordering.py, (2) wiring run_zone_matching into generator.py so clips carry narrative_zone in the manifest, and (3) making the generator use sort_clips_by_zone for final clip ordering. The existing sort_clips_by_act is preserved (backward compat) but the default ordering path becomes zone-first.

Output:
- src/cinecut/assembly/ordering.py (modified) — sort_clips_by_zone, enforce_zone_pacing_curve, ZONE_ORDER added
- src/cinecut/narrative/generator.py (modified) — run_zone_matching called post-scoring; narrative_zone set on ClipEntry; zone-first sort applied
- tests/test_assembly.py (modified) — TestSortClipsByZone and TestEnforceZonePacingCurve tests now pass
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-zone-matching-and-non-linear-ordering/08-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase or prior plan contracts. -->

From src/cinecut/assembly/ordering.py (current — to be extended):
```python
from cinecut.manifest.schema import ClipEntry, TrailerManifest
from cinecut.manifest.vibes import VibeProfile

ACT_ORDER = ["cold_open", "act1", "beat_drop", "act2", "breath", "act3"]
MIN_CLIP_DURATION_S = 0.5

def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort into canonical act order. PRESERVED — do not modify."""
    act_priority = {act: i for i, act in enumerate(ACT_ORDER)}
    return sorted(clips, key=lambda c: (act_priority.get(c.act, 999), c.source_start_s))

def compute_act_avg_duration(clips: list[ClipEntry], act: str) -> float:
    """Return mean clip duration for a specific act. PRESERVED."""
    ...

def enforce_pacing_curve(clips: list[ClipEntry], profile: VibeProfile) -> list[ClipEntry]:
    """Existing act3-based pacing enforcement. PRESERVED — do not modify."""
    ...
```

From src/cinecut/manifest/schema.py (Phase 8 Plan 01 output):
```python
class NarrativeZone(str, Enum):
    BEGINNING = "BEGINNING"
    ESCALATION = "ESCALATION"
    CLIMAX = "CLIMAX"

class ClipEntry(BaseModel):
    # ... existing fields ...
    money_shot_score: Optional[float] = Field(default=None, ge=0.0, le=1.0)
    narrative_zone: Optional[NarrativeZone] = None   # Added by 08-01
```

From src/cinecut/narrative/zone_matching.py (08-01 output):
```python
def run_zone_matching(
    clip_texts: list[str],          # dialogue_excerpt for each clip
    clip_midpoints: list[float],    # midpoint timestamps for position fallback
    film_duration_s: float,
    structural_anchors: Optional["StructuralAnchors"],  # None for v1.0 manifests
) -> list[NarrativeZone]:           # one zone per clip, same order as input
```

From src/cinecut/narrative/generator.py (current run_narrative_stage — to be modified):
```python
def run_narrative_stage(
    inference_results: list,        # list[tuple[KeyframeRecord, SceneDescription | None]]
    dialogue_events: list,          # list[DialogueEvent]
    vibe: str,
    source_file: Path,
    work_dir: Path,
    progress_callback: Callable[[int, int], None] | None = None,
    structural_anchors: Optional[StructuralAnchors] = None,  # Added by Phase 7/08-01
) -> Path:
    # ...
    # After scoring, top_scored is chronologically sorted list of dicts with keys:
    # "record", "desc", "score", "beat_type", "act", "emotion", "raw", "index"
    # Each item["record"].timestamp_s is the keyframe timestamp
    #
    # Current ClipEntry construction (to be modified to add narrative_zone):
    clip_entries.append(ClipEntry(
        source_start_s=win_start,
        source_end_s=win_end,
        beat_type=beat_type,
        act=act,
        transition=get_transition(act, vibe_profile),
        dialogue_excerpt=get_dialogue_excerpt(record.timestamp_s, dialogue_events),
        reasoning=build_reasoning(record, desc, beat_type, score),
        visual_analysis=visual_analysis,
        subtitle_analysis=subtitle_analysis,
        money_shot_score=round(score, 4),
        # ADD: narrative_zone=zones[idx]   where idx is loop index
    ))
    #
    # Current manifest assembly (to be modified to use sort_clips_by_zone):
    manifest = TrailerManifest(
        source_file=str(source_file),
        vibe=vibe,
        clips=clip_entries,           # clip_entries currently in chronological order
        structural_anchors=structural_anchors,   # Phase 7 addition
    )
```

NOTE on title_card/button: The title_card and button clips are added by assembly/title_card.py
AFTER run_narrative_stage returns. They are NOT in clip_entries at the time sort_clips_by_zone
is called inside run_narrative_stage. So sort_clips_by_zone in generator.py only sees real
narrative clips — title_card/button handling in sort_clips_by_zone is a safety guard for
if called from other contexts (e.g. tests), not needed inside generator.py's flow.

NOTE on VibeProfile.act3_avg_cut_s: action=1.2, adventure=2.0, drama=5.0, etc.
enforce_zone_pacing_curve uses profile.act3_avg_cut_s for CLIMAX zone target.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sort_clips_by_zone and enforce_zone_pacing_curve to assembly/ordering.py</name>
  <files>src/cinecut/assembly/ordering.py</files>
  <action>
Add zone-based ordering functions to ordering.py. Do NOT modify any existing functions — append only.

**Step 1 — Update imports at top of ordering.py:**

Add NarrativeZone to the schema import:
```python
from cinecut.manifest.schema import ClipEntry, NarrativeZone, TrailerManifest
```

**Step 2 — Add ZONE_ORDER constant after ACT_ORDER:**

```python
# Zone ordering priority for zone-first assembly (EORD-01).
# title_card and button clips have narrative_zone=None — they fall to priority 999.
ZONE_ORDER: dict[NarrativeZone, int] = {
    NarrativeZone.BEGINNING: 0,
    NarrativeZone.ESCALATION: 1,
    NarrativeZone.CLIMAX: 2,
}
```

**Step 3 — Add sort_clips_by_zone function after sort_clips_by_act:**

```python
def sort_clips_by_zone(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort clips into zone-first order: BEGINNING → ESCALATION → CLIMAX (EORD-01).

    Within each zone, sort by money_shot_score descending (EORD-02).
    Clips with narrative_zone=None (title_card, button, or unassigned) sort last.

    Replaces sort_clips_by_act() as the primary ordering function for v2.0 pipeline.
    sort_clips_by_act() is preserved for backward compatibility and tests.

    Zone-first ordering is the core narrative claim of v2.0:
      trailer arc = BEGINNING → ESCALATION → CLIMAX, NOT film chronology.
    """
    return sorted(
        clips,
        key=lambda c: (
            ZONE_ORDER.get(c.narrative_zone, 999) if c.narrative_zone is not None else 999,
            -(c.money_shot_score or 0.0),    # score descending within zone (negate for ascending sort)
        ),
    )
```

**Step 4 — Add enforce_zone_pacing_curve function after enforce_pacing_curve:**

```python
def enforce_zone_pacing_curve(
    clips: list[ClipEntry],
    profile: VibeProfile,
) -> list[ClipEntry]:
    """Trim CLIMAX zone clips to act3 duration targets (EORD-03).

    BEGINNING zone clips use act1_avg_cut_s — long cuts are fine for setup.
    ESCALATION zone clips use act2_avg_cut_s (enforced implicitly via clip window).
    CLIMAX zone clips are trimmed if average exceeds profile.act3_avg_cut_s * 1.5.

    Clips with narrative_zone=None are left untouched (treated as ESCALATION duration).
    Uses model_copy() (Pydantic v2) — same pattern as enforce_pacing_curve.
    Minimum clip duration: MIN_CLIP_DURATION_S (0.5s) — never trim below this.

    Does NOT modify BEGINNING zone clips — act1 targets allow longer cuts (4-8s range
    per EORD-03). Does NOT modify ESCALATION clips — act2 targets applied at window
    computation time in generator.py.
    """
    result = list(clips)

    # Compute CLIMAX zone average duration
    climax_clips = [c for c in result if c.narrative_zone == NarrativeZone.CLIMAX]
    if not climax_clips:
        return result  # No CLIMAX clips — nothing to enforce

    climax_avg = sum(c.source_end_s - c.source_start_s for c in climax_clips) / len(climax_clips)
    if climax_avg <= profile.act3_avg_cut_s * 1.5:
        return result  # Already within acceptable range

    # Trim CLIMAX clips that exceed 1.5x target
    target = profile.act3_avg_cut_s
    for i, clip in enumerate(result):
        if clip.narrative_zone == NarrativeZone.CLIMAX:
            duration = clip.source_end_s - clip.source_start_s
            if duration > target * 1.5:
                new_end = clip.source_start_s + max(target, MIN_CLIP_DURATION_S)
                result[i] = clip.model_copy(update={"source_end_s": new_end})

    return result
```
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.ordering import sort_clips_by_zone, enforce_zone_pacing_curve, ZONE_ORDER
from cinecut.manifest.schema import NarrativeZone, ClipEntry
from cinecut.manifest.vibes import VIBE_PROFILES

# ZONE_ORDER has correct priorities
assert ZONE_ORDER[NarrativeZone.BEGINNING] == 0
assert ZONE_ORDER[NarrativeZone.ESCALATION] == 1
assert ZONE_ORDER[NarrativeZone.CLIMAX] == 2

def _make_clip(zone, score, start=0.0, end=5.0):
    return ClipEntry(source_start_s=start, source_end_s=end, beat_type='escalation_beat',
                     act='act1', transition='hard_cut', money_shot_score=score, narrative_zone=zone)

# sort_clips_by_zone: BEGINNING before ESCALATION before CLIMAX
clips = [
    _make_clip(NarrativeZone.CLIMAX, 0.9, 0.0, 5.0),
    _make_clip(NarrativeZone.BEGINNING, 0.5, 0.0, 5.0),
    _make_clip(NarrativeZone.ESCALATION, 0.7, 0.0, 5.0),
]
ordered = sort_clips_by_zone(clips)
assert ordered[0].narrative_zone == NarrativeZone.BEGINNING
assert ordered[1].narrative_zone == NarrativeZone.ESCALATION
assert ordered[2].narrative_zone == NarrativeZone.CLIMAX

# Within zone: score descending
clips2 = [
    _make_clip(NarrativeZone.ESCALATION, 0.3, 0.0, 5.0),
    _make_clip(NarrativeZone.ESCALATION, 0.9, 5.0, 10.0),
]
ordered2 = sort_clips_by_zone(clips2)
assert ordered2[0].money_shot_score == 0.9, 'Highest score first within zone'

# None-zone clips sorted last
clips3 = [
    ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='title_card',
              transition='hard_cut', narrative_zone=None, money_shot_score=0.99),
    _make_clip(NarrativeZone.CLIMAX, 0.1, 5.0, 10.0),
]
ordered3 = sort_clips_by_zone(clips3)
assert ordered3[0].narrative_zone == NarrativeZone.CLIMAX, 'CLIMAX before None-zone'

# enforce_zone_pacing_curve trims CLIMAX clips
profile = VIBE_PROFILES['action']  # act3_avg_cut_s = 1.2
clips4 = [
    _make_clip(NarrativeZone.CLIMAX, 0.9, 100.0, 110.0),  # 10s -> must be trimmed
    _make_clip(NarrativeZone.BEGINNING, 0.8, 0.0, 8.0),   # 8s BEGINNING -> NOT trimmed
]
result = enforce_zone_pacing_curve(clips4, profile)
climax = next(c for c in result if c.narrative_zone == NarrativeZone.CLIMAX)
beginning = next(c for c in result if c.narrative_zone == NarrativeZone.BEGINNING)
assert (climax.source_end_s - climax.source_start_s) <= profile.act3_avg_cut_s * 1.5
assert (beginning.source_end_s - beginning.source_start_s) == 8.0, 'BEGINNING not trimmed'

print('sort_clips_by_zone and enforce_zone_pacing_curve: OK')
"</automated>
  </verify>
  <done>sort_clips_by_zone importable from cinecut.assembly.ordering; returns clips in BEGINNING → ESCALATION → CLIMAX order; within zone sorted by money_shot_score descending; None-zone clips last; enforce_zone_pacing_curve trims CLIMAX clips to act3 target while leaving BEGINNING clips untouched; existing functions unmodified</done>
</task>

<task type="auto">
  <name>Task 2: Wire run_zone_matching into generator.py and apply zone-first ordering</name>
  <files>src/cinecut/narrative/generator.py</files>
  <action>
Modify narrative/generator.py to invoke zone matching after scoring and use zone-first ordering for the manifest.

**Step 1 — Add imports:**

At the top of generator.py, add:
```python
from cinecut.narrative.zone_matching import run_zone_matching
from cinecut.assembly.ordering import sort_clips_by_zone, enforce_zone_pacing_curve
```

**Step 2 — Compute zones after the scoring loop:**

In run_narrative_stage, after the block that produces `top_scored` (sorted chronologically) and computes/resolves `windows`, add the zone matching call BEFORE the ClipEntry construction loop:

```python
# --- Zone matching: assign BEGINNING/ESCALATION/CLIMAX to each clip (STRC-02) ---
# Batch-encode all clip texts in one call — model loaded at most once via lru_cache.
# clip_texts and clip_midpoints are in the same order as top_scored/windows.
clip_texts = [
    get_dialogue_excerpt(item["record"].timestamp_s, dialogue_events)
    for item in top_scored
]
clip_midpoints = [
    (win_start + win_end) / 2.0
    for win_start, win_end in windows
]
zones = run_zone_matching(
    clip_texts=clip_texts,
    clip_midpoints=clip_midpoints,
    film_duration_s=film_duration_s,
    structural_anchors=structural_anchors,  # Optional; None for v1.0 manifests
)
```

Place this block immediately before the `clip_entries: list[ClipEntry] = []` line.

**Step 3 — Add narrative_zone to ClipEntry construction:**

In the ClipEntry construction loop, find the `clip_entries.append(ClipEntry(...))` call. The loop variable enumerating `zip(top_scored, windows)` must expose an index. Change the loop structure to track the index:

```python
clip_entries: list[ClipEntry] = []
for idx, (item, (win_start, win_end)) in enumerate(zip(top_scored, windows)):
    # Skip degenerate windows (end <= start from resolve_overlaps)
    if win_end <= win_start:
        continue

    record = item["record"]
    desc = item["desc"]
    beat_type = item["beat_type"]
    act = item["act"]
    score = item["score"]
    emotion = item["emotion"]
    raw = item["raw"]

    # Build optional analysis fields
    visual_analysis = (
        f"{desc.visual_content}. {desc.mood}. {desc.action}. {desc.setting}."
        if desc is not None
        else None
    )
    subtitle_analysis = (
        f"Emotion: {emotion}. Weight: {raw.subtitle_emotional_weight:.2f}."
        if emotion != "neutral"
        else None
    )

    clip_entries.append(ClipEntry(
        source_start_s=win_start,
        source_end_s=win_end,
        beat_type=beat_type,
        act=act,
        transition=get_transition(act, vibe_profile),
        dialogue_excerpt=get_dialogue_excerpt(record.timestamp_s, dialogue_events),
        reasoning=build_reasoning(record, desc, beat_type, score),
        visual_analysis=visual_analysis,
        subtitle_analysis=subtitle_analysis,
        money_shot_score=round(score, 4),
        narrative_zone=zones[idx],   # STRC-02: attach zone assignment
    ))
```

NOTE: The `idx` variable tracks position in `top_scored`/`windows` — it is the index into the `zones` list returned by `run_zone_matching`. Degenerate windows (skipped via `continue`) do not consume a zone entry because `zip(top_scored, windows)` and `zones` are all parallel arrays at the same length; but since degenerate windows are skipped before appending to `clip_entries`, `zones[idx]` still gives the correct zone for the idx-th window. This is safe.

**Step 4 — Apply zone-first ordering to clip_entries before manifest assembly:**

Replace the existing manifest assembly block. Currently:
```python
manifest = TrailerManifest(
    source_file=str(source_file),
    vibe=vibe,
    clips=clip_entries,
    structural_anchors=structural_anchors,
)
```

Change to apply zone-first sort and pacing enforcement first:
```python
# Apply zone-first ordering and pacing enforcement (EORD-01, EORD-02, EORD-03)
ordered_clips = sort_clips_by_zone(clip_entries)
ordered_clips = enforce_zone_pacing_curve(ordered_clips, vibe_profile)

manifest = TrailerManifest(
    source_file=str(source_file),
    vibe=vibe,
    clips=ordered_clips,
    structural_anchors=structural_anchors,
)
```

The `ordered_clips` list is now in BEGINNING → ESCALATION → CLIMAX order, with CLIMAX clips trimmed to act3 duration targets.

**Do NOT remove or modify any other existing logic** in generator.py. The chronological top_scored sort before zone matching is still needed — it is used for window computation (resolve_overlaps requires chronological order). Zone matching and zone-first ordering happen AFTER windows are resolved.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
import inspect
from cinecut.narrative.generator import run_narrative_stage
src = inspect.getsource(run_narrative_stage)

# Verify zone matching is wired in
assert 'run_zone_matching' in src, 'run_zone_matching not called in run_narrative_stage'
assert 'narrative_zone=zones' in src, 'narrative_zone=zones not in ClipEntry construction'
assert 'sort_clips_by_zone' in src, 'sort_clips_by_zone not called'
assert 'enforce_zone_pacing_curve' in src, 'enforce_zone_pacing_curve not called'

# Verify imports
from cinecut.narrative.zone_matching import run_zone_matching
from cinecut.assembly.ordering import sort_clips_by_zone, enforce_zone_pacing_curve

# Full import chain check
import cinecut.narrative.generator
print('generator.py wiring verification: OK')
print('run_zone_matching present:', 'run_zone_matching' in src)
print('zone-first ordering present:', 'sort_clips_by_zone' in src)
"</automated>
  </verify>
  <done>generator.py imports run_zone_matching, sort_clips_by_zone, enforce_zone_pacing_curve; zones computed after scoring loop using clip_texts and clip_midpoints; each ClipEntry constructed with narrative_zone=zones[idx]; manifest assembled from sort_clips_by_zone(clip_entries) then enforce_zone_pacing_curve output; existing logic unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Confirm zone ordering tests now pass and run full test suite</name>
  <files>tests/test_assembly.py</files>
  <action>
With ordering.py functions now implemented, the TestSortClipsByZone and TestEnforceZonePacingCurve test classes added in 08-01 should now pass. Verify they do by running the test suite.

If any tests in TestSortClipsByZone or TestEnforceZonePacingCurve fail due to minor implementation mismatches (e.g., the helper function signature or import path), fix the test file to match the actual implementation. Do NOT change the test behavior/intent — only fix import paths or minor fixture issues.

Expected test structure (from 08-01 plan — verify these test classes exist and pass):

**TestSortClipsByZone** (should now import sort_clips_by_zone from cinecut.assembly.ordering):
- test_zone_order_beginning_before_escalation_before_climax
- test_within_zone_score_descending
- test_clips_without_zone_sorted_last
- test_title_card_and_button_sorted_last
- test_empty_input_returns_empty

**TestEnforceZonePacingCurve** (should now import enforce_zone_pacing_curve from cinecut.assembly.ordering):
- test_climax_clips_trimmed_to_act3_target
- test_beginning_clips_not_trimmed
- test_never_below_min_duration
- test_no_trimming_when_within_threshold

Run the full test suite and confirm green:
```bash
cd /home/adamh/ai-video-trailer && pytest tests/ -x -q
```

If the generator.py changes cause any existing test_narrative.py tests to fail (because they call run_narrative_stage and don't provide structural_anchors or because zone matching fails on empty inputs), investigate and fix by ensuring:
1. run_zone_matching handles empty clip_texts gracefully (all-empty returns position-based zones)
2. structural_anchors=None is handled correctly in run_zone_matching (falls back to 33%/66% split)

Both of these are guaranteed by the zone_matching.py implementation from 08-01. If test_narrative.py tests call run_narrative_stage without mocking sentence-transformers, they should still pass because empty dialogue text triggers the position-based fallback (no model load required).
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && pytest tests/test_assembly.py -v -q && pytest tests/ -x -q</automated>
  </verify>
  <done>All TestSortClipsByZone and TestEnforceZonePacingCurve tests pass; full test suite passes with no regressions; pytest tests/ -x -q exits 0</done>
</task>

</tasks>

<verification>
End-to-end zone ordering verification (no live model or film required):

```bash
cd /home/adamh/ai-video-trailer && python -c "
from cinecut.manifest.schema import NarrativeZone, ClipEntry
from cinecut.assembly.ordering import sort_clips_by_zone, enforce_zone_pacing_curve, ZONE_ORDER
from cinecut.manifest.vibes import VIBE_PROFILES
import json

def make_clip(zone, score, start, end, act='act1'):
    return ClipEntry(source_start_s=start, source_end_s=end,
                     beat_type='escalation_beat', act=act, transition='hard_cut',
                     money_shot_score=score, narrative_zone=zone)

# Simulate a pool of clips in film-chronological order (v2.0 should reorder these)
chron_clips = [
    make_clip(NarrativeZone.ESCALATION, 0.6, 600.0, 603.0),   # early escalation
    make_clip(NarrativeZone.BEGINNING,  0.5, 200.0, 204.0),   # late beginning
    make_clip(NarrativeZone.CLIMAX,     0.9, 5000.0, 5005.0), # climax
    make_clip(NarrativeZone.BEGINNING,  0.8, 50.0, 54.0),     # early beginning (high score)
    make_clip(NarrativeZone.ESCALATION, 0.3, 2400.0, 2402.0), # mid escalation (low score)
    make_clip(NarrativeZone.CLIMAX,     0.7, 4500.0, 4510.0), # climax (long clip)
]

ordered = sort_clips_by_zone(chron_clips)

# EORD-01: Zone order must be BEGINNING, BEGINNING, ESCALATION, ESCALATION, CLIMAX, CLIMAX
zones_in_order = [c.narrative_zone for c in ordered]
assert zones_in_order == [
    NarrativeZone.BEGINNING,
    NarrativeZone.BEGINNING,
    NarrativeZone.ESCALATION,
    NarrativeZone.ESCALATION,
    NarrativeZone.CLIMAX,
    NarrativeZone.CLIMAX,
], f'Zone order wrong: {zones_in_order}'

# EORD-02: Within BEGINNING, higher score (0.8) comes before lower score (0.5)
beginning_clips = [c for c in ordered if c.narrative_zone == NarrativeZone.BEGINNING]
assert beginning_clips[0].money_shot_score == 0.8, 'BEGINNING: highest score first'

# EORD-02: Within ESCALATION, higher score (0.6) comes before lower (0.3)
esc_clips = [c for c in ordered if c.narrative_zone == NarrativeZone.ESCALATION]
assert esc_clips[0].money_shot_score == 0.6, 'ESCALATION: highest score first'

# EORD-03: enforce_zone_pacing_curve trims CLIMAX clips
profile = VIBE_PROFILES['action']  # act3_avg_cut_s = 1.2
trimmed = enforce_zone_pacing_curve(ordered, profile)
climax_clips = [c for c in trimmed if c.narrative_zone == NarrativeZone.CLIMAX]
climax_avg = sum(c.source_end_s - c.source_start_s for c in climax_clips) / len(climax_clips)
beginning_clips_after = [c for c in trimmed if c.narrative_zone == NarrativeZone.BEGINNING]
beginning_avg = sum(c.source_end_s - c.source_start_s for c in beginning_clips_after) / len(beginning_clips_after)

assert climax_avg <= profile.act3_avg_cut_s * 1.5, f'CLIMAX avg too long: {climax_avg:.2f}s'
assert beginning_avg > profile.act3_avg_cut_s, 'BEGINNING should be longer than CLIMAX target'
print(f'BEGINNING avg: {beginning_avg:.2f}s, CLIMAX avg: {climax_avg:.2f}s')
print('EORD-01/02/03 verification: OK')
"
```

Generator wiring check:
```bash
cd /home/adamh/ai-video-trailer && python -c "
import inspect
from cinecut.narrative.generator import run_narrative_stage
src = inspect.getsource(run_narrative_stage)
for symbol in ['run_zone_matching', 'narrative_zone=zones', 'sort_clips_by_zone', 'enforce_zone_pacing_curve']:
    assert symbol in src, f'Missing: {symbol}'
    print(f'  {symbol}: present')
print('Generator wiring: OK')
"
```

Full test suite:
```bash
cd /home/adamh/ai-video-trailer && pytest tests/ -x -q
```
</verification>

<success_criteria>
- assembly/ordering.py: ZONE_ORDER dict; sort_clips_by_zone() with BEGINNING → ESCALATION → CLIMAX order and score-descending within zone; enforce_zone_pacing_curve() trimming CLIMAX clips to act3 target while leaving BEGINNING untouched; all existing functions preserved
- narrative/generator.py: run_zone_matching called after scoring loop; zones[] computed with clip_texts and clip_midpoints; ClipEntry construction includes narrative_zone=zones[idx]; manifest assembled from sort_clips_by_zone + enforce_zone_pacing_curve output
- tests/test_assembly.py: TestSortClipsByZone and TestEnforceZonePacingCurve all pass
- Full test suite green: pytest tests/ -x -q exits 0
- TRAILER_MANIFEST.json clips appear in BEGINNING → ESCALATION → CLIMAX order (verifiable by inspecting output JSON from any pipeline run)
- CLIMAX clips average ≤ act3_avg_cut_s * 1.5 per vibe profile (verified in test suite)
</success_criteria>

<output>
After completion, create `.planning/phases/08-zone-matching-and-non-linear-ordering/08-02-SUMMARY.md`
</output>
