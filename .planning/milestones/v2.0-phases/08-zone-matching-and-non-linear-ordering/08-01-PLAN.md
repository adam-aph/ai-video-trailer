---
phase: 08-zone-matching-and-non-linear-ordering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cinecut/manifest/schema.py
  - src/cinecut/narrative/zone_matching.py
  - tests/test_zone_matching.py
  - tests/test_assembly.py
autonomous: true
requirements: [STRC-02]

must_haves:
  truths:
    - "Each clip entry in the manifest carries a narrative_zone field (BEGINNING, ESCALATION, or CLIMAX)"
    - "Clips with dialogue text are zone-assigned by semantic cosine similarity using all-MiniLM-L6-v2 CPU model"
    - "Clips with empty dialogue fall back to position-based zone assignment using structural_anchors timestamps when available"
    - "The sentence-transformers model is loaded at most once per process via lru_cache singleton — not per clip"
    - "Old v1.0 manifests (without narrative_zone field) load without validation error"
  artifacts:
    - path: "src/cinecut/narrative/zone_matching.py"
      provides: "NarrativeZone enum (reexported from schema), run_zone_matching(), assign_narrative_zone(), _load_model(), ZONE_ANCHORS"
      exports: ["run_zone_matching", "assign_narrative_zone", "ZONE_ANCHORS"]
    - path: "src/cinecut/manifest/schema.py"
      provides: "NarrativeZone str enum, ClipEntry.narrative_zone Optional field"
      contains: "class NarrativeZone"
    - path: "tests/test_zone_matching.py"
      provides: "Unit tests for zone_matching.py (no live model required — mocked)"
      min_lines: 60
    - path: "tests/test_assembly.py"
      provides: "TestSortClipsByZone and TestEnforceZonePacingCurve classes appended (existing tests preserved)"
      contains: "TestSortClipsByZone"
  key_links:
    - from: "src/cinecut/narrative/zone_matching.py run_zone_matching"
      to: "sentence_transformers.SentenceTransformer"
      via: "_load_model() singleton with device='cpu'"
      pattern: "lru_cache"
    - from: "src/cinecut/narrative/zone_matching.py assign_narrative_zone"
      to: "src/cinecut/manifest/schema.py NarrativeZone"
      via: "from cinecut.manifest.schema import NarrativeZone, StructuralAnchors"
      pattern: "NarrativeZone\\.BEGINNING|ESCALATION|CLIMAX"
    - from: "src/cinecut/manifest/schema.py ClipEntry"
      to: "NarrativeZone"
      via: "narrative_zone: Optional[NarrativeZone] = None"
      pattern: "narrative_zone"
---

<objective>
Create the zone matching module (narrative/zone_matching.py) and extend the schema with NarrativeZone — the foundation for all zone-based ordering in Phase 8.

Purpose: STRC-02 requires each clip to carry a narrative_zone assignment (BEGINNING, ESCALATION, or CLIMAX). This plan creates the assignment logic and schema extension. Plan 08-02 wires it into the generator and ordering pipeline.

Output:
- src/cinecut/narrative/zone_matching.py (new) — sentence-transformers CPU cosine similarity zone assignment
- src/cinecut/manifest/schema.py (modified) — NarrativeZone enum + ClipEntry.narrative_zone Optional field
- tests/test_zone_matching.py (new) — unit tests with mocked model
- tests/test_assembly.py (modified) — zone-based ordering test classes appended
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/cinecut/manifest/schema.py (current state — to be extended):
```python
from typing import Literal, Optional
from pydantic import BaseModel, Field, field_validator, model_validator

class ClipEntry(BaseModel):
    source_start_s: float = Field(ge=0.0)
    source_end_s: float = Field(ge=0.0)
    beat_type: Literal["inciting_incident", "character_introduction", "escalation_beat",
                       "relationship_beat", "money_shot", "climax_peak", "breath"]
    act: Literal["cold_open", "act1", "beat_drop", "act2", "breath", "act3", "title_card", "button"]
    transition: Literal["hard_cut", "crossfade", "fade_to_black", "fade_to_white"] = "hard_cut"
    dialogue_excerpt: str = ""
    reasoning: Optional[str] = None
    visual_analysis: Optional[str] = None
    subtitle_analysis: Optional[str] = None
    money_shot_score: Optional[float] = Field(default=None, ge=0.0, le=1.0)

class TrailerManifest(BaseModel):
    schema_version: str = "1.0"   # Phase 7 will bump to "2.0" — keep as str
    source_file: str
    vibe: str
    clips: list[ClipEntry] = Field(min_length=1)
    # Phase 7 adds: structural_anchors: Optional[StructuralAnchors] = None
```

NOTE: Phase 7 (07-02-PLAN.md) adds StructuralAnchors to schema.py and bumps schema_version to "2.0".
Phase 8 adds NarrativeZone and ClipEntry.narrative_zone. Both are backward-compatible additions.

From src/cinecut/assembly/ordering.py (current state — zone ordering to be added in 08-02):
```python
MIN_CLIP_DURATION_S = 0.5

def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Existing act-based sort — NOT replaced, kept for backward compat."""
    act_priority = {act: i for i, act in enumerate(ACT_ORDER)}
    return sorted(clips, key=lambda c: (act_priority.get(c.act, 999), c.source_start_s))

def enforce_pacing_curve(clips: list[ClipEntry], profile: VibeProfile) -> list[ClipEntry]:
    """Existing act3-based trimming — NOT replaced, extended in 08-02."""
    ...
```

From src/cinecut/manifest/vibes.py (VibeProfile fields needed for pacing tests):
```python
@dataclass(frozen=True)
class VibeProfile:
    act1_avg_cut_s: float   # e.g. action=4.0
    act2_avg_cut_s: float   # e.g. action=2.5
    act3_avg_cut_s: float   # e.g. action=1.2

# Action profile: act1_avg_cut_s=4.0, act2_avg_cut_s=2.5, act3_avg_cut_s=1.2
```

Phase 7 contract (07-02-PLAN.md output — StructuralAnchors that zone_matching.py will accept):
```python
class StructuralAnchors(BaseModel):
    begin_t: float = Field(ge=0.0)
    escalation_t: float = Field(ge=0.0)
    climax_t: float = Field(ge=0.0)
    source: str = "llm"  # "llm" | "heuristic"
```
zone_matching.py must import StructuralAnchors from cinecut.manifest.schema (added by Phase 7).
If Phase 7 has not run yet, use TYPE_CHECKING guard for the import.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add NarrativeZone enum and ClipEntry.narrative_zone to manifest/schema.py</name>
  <files>src/cinecut/manifest/schema.py</files>
  <action>
Add the NarrativeZone str enum and extend ClipEntry with the narrative_zone Optional field.

**Step 1 — Add NarrativeZone enum BEFORE ClipEntry:**

Insert after the `_VIBE_ALIASES` dict and before `class ClipEntry`:

```python
class NarrativeZone(str, Enum):
    """Narrative zone assigned by sentence-transformers zone matching (STRC-02).

    str, Enum ensures Pydantic v2 serializes as plain string ("BEGINNING" not {"value":"BEGINNING"}).
    """
    BEGINNING = "BEGINNING"
    ESCALATION = "ESCALATION"
    CLIMAX = "CLIMAX"
```

Add `from enum import Enum` to the imports at the top of schema.py (alongside the existing `from typing import Literal, Optional`).

**Step 2 — Add narrative_zone field to ClipEntry:**

In ClipEntry, after the `money_shot_score` field, add:

```python
# Phase 8: zone-based ordering (STRC-02)
narrative_zone: Optional[NarrativeZone] = None
```

The `= None` default is CRITICAL for backward compatibility — existing manifests without this field load without ValidationError.

**Do NOT change** TrailerManifest.schema_version or structural_anchors — those are Phase 7 additions.
Do NOT remove any existing fields from ClipEntry.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.manifest.schema import NarrativeZone, ClipEntry
import json

# NarrativeZone is a str enum
assert NarrativeZone.BEGINNING == 'BEGINNING'
assert NarrativeZone.ESCALATION == 'ESCALATION'
assert NarrativeZone.CLIMAX == 'CLIMAX'

# ClipEntry accepts narrative_zone
ce = ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='act1', narrative_zone=NarrativeZone.CLIMAX)
assert ce.narrative_zone == NarrativeZone.CLIMAX

# Serializes as plain string
j = json.loads(ce.model_dump_json())
assert j['narrative_zone'] == 'CLIMAX', f'Expected string CLIMAX, got {j[\"narrative_zone\"]}'

# Default is None (backward compat)
ce_none = ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='act1')
assert ce_none.narrative_zone is None

# exclude_none=True omits None narrative_zone (backward compat)
j_none = json.loads(ce_none.model_dump_json(exclude_none=True))
assert 'narrative_zone' not in j_none, 'narrative_zone should be absent when None'

print('NarrativeZone and ClipEntry.narrative_zone: OK')
"</automated>
  </verify>
  <done>NarrativeZone importable from cinecut.manifest.schema; ClipEntry.narrative_zone Optional field defaults None; serializes to "BEGINNING"/"ESCALATION"/"CLIMAX" string in JSON; old manifests load without error</done>
</task>

<task type="auto">
  <name>Task 2: Create narrative/zone_matching.py with CPU sentence-transformers zone assignment</name>
  <files>src/cinecut/narrative/zone_matching.py</files>
  <action>
Create src/cinecut/narrative/zone_matching.py implementing zone assignment via all-MiniLM-L6-v2 cosine similarity.

**CRITICAL installation order (must be in pyproject.toml — check if torch/sentence-transformers already added by Phase 7; if not, add):**
Add to pyproject.toml dependencies if not already present:
```toml
"torch>=2.0",
"sentence-transformers>=3.0",
```
If torch is already in pyproject.toml, do not add it again.

**Full module content:**

```python
"""Zone matching: assign each clip to BEGINNING, ESCALATION, or CLIMAX.

Uses sentence-transformers all-MiniLM-L6-v2 (CPU-only, 22.7M params, 384-dim)
with cosine similarity against static zone anchor phrases.

CPU-only is mandatory: CUDA 11.4 on Quadro K6000 is incompatible with modern
PyTorch CUDA wheels. Install order: pip install torch --index-url
https://download.pytorch.org/whl/cpu && pip install sentence-transformers

Anti-patterns avoided:
  - Model NOT loaded per clip (uses lru_cache singleton — ~200ms load cost)
  - CUDA device NOT used (explicit device='cpu')
  - Empty strings NOT embedded (position fallback instead)
  - util.cos_sim() returns Tensor — always call .numpy() before np.argmax()
"""
from __future__ import annotations

import numpy as np
from functools import lru_cache
from typing import TYPE_CHECKING, Optional

from cinecut.manifest.schema import NarrativeZone

if TYPE_CHECKING:
    from cinecut.manifest.schema import StructuralAnchors
    from sentence_transformers import SentenceTransformer

MODEL_NAME = "all-MiniLM-L6-v2"

# Static zone anchor phrases. Represent the semantic character of each zone.
# These are stable across films — no subtitle corpus re-reading required.
ZONE_ANCHORS: dict[NarrativeZone, str] = {
    NarrativeZone.BEGINNING: (
        "introduction setup ordinary world character establishment calm before the storm"
    ),
    NarrativeZone.ESCALATION: (
        "rising tension conflict confrontation danger intensifying stakes escalating pressure"
    ),
    NarrativeZone.CLIMAX: (
        "peak crisis final battle decisive moment maximum intensity explosive showdown climax"
    ),
}


@lru_cache(maxsize=1)
def _load_model() -> "SentenceTransformer":
    """Load and cache all-MiniLM-L6-v2 CPU model (loaded at most once per process).

    lru_cache with no arguments means the function is called once on first use
    and the result is returned on all subsequent calls. This avoids the ~200ms
    model loading cost being incurred per clip (30 clips = 6s overhead otherwise).

    Raises RuntimeError if sentence_transformers is not installed or if the
    model cannot be downloaded (offline environment without cached model).
    """
    try:
        from sentence_transformers import SentenceTransformer
    except ImportError as e:
        raise RuntimeError(
            "sentence-transformers not installed. Run: "
            "pip install torch --index-url https://download.pytorch.org/whl/cpu "
            "&& pip install sentence-transformers"
        ) from e
    return SentenceTransformer(MODEL_NAME, device="cpu")


def _zone_by_position(
    midpoint_s: float,
    film_duration_s: float,
    anchors: "Optional[StructuralAnchors]",
) -> NarrativeZone:
    """Assign zone by timestamp position relative to structural anchors.

    Uses anchors.escalation_t and anchors.climax_t when available.
    Falls back to 33%/66% split when anchors is None.
    This fallback handles: empty dialogue excerpt, absent structural_anchors (v1.0 manifest).
    """
    if anchors is not None:
        if midpoint_s < anchors.escalation_t:
            return NarrativeZone.BEGINNING
        elif midpoint_s < anchors.climax_t:
            return NarrativeZone.ESCALATION
        else:
            return NarrativeZone.CLIMAX
    # Hard fallback: no anchors at all
    pos = midpoint_s / max(film_duration_s, 1.0)
    if pos < 0.33:
        return NarrativeZone.BEGINNING
    elif pos < 0.67:
        return NarrativeZone.ESCALATION
    else:
        return NarrativeZone.CLIMAX


def assign_narrative_zone(
    dialogue_text: str,
    structural_anchors: "Optional[StructuralAnchors]",
    clip_midpoint_s: float,
    film_duration_s: float,
) -> NarrativeZone:
    """Assign a single clip to BEGINNING, ESCALATION, or CLIMAX.

    If dialogue_text is empty (silent shot) or structural_anchors is None:
        Uses position-based fallback via _zone_by_position().

    Otherwise:
        Embeds dialogue_text with all-MiniLM-L6-v2, computes cosine similarity
        against ZONE_ANCHORS phrases, returns highest-scoring zone.

    normalize_embeddings=True: L2-normalized embeddings make cosine similarity
    equivalent to dot product — faster and recommended by sbert.net docs.
    """
    if not dialogue_text.strip():
        return _zone_by_position(clip_midpoint_s, film_duration_s, structural_anchors)

    model = _load_model()
    zone_keys = list(ZONE_ANCHORS.keys())
    zone_texts = list(ZONE_ANCHORS.values())

    text_emb = model.encode([dialogue_text], normalize_embeddings=True)      # shape: (1, 384)
    anchor_embs = model.encode(zone_texts, normalize_embeddings=True)        # shape: (3, 384)

    from sentence_transformers import util
    sims = util.cos_sim(text_emb, anchor_embs)[0]  # Tensor shape: (3,)
    # CRITICAL: util.cos_sim returns torch.Tensor — must call .numpy() for np.argmax
    best_idx = int(np.argmax(sims.numpy()))
    return zone_keys[best_idx]


def run_zone_matching(
    clip_texts: list[str],
    clip_midpoints: list[float],
    film_duration_s: float,
    structural_anchors: "Optional[StructuralAnchors]",
) -> list[NarrativeZone]:
    """Assign narrative zones to all clips, called once per pipeline run.

    Encodes anchor phrases once, then processes each clip text.
    Clips with empty text use position-based fallback (no model encode call).

    Args:
        clip_texts: dialogue_excerpt for each clip (empty string if no dialogue)
        clip_midpoints: midpoint timestamp (seconds) for each clip (for fallback)
        film_duration_s: total film duration (for position-based fallback)
        structural_anchors: StructuralAnchors from manifest (None for v1.0 manifests)

    Returns:
        list of NarrativeZone, one per clip, in same order as clip_texts
    """
    zones: list[NarrativeZone] = []
    zone_keys = list(ZONE_ANCHORS.keys())
    zone_texts = list(ZONE_ANCHORS.values())

    # Pre-encode anchor phrases once for all clips (3ms total vs per-clip overhead)
    # Only load model if any clips have dialogue text
    has_text = any(t.strip() for t in clip_texts)
    anchor_embs = None
    if has_text:
        model = _load_model()
        anchor_embs = model.encode(zone_texts, normalize_embeddings=True)  # shape: (3, 384)

    for text, midpoint in zip(clip_texts, clip_midpoints):
        if not text.strip() or anchor_embs is None:
            zones.append(_zone_by_position(midpoint, film_duration_s, structural_anchors))
            continue

        text_emb = model.encode([text], normalize_embeddings=True)   # shape: (1, 384)
        from sentence_transformers import util
        sims = util.cos_sim(text_emb, anchor_embs)[0]                # Tensor shape: (3,)
        best_idx = int(np.argmax(sims.numpy()))
        zones.append(zone_keys[best_idx])

    return zones
```

After writing the file, verify the module imports cleanly WITHOUT triggering model download:

```python
# This import should succeed without loading the model (lru_cache is lazy)
from cinecut.narrative.zone_matching import run_zone_matching, assign_narrative_zone, ZONE_ANCHORS
```

Also add sentence-transformers and torch to pyproject.toml if not already present. Read pyproject.toml first to check current dependencies before adding.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.narrative.zone_matching import run_zone_matching, assign_narrative_zone, ZONE_ANCHORS, _zone_by_position
from cinecut.manifest.schema import NarrativeZone

# ZONE_ANCHORS has all three zones
assert NarrativeZone.BEGINNING in ZONE_ANCHORS
assert NarrativeZone.ESCALATION in ZONE_ANCHORS
assert NarrativeZone.CLIMAX in ZONE_ANCHORS

# Position fallback works without structural_anchors
z = _zone_by_position(100.0, 5400.0, None)  # 100s / 5400s = 1.85% -> BEGINNING
assert z == NarrativeZone.BEGINNING, f'Expected BEGINNING, got {z}'

z2 = _zone_by_position(4000.0, 5400.0, None)  # 74% -> CLIMAX
assert z2 == NarrativeZone.CLIMAX, f'Expected CLIMAX, got {z2}'

# Empty dialogue uses position fallback (no model load)
z3 = assign_narrative_zone('', None, 100.0, 5400.0)
assert z3 == NarrativeZone.BEGINNING

# run_zone_matching with all-empty texts uses position fallback (no model load)
zones = run_zone_matching(['', '', ''], [100.0, 3000.0, 5000.0], 5400.0, None)
assert zones[0] == NarrativeZone.BEGINNING
assert zones[1] == NarrativeZone.ESCALATION
assert zones[2] == NarrativeZone.CLIMAX

print('zone_matching.py: fallback logic OK (no model download required)')
"</automated>
  </verify>
  <done>zone_matching.py importable; ZONE_ANCHORS dict populated; _zone_by_position correctly assigns zones by position fraction; assign_narrative_zone returns position-based zone for empty text; run_zone_matching returns one zone per input clip; all without requiring model download</done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for zone_matching.py and append zone ordering tests to test_assembly.py</name>
  <files>
    tests/test_zone_matching.py
    tests/test_assembly.py
  </files>
  <action>
**Part A — Create tests/test_zone_matching.py:**

These tests MUST NOT require a live model download. Use unittest.mock.patch to mock _load_model and the sentence_transformers util.

```python
"""Unit tests for narrative/zone_matching.py (STRC-02).

Tests use mocked sentence-transformers model — no model download required.
"""
import numpy as np
import pytest
from unittest.mock import MagicMock, patch
from cinecut.narrative.zone_matching import (
    assign_narrative_zone,
    run_zone_matching,
    _zone_by_position,
    ZONE_ANCHORS,
)
from cinecut.manifest.schema import NarrativeZone
```

Implement these test cases:

1. **test_zone_anchors_has_all_three_zones** — assert all three NarrativeZone values are keys in ZONE_ANCHORS

2. **test_zone_by_position_beginning_no_anchors** — _zone_by_position(100.0, 5400.0, None) returns BEGINNING (1.85% < 33%)

3. **test_zone_by_position_escalation_no_anchors** — _zone_by_position(2500.0, 5400.0, None) returns ESCALATION (46% > 33%, < 67%)

4. **test_zone_by_position_climax_no_anchors** — _zone_by_position(4500.0, 5400.0, None) returns CLIMAX (83% > 67%)

5. **test_zone_by_position_with_structural_anchors** — create a mock StructuralAnchors with begin_t=180, escalation_t=1800, climax_t=3600; test that midpoint=1000 returns BEGINNING (< escalation_t=1800), midpoint=2500 returns ESCALATION, midpoint=4000 returns CLIMAX

6. **test_empty_dialogue_uses_position_fallback** — assign_narrative_zone("", None, 100.0, 5400.0) returns BEGINNING; does NOT call _load_model (patch _load_model to raise if called)

7. **test_whitespace_dialogue_uses_position_fallback** — assign_narrative_zone("   ", None, 100.0, 5400.0) returns BEGINNING without calling model

8. **test_semantic_assignment_climax** — patch _load_model to return a mock model; mock model.encode to return pre-computed embeddings such that the climax anchor wins. Set up: text_emb has high cosine similarity to climax anchor. Simplest approach: patch util.cos_sim to return a tensor-like mock where [0] returns a mock with .numpy() returning np.array([0.1, 0.2, 0.9]) (climax wins). Verify assign_narrative_zone("I will destroy you", None, 100.0, 5400.0) returns CLIMAX.

9. **test_run_zone_matching_all_empty_no_model_load** — run_zone_matching(["", "", ""], [100.0, 3000.0, 5000.0], 5400.0, None) returns [BEGINNING, ESCALATION, CLIMAX]; patch _load_model to MagicMock that raises AssertionError if called (model must NOT be loaded for all-empty input)

10. **test_run_zone_matching_length_matches_input** — with mocked model, verify len(result) == len(clip_texts) for a 5-element input

11. **test_run_zone_matching_returns_narrative_zone_enum** — verify all returned values are instances of NarrativeZone

For mock setup pattern (tests 8, 10, 11):
```python
mock_model = MagicMock()
# model.encode returns a numpy array (384-dim)
mock_model.encode.return_value = np.zeros((1, 384))
# util.cos_sim returns Tensor-like with [0] that has .numpy()
mock_sims = MagicMock()
mock_sims.numpy.return_value = np.array([0.1, 0.2, 0.9])  # climax wins
mock_cos_result = MagicMock()
mock_cos_result.__getitem__ = lambda self, idx: mock_sims
```

Use `@patch("cinecut.narrative.zone_matching._load_model", return_value=mock_model)` and
`@patch("cinecut.narrative.zone_matching.util", ...)` or patch inside the test.

**Part B — Append to tests/test_assembly.py (do NOT modify existing tests):**

Read the existing test_assembly.py file first, then APPEND these two new test classes at the end.

```python
# ============================================================
# Phase 8 zone ordering tests (EORD-01, EORD-02, EORD-03)
# ============================================================
```

**Class TestSortClipsByZone:**

```python
class TestSortClipsByZone:
    """EORD-01 and EORD-02: sort_clips_by_zone() — zone-first, score-descending within zone."""
```

The class imports and calls `sort_clips_by_zone` from `cinecut.assembly.ordering`.
NOTE: sort_clips_by_zone is implemented in Plan 08-02. Write the test class now using forward-compatible imports that will fail with ImportError until 08-02 is executed. Tests in this class should be decorated with pytest.importorskip or wrapped in try/except to skip if the function is not yet available, OR just write them normally and accept that they will FAIL until 08-02 completes (which is fine — they are Wave 0 tests for 08-02).

Actually — write the tests normally without skip guards. They will fail until 08-02 is done, which is expected (part of the Wave 0 pattern). The full test suite gate is at phase end, not plan end.

Test cases to add to TestSortClipsByZone:

- **test_zone_order_beginning_before_escalation_before_climax**: Create clips with BEGINNING, CLIMAX, ESCALATION zones (out of order). Verify sort_clips_by_zone returns them in BEGINNING, ESCALATION, CLIMAX order.

- **test_within_zone_score_descending**: Two ESCALATION clips with money_shot_score 0.9 and 0.3. Verify 0.9 comes first.

- **test_clips_without_zone_sorted_last**: Create a clip with narrative_zone=None alongside BEGINNING and CLIMAX clips. Verify the None-zone clip appears after all zone-assigned clips.

- **test_title_card_and_button_sorted_last**: Create clips with act="title_card" and act="button" and narrative_zone=None. Verify they appear after all zone-assigned clips.

- **test_empty_input_returns_empty**: sort_clips_by_zone([]) returns []

Helper function:
```python
def _make_zone_clip(zone: Optional[NarrativeZone], score: float, start: float = 0.0, end: float = 5.0, act: str = "act1") -> ClipEntry:
    return ClipEntry(source_start_s=start, source_end_s=end, beat_type="escalation_beat", act=act,
                     transition="hard_cut", money_shot_score=score, narrative_zone=zone)
```

**Class TestEnforceZonePacingCurve:**

```python
class TestEnforceZonePacingCurve:
    """EORD-03: enforce_zone_pacing_curve() trims CLIMAX zone clips to act3 targets."""
```

Imports enforce_zone_pacing_curve from cinecut.assembly.ordering (also from 08-02).

Test cases:

- **test_climax_clips_trimmed_to_act3_target**: CLIMAX zone clips averaging 10s → trimmed to near act3_avg_cut_s (action profile: 1.2s). Verify average after enforcement is <= act3_avg_cut_s * 1.5.

- **test_beginning_clips_not_trimmed**: BEGINNING zone clips are NOT trimmed regardless of length.

- **test_never_below_min_duration**: After trimming, no CLIMAX clip duration is below MIN_CLIP_DURATION_S (0.5s).

- **test_no_trimming_when_within_threshold**: CLIMAX clips already within act3_avg_cut_s * 1.5 are returned unchanged.

Run the full test suite to confirm no regressions in existing tests from schema.py changes:
`pytest tests/test_zone_matching.py -x -q && pytest tests/test_assembly.py -x -q && pytest tests/ -x -q`
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && pytest tests/test_zone_matching.py -x -q && pytest tests/test_manifest.py tests/test_cache.py tests/test_checkpoint.py -x -q</automated>
  </verify>
  <done>All test_zone_matching.py tests pass without live model download; existing test_manifest.py, test_cache.py, test_checkpoint.py pass with no regressions from schema changes; TestSortClipsByZone and TestEnforceZonePacingCurve classes exist in test_assembly.py (may fail until 08-02)</done>
</task>

</tasks>

<verification>
Import chain and schema verification:
```bash
cd /home/adamh/ai-video-trailer && python -c "
from cinecut.manifest.schema import NarrativeZone, ClipEntry, TrailerManifest
from cinecut.narrative.zone_matching import run_zone_matching, ZONE_ANCHORS, _zone_by_position
import json

# NarrativeZone enum correctness
assert NarrativeZone('BEGINNING') == NarrativeZone.BEGINNING
assert len(ZONE_ANCHORS) == 3

# ClipEntry with narrative_zone serializes correctly
ce = ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='act1',
               narrative_zone=NarrativeZone.ESCALATION, money_shot_score=0.75)
j = json.loads(ce.model_dump_json(exclude_none=True))
assert j['narrative_zone'] == 'ESCALATION'
assert 'money_shot_score' in j

# Backward compat: old manifest without narrative_zone field loads cleanly
ce_old = ClipEntry(source_start_s=0.0, source_end_s=5.0, beat_type='breath', act='act1')
assert ce_old.narrative_zone is None
j_old = json.loads(ce_old.model_dump_json(exclude_none=True))
assert 'narrative_zone' not in j_old

# Position fallback covers all three zones
assert _zone_by_position(100.0, 9000.0, None) == NarrativeZone.BEGINNING
assert _zone_by_position(4500.0, 9000.0, None) == NarrativeZone.ESCALATION
assert _zone_by_position(8000.0, 9000.0, None) == NarrativeZone.CLIMAX

# All-empty run_zone_matching uses fallback (no model load)
zones = run_zone_matching(['', '', ''], [100.0, 3500.0, 8000.0], 9000.0, None)
assert len(zones) == 3
assert all(isinstance(z, NarrativeZone) for z in zones)
print('Phase 08-01 verification: OK')
"
```

Full test suite (zone_matching + assembly — assembly zone tests will fail until 08-02):
```bash
cd /home/adamh/ai-video-trailer && pytest tests/test_zone_matching.py -v && pytest tests/ -x -q --ignore=tests/test_zone_matching.py 2>&1 | tail -5
```
</verification>

<success_criteria>
- NarrativeZone str enum in manifest/schema.py with BEGINNING, ESCALATION, CLIMAX values
- ClipEntry.narrative_zone: Optional[NarrativeZone] = None (backward compatible)
- narrative/zone_matching.py: _load_model() lru_cache singleton; ZONE_ANCHORS dict; assign_narrative_zone(); run_zone_matching(); _zone_by_position()
- Empty dialogue text returns position-based zone without touching sentence-transformers model
- sentence-transformers and torch added to pyproject.toml if not already present
- tests/test_zone_matching.py: 11 tests pass without live model download (mocked)
- tests/test_assembly.py: TestSortClipsByZone and TestEnforceZonePacingCurve classes appended (existing tests unmodified)
- Full test suite passes for existing tests: pytest tests/ -x -q (zone tests excluded until 08-02)
</success_criteria>

<output>
After completion, create `.planning/phases/08-zone-matching-and-non-linear-ordering/08-01-SUMMARY.md`
</output>
