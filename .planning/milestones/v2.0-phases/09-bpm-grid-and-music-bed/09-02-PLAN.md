---
phase: 09-bpm-grid-and-music-bed
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cinecut/assembly/music.py
  - pyproject.toml
autonomous: true
requirements:
  - MUSC-01
  - MUSC-02
  - MUSC-03

must_haves:
  truths:
    - "fetch_music_for_vibe() returns a MusicBed (dataclass) with local_path pointing to cached file when cache hit"
    - "fetch_music_for_vibe() calls the Jamendo API v3 and downloads the track when cache miss"
    - "fetch_music_for_vibe() returns None (never raises) on any failure: missing env var, network error, no downloadable tracks"
    - "Download uses atomic rename: writes to {vibe}.mp3.tmp then renames to {vibe}.mp3 to prevent partial-file corruption"
    - "audiodownload_allowed=True filter applied before selecting track (PITFALL 3)"
    - "pyproject.toml lists librosa>=0.11.0 and soundfile>=0.12.1"
  artifacts:
    - path: "src/cinecut/assembly/music.py"
      provides: "Jamendo music fetch, permanent per-vibe cache, MusicBed dataclass"
      exports:
        - VIBE_TO_JAMENDO_TAG
        - MusicBed (dataclass)
        - get_music_cache_dir
        - fetch_music_for_vibe
    - path: "pyproject.toml"
      provides: "librosa and soundfile added as project dependencies"
      contains:
        - "librosa>=0.11.0"
        - "soundfile>=0.12.1"
  key_links:
    - from: "assembly/music.py fetch_music_for_vibe()"
      to: "~/.cinecut/music/{vibe}.mp3"
      via: "atomic write: tmp path rename to final cached path"
    - from: "assembly/music.py MusicBed.local_path"
      to: "assembly/bpm.py generate_beat_grid()"
      via: "Plan 03 passes MusicBed.local_path as audio_path to generate_beat_grid()"
---

<objective>
Create assembly/music.py with the Jamendo API v3 fetch, permanent per-vibe disk cache at ~/.cinecut/music/,
and graceful degradation on any failure. Add librosa and soundfile to pyproject.toml.

Purpose: Provides the music file that BPM detection (Plan 01) will analyze. The permanent cache means
Jamendo API is called only once per vibe across all runs. Returns None instead of raising on any failure,
satisfying MUSC-03.
Output: assembly/music.py (fully functional), pyproject.toml updated with two new dependencies.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-bpm-grid-and-music-bed/09-RESEARCH.md

<interfaces>
From src/cinecut/assembly/bpm.py (created by Plan 01 — assembly/music.py does NOT import from bpm.py;
MusicBed.bpm field is filled by the caller in Plan 03 after running generate_beat_grid):

  @dataclass
  class BpmGrid:
      bpm: float
      beat_times_s: list[float]
      source: str
      beat_count: int = 0

From pyproject.toml (current dependencies — ADD to this, do not remove existing deps):
  "numpy>=1.24.0",
  "requests>=2.31.0",
  # ADD:
  "librosa>=0.11.0",
  "soundfile>=0.12.1",

Note: assembly/music.py defines its OWN MusicBed dataclass (for runtime use with local_path).
This is separate from the MusicBed Pydantic BaseModel in manifest/schema.py (used for JSON serialization).
The two MusicBed types are intentionally separate — the dataclass carries runtime data, the Pydantic model
carries only what is needed in the manifest JSON. Plan 03 converts between them.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assembly/music.py with Jamendo API fetch, permanent per-vibe cache, graceful degradation</name>
  <files>src/cinecut/assembly/music.py</files>
  <action>
Create src/cinecut/assembly/music.py. All patterns verified in 09-RESEARCH.md (Pattern 4, Pitfalls 3, 5, 7).

Module docstring: "Jamendo API v3 music fetch with permanent per-vibe cache for Phase 9 music bed (MUSC-01, MUSC-02, MUSC-03)."

Imports: import os, import logging, import requests, from dataclasses import dataclass, from pathlib import Path, from typing import Optional

_logger = logging.getLogger("cinecut")

JAMENDO_TRACKS_URL = "https://api.jamendo.com/v3.0/tracks/"

VIBE_TO_JAMENDO_TAG (dict[str, str]) — 18 vibes from RESEARCH.md Pattern 4:
  action="action", adventure="adventure", animation="pop", comedy="pop",
  crime="darkambient", documentary="documentary", drama="dramatic", family="pop",
  fantasy="epic", history="classical", horror="darkambient", music="pop",
  mystery="darkambient", romance="romantic", sci-fi="electronic", thriller="dramatic",
  war="epic", western="acoustic"

MusicBed dataclass:
  @dataclass
  class MusicBed:
      """Music track selected by Phase 9. local_path points to ~/.cinecut/music/{vibe}.mp3."""
      track_id: str
      track_name: str
      artist_name: str
      license_ccurl: str
      local_path: str     # Absolute path to the cached MP3 file
      bpm: Optional[float] = None   # Filled by Plan 03 after generate_beat_grid() runs

get_music_cache_dir() -> Path:
  """Return ~/.cinecut/music/, creating it if it does not exist."""
  cache_dir = Path.home() / ".cinecut" / "music"
  cache_dir.mkdir(parents=True, exist_ok=True)
  return cache_dir

fetch_music_for_vibe(vibe: str) -> Optional[MusicBed]:
  """Fetch or return cached CC-licensed music track for the given vibe.

  MUSC-02: Returns cached MusicBed immediately if ~/.cinecut/music/{vibe}.mp3 exists (no API call).
  MUSC-01: On cache miss, calls Jamendo API v3 tracks endpoint and downloads the first track
           with audiodownload_allowed=True.
  MUSC-03: Any exception (network error, missing client_id, no results, download failure) is
           caught — logs a warning and returns None. Pipeline continues without music.

  Requires: JAMENDO_CLIENT_ID env var set to a valid Jamendo developer client_id.
  """

  Entire function body wrapped in try/except Exception as exc:
    On exception: _logger.warning("Music bed unavailable for vibe '%s': %s — trailer will be produced without music", vibe, exc); return None

  Inside the try:
    cache_dir = get_music_cache_dir()
    cached_path = cache_dir / f"{vibe}.mp3"

    # MUSC-02: Cache hit — return immediately without API call
    if cached_path.exists():
        return MusicBed(
            track_id="cached",
            track_name=f"{vibe} (cached)",
            artist_name="unknown",
            license_ccurl="",
            local_path=str(cached_path),
        )

    # MUSC-01: Cache miss — check env var before calling API
    client_id = os.environ.get("JAMENDO_CLIENT_ID", "")
    if not client_id:
        raise ValueError("JAMENDO_CLIENT_ID env var not set — register at developer.jamendo.com")

    tag = VIBE_TO_JAMENDO_TAG.get(vibe, "pop")
    params = {
        "client_id": client_id,
        "format": "json",
        "limit": "10",
        "tags": tag,
        "order": "popularity_total",
        "audioformat": "mp32",
        "include": "musicinfo",
    }
    resp = requests.get(JAMENDO_TRACKS_URL, params=params, timeout=15)
    resp.raise_for_status()

    data = resp.json()
    tracks = data.get("results", [])
    if not tracks:
        raise ValueError(f"Jamendo returned 0 tracks for tag '{tag}'")

    # PITFALL 3: filter for audiodownload_allowed=True (since April 2022, False returns 404)
    downloadable = [t for t in tracks if t.get("audiodownload_allowed", False)]
    if not downloadable:
        raise ValueError(f"No downloadable tracks in Jamendo results for tag '{tag}'")
    selected = downloadable[0]

    download_url = selected.get("audiodownload", "")
    if not download_url:
        raise ValueError("Selected track has no audiodownload URL")

    # PITFALL 7: atomic download — write to .tmp then rename to prevent partial-file corruption
    tmp_path = cache_dir / f"{vibe}.mp3.tmp"
    try:
        with requests.get(download_url, stream=True, timeout=60) as dl:
            dl.raise_for_status()
            with open(tmp_path, "wb") as f:
                for chunk in dl.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
        tmp_path.rename(cached_path)  # atomic on same filesystem
    except Exception:
        tmp_path.unlink(missing_ok=True)   # clean up partial file
        raise

    return MusicBed(
        track_id=str(selected.get("id", "unknown")),
        track_name=selected.get("name", "unknown"),
        artist_name=selected.get("artist_name", "unknown"),
        license_ccurl=selected.get("license_ccurl", ""),
        local_path=str(cached_path),
    )
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.music import MusicBed, fetch_music_for_vibe, get_music_cache_dir, VIBE_TO_JAMENDO_TAG
print('music.py imports OK')
# Missing JAMENDO_CLIENT_ID should return None gracefully (MUSC-03)
import os
os.environ.pop('JAMENDO_CLIENT_ID', None)
result = fetch_music_for_vibe('action')
assert result is None, f'Expected None when no client_id, got: {result}'
print('MUSC-03 graceful None: OK')
# MusicBed dataclass
mb = MusicBed(track_id='1', track_name='Test', artist_name='Artist', license_ccurl='http://cc', local_path='/tmp/test.mp3')
assert mb.bpm is None
print('MusicBed dataclass: OK')
# All 18 vibes have a tag mapping
for vibe in ['action', 'adventure', 'drama', 'sci-fi', 'thriller']:
    assert vibe in VIBE_TO_JAMENDO_TAG, f'Missing vibe tag: {vibe}'
print('VIBE_TO_JAMENDO_TAG coverage: OK')
print('Task 1 PASS')
"</verify>
  <done>assembly/music.py importable; fetch_music_for_vibe returns None (not raises) when JAMENDO_CLIENT_ID is absent; MusicBed dataclass constructible; all 18 vibes present in VIBE_TO_JAMENDO_TAG</done>
</task>

<task type="auto">
  <name>Task 2: Add librosa and soundfile to pyproject.toml dependencies</name>
  <files>pyproject.toml</files>
  <action>
Read pyproject.toml. In the [project] dependencies list, add two new entries after the existing "msgpack>=1.1.0" line:
    "librosa>=0.11.0",
    "soundfile>=0.12.1",

Do NOT remove or change any existing dependency entries.

After editing, run: pip install librosa soundfile
to ensure the packages are installed in the active virtualenv.

CRITICAL (PITFALL 2): soundfile>=0.12.1 is required for MP3 support (bundles libsndfile 1.1.0+ on Linux).
Without this, librosa.load() on .mp3 files raises LibsndfileError. The Jamendo download format is mp32
(MP3 VBR) — librosa must be able to read it.
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
import librosa, soundfile
print(f'librosa {librosa.__version__} OK')
print(f'soundfile {soundfile.__version__} OK')
# Verify soundfile version is >= 0.12.1 for MP3 support
from packaging.version import Version
assert Version(soundfile.__version__) >= Version('0.12.1'), f'soundfile too old: {soundfile.__version__}'
print('soundfile MP3 support (>= 0.12.1): OK')
" 2>/dev/null || python -c "import librosa; import soundfile; print('librosa and soundfile present')"</verify>
  <done>librosa and soundfile appear in pyproject.toml dependencies; both packages importable in the project virtualenv; soundfile version >= 0.12.1</done>
</task>

</tasks>

<verification>
Run existing test suite to confirm no regressions from pyproject.toml change:
  cd /home/adamh/ai-video-trailer && python -m pytest tests/ -x -q

Confirm full music module import chain:
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.assembly.music import fetch_music_for_vibe, MusicBed, VIBE_TO_JAMENDO_TAG; from cinecut.assembly.bpm import generate_beat_grid; print('Phase 9 Plan 02 all symbols OK')"
</verification>

<success_criteria>
- assembly/music.py: MusicBed dataclass, fetch_music_for_vibe, get_music_cache_dir, VIBE_TO_JAMENDO_TAG all importable
- fetch_music_for_vibe('action') returns None (not raises) when JAMENDO_CLIENT_ID is not set
- VIBE_TO_JAMENDO_TAG has all 18 vibes
- pyproject.toml contains "librosa>=0.11.0" and "soundfile>=0.12.1"
- librosa and soundfile importable in virtualenv
- python -m pytest tests/ -x exits 0 (no regressions)
</success_criteria>

<output>
After completion, create .planning/phases/09-bpm-grid-and-music-bed/09-02-SUMMARY.md
</output>
