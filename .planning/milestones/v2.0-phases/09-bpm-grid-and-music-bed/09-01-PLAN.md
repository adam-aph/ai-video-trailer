---
phase: 09-bpm-grid-and-music-bed
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cinecut/assembly/bpm.py
  - src/cinecut/manifest/schema.py
autonomous: true
requirements:
  - BPMG-01
  - BPMG-02
  - BPMG-03

must_haves:
  truths:
    - "Given a music file path and vibe, generate_beat_grid() returns a BpmGrid (never crashes)"
    - "resolve_bpm() corrects 0-BPM (returns vibe default), half-tempo, and double-tempo octave errors"
    - "snap_to_nearest_beat() snaps clip start times to nearest beat within plus-or-minus 1 beat tolerance, clamped to >= 0.0"
    - "TrailerManifest in schema.py has optional bpm_grid and music_bed fields using BpmGrid and MusicBed Pydantic models"
  artifacts:
    - path: "src/cinecut/assembly/bpm.py"
      provides: "BPM detection, octave correction, beat grid generation, beat snapping"
      exports:
        - VIBE_BPM_DEFAULTS
        - VIBE_BPM_RANGES
        - BpmGrid (dataclass)
        - resolve_bpm
        - generate_beat_grid
        - snap_to_nearest_beat
    - path: "src/cinecut/manifest/schema.py"
      provides: "BpmGrid and MusicBed Pydantic manifest models; TrailerManifest bpm_grid and music_bed optional fields"
      contains:
        - "class BpmGrid(BaseModel)"
        - "class MusicBed(BaseModel)"
        - "bpm_grid: Optional[BpmGrid] = None"
        - "music_bed: Optional[MusicBed] = None"
  key_links:
    - from: "assembly/bpm.py generate_beat_grid()"
      to: "assembly/bpm.py BpmGrid dataclass"
      via: "returns BpmGrid(bpm=resolved_bpm, beat_times_s=..., source=..., beat_count=...)"
    - from: "assembly/bpm.py snap_to_nearest_beat()"
      to: "manifest/schema.py ClipEntry.source_start_s"
      via: "returns snapped float; caller uses model_copy(update={'source_start_s': snapped})"
    - from: "manifest/schema.py BpmGrid (Pydantic)"
      to: "manifest/schema.py TrailerManifest"
      via: "bpm_grid: Optional[BpmGrid] = None field on TrailerManifest"
---

<objective>
Create assembly/bpm.py with BPM detection, octave correction, beat grid generation, and beat snapping.
Add BpmGrid and MusicBed Pydantic manifest models to manifest/schema.py, and wire them as optional
fields on TrailerManifest.

Purpose: These are the foundational contracts that Plan 02 (music.py) and Plan 03 (cli.py wiring) consume.
Beat snapping (BPMG-02) requires the beat grid. Manifest recording requires Pydantic models.
Output: assembly/bpm.py (fully functional), manifest/schema.py (BpmGrid + MusicBed models added).
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-bpm-grid-and-music-bed/09-RESEARCH.md

<interfaces>
From src/cinecut/manifest/schema.py (current — ADD to this file, do NOT replace existing content):

  class ClipEntry(BaseModel):
      source_start_s: float = Field(ge=0.0)
      source_end_s: float = Field(ge=0.0)
      # ... beat_type, act, transition, dialogue_excerpt, reasoning, visual_analysis,
      # subtitle_analysis, money_shot_score (all already present)
      # Phase 8 addition (present from Phase 8):
      narrative_zone: Optional[str] = None

  class TrailerManifest(BaseModel):
      schema_version: str = "2.0"   # already bumped by Phase 7
      source_file: str
      vibe: str
      clips: list[ClipEntry] = Field(min_length=1)
      structural_anchors: Optional["StructuralAnchors"] = None
      # Phase 9 additions (ADD THESE):
      bpm_grid: Optional["BpmGrid"] = None
      music_bed: Optional["MusicBed"] = None

From src/cinecut/assembly/ordering.py (existing — for reference):

  ACT_ORDER = ["cold_open", "act1", "beat_drop", "act2", "breath", "act3"]
  def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]: ...
  def enforce_pacing_curve(clips, profile) -> list[ClipEntry]: ...
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create assembly/bpm.py with BPM detection, octave correction, beat grid, and beat snapping</name>
  <files>src/cinecut/assembly/bpm.py</files>
  <action>
Create src/cinecut/assembly/bpm.py. All patterns verified in 09-RESEARCH.md.

Module docstring: "BPM detection, octave correction, beat grid generation, and beat-snap for Phase 9 (BPMG-01, BPMG-02, BPMG-03)."

Imports: import librosa, import numpy as np, from dataclasses import dataclass, from typing import Optional

VIBE_BPM_DEFAULTS (dict[str, float]) — 18 vibes with research-derived defaults:
  action=128.0, adventure=110.0, animation=100.0, comedy=95.0, crime=105.0, documentary=75.0,
  drama=80.0, family=95.0, fantasy=105.0, history=80.0, horror=90.0, music=120.0,
  mystery=88.0, romance=80.0, sci-fi=115.0, thriller=120.0, war=118.0, western=90.0

VIBE_BPM_RANGES (dict[str, tuple[float, float]]) — 18 vibes from RESEARCH.md Pattern 2:
  action=(100.0, 160.0), adventure=(90.0, 140.0), animation=(80.0, 130.0), comedy=(75.0, 130.0),
  crime=(80.0, 140.0), documentary=(55.0, 110.0), drama=(60.0, 110.0), family=(75.0, 130.0),
  fantasy=(80.0, 140.0), history=(55.0, 110.0), horror=(60.0, 130.0), music=(90.0, 160.0),
  mystery=(65.0, 120.0), romance=(60.0, 110.0), sci-fi=(90.0, 150.0), thriller=(90.0, 150.0),
  war=(90.0, 150.0), western=(65.0, 125.0)

BpmGrid dataclass:
  @dataclass
  class BpmGrid:
      bpm: float              # Resolved BPM after octave correction or fallback
      beat_times_s: list[float]  # Beat timestamps in seconds, all >= 0.0
      source: str             # "librosa" or "vibe_default"
      beat_count: int = 0     # len(beat_times_s), set in generate_beat_grid

resolve_bpm(raw_bpm: float, vibe: str) -> float:
  Docstring: "Apply BPMG-03: 0-BPM guard, octave-error correction, vibe-default fallback."
  vibe_min, vibe_max = VIBE_BPM_RANGES.get(vibe, (60.0, 160.0))
  vibe_default = VIBE_BPM_DEFAULTS.get(vibe, 100.0)
  Guard 1 (no onset): if raw_bpm < 10.0: return vibe_default
  Guard 2 (half-tempo octave error — double it): if raw_bpm < vibe_min * 0.7 and vibe_min <= raw_bpm * 2.0 <= vibe_max: return raw_bpm * 2.0
  Guard 3 (double-tempo octave error — halve it): if raw_bpm > vibe_max * 1.4 and vibe_min <= raw_bpm / 2.0 <= vibe_max: return raw_bpm / 2.0
  Guard 4 (still out of range after correction): if not (vibe_min <= raw_bpm <= vibe_max): return vibe_default
  return raw_bpm  # In range — no correction needed

generate_beat_grid(audio_path: str, vibe: str, duration_s: float) -> BpmGrid:
  Docstring: "Load audio, detect BPM, generate beat timestamps (BPMG-01, BPMG-03). Always returns valid BpmGrid."
  Outer try/except Exception wraps everything — on any failure return BpmGrid with vibe_default and synthesized grid.
  Inner try: load audio with librosa.load(audio_path, sr=22050, mono=True), call librosa.beat.beat_track(y=y, sr=sr)
  CRITICAL (PITFALL 1): raw_bpm = float(tempo[0]) if isinstance(tempo, np.ndarray) else float(tempo)
  except Exception: raw_bpm = 0.0; beat_frames = np.array([])
  resolved_bpm = resolve_bpm(raw_bpm, vibe)
  source = "librosa" if (resolved_bpm == raw_bpm and raw_bpm >= 10.0) else "vibe_default"
  If source == "librosa" and len(beat_frames) > 0:
    raw_times = librosa.frames_to_time(beat_frames, sr=22050)
    beat_times = [t for t in raw_times.tolist() if t >= 0.0]  # PITFALL 6: filter negatives
  Else (vibe_default case): synthesize regular grid:
    beat_interval_s = 60.0 / resolved_bpm
    beat_times = list(np.arange(0.0, duration_s, beat_interval_s))
  return BpmGrid(bpm=resolved_bpm, beat_times_s=beat_times, source=source, beat_count=len(beat_times))

snap_to_nearest_beat(start_s: float, beat_times_s: list[float], bpm: float) -> float:
  Docstring: "Snap clip start time to nearest beat within +/-1 beat tolerance (BPMG-02). Returns start_s unchanged if no beat within tolerance."
  if not beat_times_s: return start_s
  beat_interval_s = 60.0 / max(bpm, 10.0)  # +/-1 beat tolerance window
  beat_arr = np.array(beat_times_s)
  distances = np.abs(beat_arr - start_s)
  nearest_idx = int(np.argmin(distances))
  if distances[nearest_idx] <= beat_interval_s:
    return max(0.0, float(beat_arr[nearest_idx]))  # PITFALL 6: clamp >= 0.0
  return start_s  # No beat within tolerance — keep original
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.assembly.bpm import BpmGrid, resolve_bpm, generate_beat_grid, snap_to_nearest_beat, VIBE_BPM_DEFAULTS, VIBE_BPM_RANGES
print('bpm.py imports OK')
# 0-BPM guard
assert resolve_bpm(0.0, 'action') == 128.0, 'BPMG-03 0-BPM guard failed'
# Half-tempo: 64 BPM for action (range 100-160) should double to 128
assert resolve_bpm(64.0, 'action') == 128.0, 'BPMG-03 half-tempo correction failed'
# Double-tempo: 256 BPM for action should halve to 128
assert resolve_bpm(256.0, 'action') == 128.0, 'BPMG-03 double-tempo correction failed'
# In-range passes through
result = resolve_bpm(120.0, 'action')
assert result == 120.0, f'In-range BPM should pass through: {result}'
print('resolve_bpm guards: all OK')
# snap_to_nearest_beat - no beats returns original
assert snap_to_nearest_beat(5.0, [], 120.0) == 5.0
# snap within tolerance
beats = [0.0, 0.5, 1.0, 1.5, 2.0]
snapped = snap_to_nearest_beat(0.3, beats, 120.0)  # 1 beat = 0.5s; 0.3 is within 0.5 of 0.5
assert snapped == 0.5, f'Beat snap failed: {snapped}'
# negative clamp
snapped_neg = snap_to_nearest_beat(0.05, [-0.1, 0.0, 0.5], 120.0)
assert snapped_neg >= 0.0, f'Negative beat result not clamped: {snapped_neg}'
print('snap_to_nearest_beat: all OK')
print('Task 1 PASS')
"</verify>
  <done>assembly/bpm.py exists, all named symbols importable, resolve_bpm handles all BPMG-03 cases, snap_to_nearest_beat snaps within tolerance and clamps negatives to 0.0</done>
</task>

<task type="auto">
  <name>Task 2: Add BpmGrid and MusicBed Pydantic models to manifest/schema.py; wire into TrailerManifest</name>
  <files>src/cinecut/manifest/schema.py</files>
  <action>
Read the current manifest/schema.py carefully. Add the following without removing or changing any existing content.

Add two new Pydantic models BEFORE the TrailerManifest class (place them after the ClipEntry class):

  class BpmGrid(BaseModel):
      """BPM grid metadata stored in manifest (BPMG-01, BPMG-03)."""
      bpm: float = Field(gt=0.0, description="Resolved BPM after octave correction or vibe_default fallback")
      beat_count: int = Field(ge=0, description="Number of beat timestamps in the grid")
      source: str = Field(description="'librosa' if detected from audio; 'vibe_default' if fallback used")

  class MusicBed(BaseModel):
      """Music track metadata stored in manifest (MUSC-01, MUSC-02)."""
      track_id: str
      track_name: str
      artist_name: str
      license_ccurl: str
      local_path: str     # Absolute path to ~/.cinecut/music/{vibe}.mp3
      bpm: Optional[float] = None   # Filled after BPM detection runs on the music file

IMPORTANT: BpmGrid in schema.py is a Pydantic BaseModel (for JSON serialization in the manifest).
It is DIFFERENT from the BpmGrid dataclass in assembly/bpm.py (which carries the full beat_times_s list
for computation). Do NOT import or reference assembly/bpm.py from schema.py.

Add two optional fields to TrailerManifest (after the structural_anchors field):
  bpm_grid: Optional[BpmGrid] = None      # None if BPM detection was skipped or unavailable
  music_bed: Optional[MusicBed] = None    # None if music unavailable (MUSC-03 graceful degradation)

The field type annotation uses the string form "BpmGrid" and "MusicBed" if needed to avoid forward-reference
issues, or use the direct class reference since they are defined in the same file above TrailerManifest.

Ensure Optional is imported from typing (already present in schema.py). Field is already imported from pydantic.

Do NOT change schema_version — it will be "2.0" from Phase 7 (or will be updated by Phase 7 execution).
Do NOT change any existing ClipEntry fields, validators, or TrailerManifest logic.
  </action>
  <verify>cd /home/adamh/ai-video-trailer && python -c "
from cinecut.manifest.schema import TrailerManifest, ClipEntry, BpmGrid, MusicBed
print('schema.py imports OK')
# BpmGrid Pydantic model
bg = BpmGrid(bpm=128.0, beat_count=342, source='librosa')
j = bg.model_dump_json()
assert '128' in j and 'librosa' in j, 'BpmGrid JSON failed'
# MusicBed Pydantic model
mb = MusicBed(track_id='123', track_name='test', artist_name='artist', license_ccurl='http://cc', local_path='/tmp/test.mp3')
assert mb.bpm is None
# TrailerManifest with new optional fields
clip = ClipEntry(source_start_s=0.0, source_end_s=3.0, beat_type='escalation_beat', act='act1')
tm = TrailerManifest(source_file='test.mkv', vibe='action', clips=[clip])
assert tm.bpm_grid is None
assert tm.music_bed is None
# Assign and serialize
tm2 = tm.model_copy(update={'bpm_grid': bg})
assert tm2.bpm_grid.bpm == 128.0
j2 = tm2.model_dump_json()
assert 'bpm_grid' in j2 and '128' in j2, 'TrailerManifest BpmGrid JSON failed'
print('Task 2 PASS')
"</verify>
  <done>BpmGrid and MusicBed Pydantic models importable from manifest/schema.py; TrailerManifest.bpm_grid and TrailerManifest.music_bed fields accept None and valid model instances; all existing tests still pass</done>
</task>

</tasks>

<verification>
Run existing test suite to confirm no regressions:
  cd /home/adamh/ai-video-trailer && python -m pytest tests/test_assembly.py tests/test_manifest.py -v

Verify new imports work end-to-end:
  cd /home/adamh/ai-video-trailer && python -c "from cinecut.assembly.bpm import generate_beat_grid, snap_to_nearest_beat; from cinecut.manifest.schema import BpmGrid, MusicBed, TrailerManifest; print('all Phase 9 Plan 01 symbols OK')"
</verification>

<success_criteria>
- assembly/bpm.py: all six symbols exported (VIBE_BPM_DEFAULTS, VIBE_BPM_RANGES, BpmGrid dataclass, resolve_bpm, generate_beat_grid, snap_to_nearest_beat)
- resolve_bpm: 0-BPM returns vibe default; 64 BPM for action returns 128.0; 256 BPM for action returns 128.0; 120 BPM for action returns 120.0
- snap_to_nearest_beat: snaps within tolerance; returns original if no beat in range; result always >= 0.0
- manifest/schema.py: BpmGrid and MusicBed importable as Pydantic BaseModel; TrailerManifest.bpm_grid and .music_bed default to None; serializes cleanly via model_dump_json()
- python -m pytest tests/ -x exits 0 (no regressions)
</success_criteria>

<output>
After completion, create .planning/phases/09-bpm-grid-and-music-bed/09-01-SUMMARY.md
</output>
