---
phase: 10-sfx-vo-and-audio-mix
plan: 03
type: execute
wave: 2
depends_on:
  - 10-01
  - 10-02
files_modified:
  - src/cinecut/conform/audio_mix.py
  - src/cinecut/conform/pipeline.py
  - tests/test_sfx_vo_mix.py
autonomous: true
requirements:
  - AMIX-01
  - AMIX-02
  - AMIX-03
must_haves:
  truths:
    - "Music bed audibly ducks during protagonist VO via sidechaincompress (attack=100ms, release=600ms)"
    - "All four stems (film audio, music, SFX, VO) are independently loudnorm-normalized before mixing"
    - "amix normalize=0 is used throughout — never normalize=1 (mandatory per STATE.md decision)"
    - "All stems resampled to 48000Hz stereo before mixing via aresample+aformat"
    - "mix_four_stems() produces trailer_final.mp4 replacing Pass 2 concat output with four-stem audio"
    - "When music bed is absent (Phase 9 unavailable), mix_four_stems() falls back to three-stem mix without aborting"
    - "Pipeline wiring: Pass 3 synthesizes SFX+extracts VO, Pass 4 runs four-stem mix"
    - "Unit tests verify: SFX synthesis idempotency, protagonist None graceful degradation, adelay millisecond conversion, normalize=0 constraint in generated filtergraph"
  artifacts:
    - path: "src/cinecut/conform/audio_mix.py"
      provides: "mix_four_stems() — four-stem mix with sidechaincompress ducking and amix normalize=0"
      exports:
        - "mix_four_stems"
        - "DUCK_THRESHOLD"
        - "DUCK_RATIO"
        - "DUCK_ATTACK_MS"
        - "DUCK_RELEASE_MS"
    - path: "src/cinecut/conform/pipeline.py"
      provides: "conform_manifest() extended with Pass 3 (SFX+VO) and Pass 4 (four-stem mix)"
      exports:
        - "conform_manifest"
    - path: "tests/test_sfx_vo_mix.py"
      provides: "Unit tests for sfx.py, vo_extract.py, audio_mix.py"
  key_links:
    - from: "src/cinecut/conform/audio_mix.py"
      to: "FFmpeg filtergraph"
      via: "mix_four_stems() builds dynamic -filter_complex string"
      pattern: "sidechaincompress.*threshold.*ratio.*attack.*release"
    - from: "src/cinecut/conform/audio_mix.py"
      to: "amix normalize=0"
      via: "amix=inputs=4:normalize=0:weights in filtergraph"
      pattern: "amix.*normalize=0"
    - from: "src/cinecut/conform/pipeline.py"
      to: "cinecut.conform.sfx.synthesize_sfx_files + apply_sfx_to_timeline"
      via: "Pass 3 in conform_manifest() after concatenate_clips()"
      pattern: "synthesize_sfx_files.*apply_sfx_to_timeline"
    - from: "src/cinecut/conform/pipeline.py"
      to: "cinecut.conform.audio_mix.mix_four_stems"
      via: "Pass 4 in conform_manifest() after Pass 3"
      pattern: "mix_four_stems"
---

<objective>
Implement `conform/audio_mix.py` (four-stem mix with sidechain ducking) and wire Pass 3 (SFX+VO) and Pass 4 (audio mix) into `conform/pipeline.py`. Add unit tests covering the critical audio mix constraints.

Purpose: Fulfils AMIX-01, AMIX-02, AMIX-03 — sidechaincompress music ducking, independent stem loudnorm, amix normalize=0, 48000Hz resampling throughout. Wires all Phase 10 modules into the pipeline.
Output: `conform/audio_mix.py`, updated `conform/pipeline.py`, `tests/test_sfx_vo_mix.py`.
</objective>

<execution_context>
@/home/adamh/.claude/get-shit-done/workflows/execute-plan.md
@/home/adamh/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-sfx-vo-and-audio-mix/10-RESEARCH.md
@.planning/phases/10-sfx-vo-and-audio-mix/10-01-SUMMARY.md
@.planning/phases/10-sfx-vo-and-audio-mix/10-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts. Executor uses these directly — no codebase exploration needed. -->

From src/cinecut/conform/sfx.py (created in Plan 01):
```python
SFX_HARD_DURATION_S: float = 0.4
SFX_BOUNDARY_DURATION_S: float = 1.2

def synthesize_sfx_files(work_dir: Path) -> tuple[Path, Path]:
    """Synthesize sfx_hard.wav (0.4s) and sfx_boundary.wav (1.2s) into work_dir/sfx/.
    Idempotent — skips FFmpeg if files already exist.
    Returns (sfx_hard_path, sfx_boundary_path)."""

def apply_sfx_to_timeline(
    manifest: TrailerManifest,
    sfx_hard: Path,
    sfx_boundary: Path,
    work_dir: Path,
    concat_duration_s: float,
) -> Path:
    """Overlay SFX at cut positions using adelay. Returns work_dir/sfx/sfx_mix.wav."""
```

From src/cinecut/conform/vo_extract.py (created in Plan 02):
```python
@dataclass
class VoClip:
    path: Path           # extracted .aac file path
    timeline_s: float    # position in trailer timeline (seconds)
    act_zone: str        # "act1" or "act2"

def identify_protagonist(subtitle_path: Path) -> str | None: ...

def extract_vo_clips(
    manifest: TrailerManifest,
    source: Path,
    subtitle_path: Path,
    work_dir: Path,
) -> list[VoClip]: ...
```

From src/cinecut/conform/pipeline.py (existing — to be modified):
```python
def conform_manifest(
    manifest: TrailerManifest,
    source: Path,
    work_dir: Path,
    extra_clip_paths: list[Path] | None = None,
) -> Path:
    # Pass 1: extract_and_grade_clip() x N clips
    # Pass 2: concatenate_clips() -> final_output_path (currently the FINAL output)
    # ADD: Pass 3 — synthesize_sfx_files(), apply_sfx_to_timeline(), extract_vo_clips()
    # ADD: Pass 4 — mix_four_stems() -> trailer_final.mp4 (new final output)
```

From src/cinecut/manifest/schema.py:
```python
class TrailerManifest(BaseModel):
    source_file: str
    vibe: str
    clips: list[ClipEntry]
    bpm_grid: Optional[BpmGrid] = None    # Phase 9
    music_bed: Optional[MusicBed] = None  # Phase 9 — has local_path field

class MusicBed(BaseModel):
    local_path: str    # path to cached music file (e.g. ~/.cinecut/music/action.mp3)
    track_id: str
    track_name: str
    # ... other fields
```

From src/cinecut/errors.py:
```python
class ConformError(CineCutError):
    def __init__(self, path: Path, stderr: str) -> None: ...
```

Existing loudnorm pattern (from pipeline.py pass 1):
```python
# Two-pass loudnorm: run FFmpeg with -af loudnorm:print_format=json -> -f null -
# Parse JSON from stderr with re.search(r"\{[^}]+\}", result.stderr, re.DOTALL)
# Then apply measured stats in pass 2 with linear=true
```

Four-stem mix filtergraph (from RESEARCH.md — verified against FFmpeg docs):
```
[1:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[film];
[2:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[music];
[3:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[sfx];
[4:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[vo];
[vo]asplit=2[vo_out][vo_sc];
[music][vo_sc]sidechaincompress=threshold=0.025:ratio=6:attack=100:release=600:makeup=1[music_ducked];
[film][music_ducked][sfx][vo_out]amix=inputs=4:normalize=0:weights='1.0 0.7 0.8 1.0'[mixed]
```
Three-stem fallback (no music):
```
[1:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[film];
[2:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[sfx];
[3:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[vo];
[film][sfx][vo]amix=inputs=3:normalize=0:weights='1.0 0.8 1.0'[mixed]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conform/audio_mix.py — four-stem mix with sidechaincompress ducking</name>
  <files>src/cinecut/conform/audio_mix.py</files>
  <action>
Create `src/cinecut/conform/audio_mix.py` with:

**Module-level tuning constants (easy to adjust empirically per STATE.md):**
```python
# Sidechain ducking parameters — require empirical tuning per STATE.md
DUCK_THRESHOLD: float = 0.025   # ~-32dB
DUCK_RATIO: float = 6.0
DUCK_ATTACK_MS: int = 100
DUCK_RELEASE_MS: int = 600

# amix stem weights: film=1.0, music=0.7, sfx=0.8, vo=1.0
STEM_WEIGHTS_FOUR: str = "1.0 0.7 0.8 1.0"
STEM_WEIGHTS_THREE: str = "1.0 0.8 1.0"  # film, sfx, vo (no music)
```

**`_loudnorm_stem(input_path: Path, output_path: Path) -> Path`** (private helper):
- Two-pass loudnorm targeting -16 LUFS (standard broadcast loudness for trailers)
- Pass 1: `ffmpeg -i INPUT -af "loudnorm=I=-16:LRA=7:tp=-2:print_format=json" -f null -`
- Parse JSON from stderr using `re.search(r"\{[^}]+\}", result.stderr, re.DOTALL)`
- Pass 2: `ffmpeg -y -i INPUT -af "loudnorm=I=-16:LRA=7:tp=-2:measured_I=...:linear=true" -c:a aac -ar 48000 -ac 2 OUTPUT`
- Returns `output_path` on success; raises `ConformError` on FFmpeg failure

**`mix_four_stems(concat_path: Path, sfx_mix: Path, vo_clips: list, music_bed_path: Path | None, work_dir: Path) -> Path`:**
- `vo_clips` is `list[VoClip]` from vo_extract.py (imported by type only)
- Step 1: Extract film audio from concat MP4 (Pass 2 output) → `work_dir/stems/film_audio_raw.aac`
  ```
  ffmpeg -y -i CONCAT_PATH -vn -c:a aac -ar 48000 -ac 2 film_audio_raw.aac
  ```
- Step 2: Loudnorm each stem independently (AMIX-02):
  - Film audio: `_loudnorm_stem(film_audio_raw.aac, work_dir/stems/film_audio.aac)`
  - SFX mix: normalize and convert to AAC → `work_dir/stems/sfx_norm.aac`
  - Music bed (if present): `_loudnorm_stem(music_bed_path, work_dir/stems/music_norm.aac)` — only if `music_bed_path is not None and music_bed_path.exists()`
  - VO stem: if `vo_clips` is non-empty, build a combined VO AAC by positioning each VoClip at its `timeline_s` using `adelay` and mixing them; otherwise use silence (0.1s aevalsrc=0) as a placeholder — do NOT skip VO stem if no clips, use near-silence to keep filtergraph inputs consistent
    - VO combination filtergraph: each clip gets `[N:a]adelay=MS|MS[voN]`, then `[vo0][vo1]...amix=inputs=N:normalize=0[vo_combined]`; output → `work_dir/stems/vo_mix.aac`
    - If no VO clips: create `work_dir/stems/vo_mix.aac` as 0.1s silence using `ffmpeg -f lavfi -i "aevalsrc=0:s=48000:d=0.1:c=stereo" -c:a aac -ar 48000 -ac 2 vo_mix.aac`
- Step 3: Build the final mixer filtergraph and produce `trailer_final.mp4`:
  - Strip audio from concat MP4: `ffmpeg -y -i CONCAT_PATH -an -c:v copy trailer_noaudio.mp4`
  - If music stem available (four-stem mix):
    ```
    ffmpeg -y \
      -i trailer_noaudio.mp4 \      # input 0: video
      -i film_audio.aac \           # input 1: film audio (normalized)
      -i music_norm.aac \           # input 2: music bed (normalized)
      -i sfx_norm.aac \             # input 3: SFX
      -i vo_mix.aac \               # input 4: VO
      -filter_complex "
        [1:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[film];
        [2:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[music];
        [3:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[sfx];
        [4:a]aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo[vo];
        [vo]asplit=2[vo_out][vo_sc];
        [music][vo_sc]sidechaincompress=threshold=DUCK_THRESHOLD:ratio=DUCK_RATIO:attack=DUCK_ATTACK_MS:release=DUCK_RELEASE_MS:makeup=1[music_ducked];
        [film][music_ducked][sfx][vo_out]amix=inputs=4:normalize=0:weights='STEM_WEIGHTS_FOUR'[mixed]
      " \
      -map 0:v -map "[mixed]" \
      -c:v copy -c:a aac -ar 48000 -ac 2 \
      trailer_final.mp4
    ```
  - If music absent (three-stem fallback — MUSC-03 graceful degradation pattern):
    ```
    # inputs: 0=video, 1=film, 2=sfx, 3=vo
    # filter: aresample+aformat per stem; amix=inputs=3:normalize=0
    ```
  - Use f-string formatting to substitute the tuning constants into the filtergraph string
  - Raises `ConformError` if FFmpeg fails
  - Returns path to `work_dir/trailer_final.mp4`

**`create_stems_dir(work_dir: Path) -> Path`** (private helper): creates and returns `work_dir/stems/`

**Import block:**
```python
import re
import subprocess
from pathlib import Path
from cinecut.errors import ConformError
```

Note: Import `VoClip` with `TYPE_CHECKING` guard to avoid circular imports:
```python
from __future__ import annotations
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from cinecut.conform.vo_extract import VoClip
```
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -c "from cinecut.conform.audio_mix import mix_four_stems, DUCK_THRESHOLD, DUCK_RATIO, DUCK_ATTACK_MS, DUCK_RELEASE_MS; print('import ok', DUCK_THRESHOLD)"</automated>
  </verify>
  <done>
    - `from cinecut.conform.audio_mix import mix_four_stems, DUCK_THRESHOLD, DUCK_RATIO, DUCK_ATTACK_MS, DUCK_RELEASE_MS` succeeds
    - `DUCK_THRESHOLD = 0.025`, `DUCK_RATIO = 6.0`, `DUCK_ATTACK_MS = 100`, `DUCK_RELEASE_MS = 600`
    - `mix_four_stems` signature accepts `(concat_path, sfx_mix, vo_clips, music_bed_path, work_dir)`
    - `amix normalize=0` appears in the filtergraph string (inspectable in source)
    - `aresample=48000,aformat=sample_fmts=fltp:channel_layouts=stereo` applied to each stem
    - Three-stem fallback triggered when `music_bed_path is None or not music_bed_path.exists()`
    - `sidechaincompress` uses `DUCK_THRESHOLD`, `DUCK_RATIO`, `DUCK_ATTACK_MS`, `DUCK_RELEASE_MS` constants (not hardcoded literals)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Pass 3 + Pass 4 into conform/pipeline.py and add unit tests</name>
  <files>src/cinecut/conform/pipeline.py, tests/test_sfx_vo_mix.py</files>
  <action>
**Update `conform/pipeline.py`:**

Modify `conform_manifest()` to add Pass 3 (SFX synthesis + VO extraction) and Pass 4 (four-stem audio mix) after the existing Pass 2 (concatenate_clips).

The `conform_manifest()` function currently:
1. Calls `extract_and_grade_clip()` x N (Pass 1)
2. Calls `concatenate_clips()` (Pass 2) → `final_output_path`
3. Returns `final_output_path`

Add two new parameters to `conform_manifest()`:
```python
def conform_manifest(
    manifest: TrailerManifest,
    source: Path,
    work_dir: Path,
    extra_clip_paths: list[Path] | None = None,
    subtitle_path: Path | None = None,   # NEW — for VO extraction; None = skip VO
) -> Path:
```

After `concatenate_clips()` in Pass 2:

**Pass 3 — SFX synthesis and VO extraction:**
```python
# Compute concat duration for SFX positioning
concat_duration_s = sum(c.source_end_s - c.source_start_s for c in manifest.clips)

# Synthesize SFX files (idempotent — skips if already exist)
sfx_hard, sfx_boundary = synthesize_sfx_files(work_dir)

# Overlay SFX at cut positions
sfx_mix = apply_sfx_to_timeline(manifest, sfx_hard, sfx_boundary, work_dir, concat_duration_s)

# Extract VO clips (skip if no subtitle path provided)
vo_clips: list = []
if subtitle_path is not None:
    from cinecut.conform.vo_extract import extract_vo_clips
    vo_clips = extract_vo_clips(manifest, source, subtitle_path, work_dir)
```

**Pass 4 — Four-stem audio mix:**
```python
# Get music bed path from manifest (may be None if Phase 9 unavailable)
music_bed_path: Path | None = None
if manifest.music_bed is not None:
    music_bed_path = Path(manifest.music_bed.local_path)

final_output_path = mix_four_stems(
    concat_path=pass2_concat_path,  # the Pass 2 output (trailer_concat.mp4)
    sfx_mix=sfx_mix,
    vo_clips=vo_clips,
    music_bed_path=music_bed_path,
    work_dir=work_dir,
)
```

Store the Pass 2 output in a local variable (rename from `final_output_path` to `pass2_concat_path`) before Pass 3. Return the Pass 4 output as `final_output_path`.

Add imports at top of pipeline.py:
```python
from cinecut.conform.sfx import synthesize_sfx_files, apply_sfx_to_timeline
from cinecut.conform.audio_mix import mix_four_stems
```

**Create `tests/test_sfx_vo_mix.py`:**

Unit tests (no FFmpeg calls — mock subprocess.run):

```python
"""Unit tests for Phase 10 audio modules — sfx.py, vo_extract.py, audio_mix.py.

All tests mock subprocess.run to avoid FFmpeg calls. Tests verify:
- SFX synthesis idempotency (skips FFmpeg if files already exist)
- Linear chirp formula correctness (slope = (f1-f0)/(2*d))
- Protagonist identification returns None for SRT (no event.name)
- adelay uses milliseconds (not seconds)
- amix normalize=0 in four-stem filtergraph
- Three-stem fallback when music_bed_path is None
"""
from pathlib import Path
from unittest.mock import patch, MagicMock
import pytest
```

Write the following specific tests:

1. **`test_synthesize_sfx_files_idempotent`**: Create fake `sfx_hard.wav` and `sfx_boundary.wav` in `tmp_path/sfx/` before calling `synthesize_sfx_files(tmp_path)`. Assert subprocess.run is NOT called (mock it). Confirms idempotency.

2. **`test_synthesize_sfx_files_chirp_formula`**: Call `synthesize_sfx_files(tmp_path)` with mocked subprocess.run (returncode=0). Inspect the `cmd` arguments passed to subprocess.run. Assert the aevalsrc expression for `sfx_hard.wav` contains `-3375` (the pre-computed slope for 3000→300 over 0.4s: `(300-3000)/(2*0.4) = -3375`). Assert the expression for `sfx_boundary.wav` contains `750` (slope for 200→2000 over 1.2s: `(2000-200)/(2*1.2) = 750`).

3. **`test_identify_protagonist_srt_returns_none`**: Create a fake SRT subtitle using pysubs2 (`SSAFile` with events having empty `.name` fields). Save as `.srt` file. Call `identify_protagonist(path)`. Assert result is `None`.

4. **`test_identify_protagonist_ass_returns_most_frequent`**: Create a fake ASS subtitle with events: HERO appearing 5 times, VILLAIN 2 times. Call `identify_protagonist(path)`. Assert result is `"HERO"`.

5. **`test_adelay_uses_milliseconds`**: In `apply_sfx_to_timeline()`, the adelay value for a clip starting at `t=5.0s` in the trailer timeline should be `5000` (ms), not `5.0` (seconds). Create a minimal two-clip manifest, mock subprocess.run, call `apply_sfx_to_timeline()`, capture the filtergraph string from the cmd arguments, and assert it contains `"5000|5000"` or `"adelay=5000"` (accounting for the 0.1s lead offset: actual delay = `(5.0 - 0.4/4)*1000 = 4900ms`).

6. **`test_mix_four_stems_normalize_zero`**: Mock subprocess.run (returncode=0). Create minimal input paths. Call `mix_four_stems(...)` with a music_bed_path that exists (touch a file). Inspect all subprocess.run calls. Assert at least one call contains `"normalize=0"` in its cmd list (the filtergraph argument). Assert NO call contains `"normalize=1"`.

7. **`test_mix_four_stems_no_music_three_stem_fallback`**: Call `mix_four_stems(...)` with `music_bed_path=None`. Assert subprocess.run is called with `"amix=inputs=3"` in the filtergraph (three-stem mode), not `"amix=inputs=4"`. Assert `"sidechaincompress"` does NOT appear in any cmd.

Use `pytest.fixture` for `tmp_path` (built-in). Use `unittest.mock.patch("cinecut.conform.sfx.subprocess.run")`, `patch("cinecut.conform.audio_mix.subprocess.run")` etc. for isolation.
  </action>
  <verify>
    <automated>cd /home/adamh/ai-video-trailer && python -m pytest tests/test_sfx_vo_mix.py -v --tb=short 2>&1 | tail -20</automated>
  </verify>
  <done>
    - `tests/test_sfx_vo_mix.py` runs with all 7 tests passing
    - `conform_manifest()` has new `subtitle_path: Path | None = None` parameter (backward-compatible)
    - Pass 3 calls `synthesize_sfx_files()` and `apply_sfx_to_timeline()` after Pass 2
    - Pass 4 calls `mix_four_stems()` and returns its output as the final path
    - `python -m pytest tests/ -x -q --tb=short` passes (no regressions)
    - `mix_four_stems` is imported in pipeline.py at module level
    - `normalize=0` test asserts FFmpeg filtergraph never uses `normalize=1`
    - Three-stem fallback test passes when `music_bed_path=None`
  </done>
</task>

</tasks>

<verification>
Run from `/home/adamh/ai-video-trailer`:
```bash
python -m pytest tests/test_sfx_vo_mix.py -v --tb=short
python -m pytest tests/ -x -q --tb=short 2>&1 | tail -15
python -c "from cinecut.conform.pipeline import conform_manifest; import inspect; print([p for p in inspect.signature(conform_manifest).parameters])"
```
All 7 new tests pass, no regressions in existing test suite, `subtitle_path` appears in `conform_manifest` signature.
</verification>

<success_criteria>
- `src/cinecut/conform/audio_mix.py` exists with `mix_four_stems`, ducking constants exported
- `conform/pipeline.py` has Pass 3 (SFX+VO) and Pass 4 (audio mix) wired after Pass 2
- `conform_manifest()` accepts `subtitle_path: Path | None = None` (backward-compatible)
- `amix normalize=0` used throughout — confirmed by unit test
- Three-stem fallback when music absent — confirmed by unit test
- `sidechaincompress` uses named constants `DUCK_THRESHOLD`, `DUCK_RATIO`, `DUCK_ATTACK_MS`, `DUCK_RELEASE_MS`
- `tests/test_sfx_vo_mix.py`: 7 tests pass covering idempotency, chirp formula, None protagonist, adelay ms, normalize=0, three-stem fallback
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/10-sfx-vo-and-audio-mix/10-03-SUMMARY.md`
</output>
