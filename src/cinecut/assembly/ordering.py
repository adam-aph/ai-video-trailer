"""3-act clip ordering and pacing curve enforcement for trailer assembly."""
from cinecut.manifest.schema import ClipEntry, TrailerManifest
from cinecut.manifest.vibes import VibeProfile

# Canonical act sequence for a trailer.
# title_card and button are generated segments — NOT present in the input clips list.
ACT_ORDER = [
    "cold_open",
    "act1",
    "beat_drop",
    "act2",
    "breath",
    "act3",
]

MIN_CLIP_DURATION_S = 0.5  # Never trim below 0.5s to avoid empty clips


def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort clips into canonical 3-act trailer order.

    Within the same act, preserve chronological order (source_start_s ascending).
    Does NOT include title_card or button — those are generated by title_card.py.
    """
    act_priority = {act: i for i, act in enumerate(ACT_ORDER)}
    return sorted(
        clips,
        key=lambda c: (act_priority.get(c.act, 999), c.source_start_s),
    )


def compute_act_avg_duration(clips: list[ClipEntry], act: str) -> float:
    """Return mean clip duration for a specific act. Returns 0.0 if no clips for that act."""
    act_clips = [c for c in clips if c.act == act]
    if not act_clips:
        return 0.0
    return sum(c.source_end_s - c.source_start_s for c in act_clips) / len(act_clips)


def enforce_pacing_curve(
    clips: list[ClipEntry],
    profile: VibeProfile,
) -> list[ClipEntry]:
    """Trim act3 clips to enforce measurable pacing curve (act1_avg > act3_avg).

    If measured act3 average duration exceeds profile.act3_avg_cut_s * 1.5,
    each act3 clip is trimmed to profile.act3_avg_cut_s by adjusting source_end_s.
    Uses model_copy() (Pydantic v2) since ClipEntry is a BaseModel.
    Minimum clip duration: MIN_CLIP_DURATION_S (0.5s) — never trim below this.
    """
    result = list(clips)
    measured_act3_avg = compute_act_avg_duration(result, "act3")
    if measured_act3_avg <= profile.act3_avg_cut_s * 1.5:
        return result  # Already within acceptable range — no trimming needed

    for i, clip in enumerate(result):
        if clip.act == "act3":
            duration = clip.source_end_s - clip.source_start_s
            target = profile.act3_avg_cut_s
            if duration > target * 1.5:
                new_end = clip.source_start_s + max(target, MIN_CLIP_DURATION_S)
                result[i] = clip.model_copy(update={"source_end_s": new_end})
    return result
