"""3-act clip ordering and pacing curve enforcement for trailer assembly."""
from cinecut.manifest.schema import ClipEntry, NarrativeZone, TrailerManifest
from cinecut.manifest.vibes import VibeProfile

# Canonical act sequence for a trailer.
# title_card and button are generated segments — NOT present in the input clips list.
ACT_ORDER = [
    "cold_open",
    "act1",
    "beat_drop",
    "act2",
    "breath",
    "act3",
]

MIN_CLIP_DURATION_S = 0.5  # Never trim below 0.5s to avoid empty clips

# Zone ordering priority for zone-first assembly (EORD-01).
# title_card and button clips have narrative_zone=None — they fall to priority 999.
ZONE_ORDER: dict[NarrativeZone, int] = {
    NarrativeZone.BEGINNING: 0,
    NarrativeZone.ESCALATION: 1,
    NarrativeZone.CLIMAX: 2,
}


def sort_clips_by_act(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort clips into canonical 3-act trailer order.

    Within the same act, preserve chronological order (source_start_s ascending).
    Does NOT include title_card or button — those are generated by title_card.py.
    """
    act_priority = {act: i for i, act in enumerate(ACT_ORDER)}
    return sorted(
        clips,
        key=lambda c: (act_priority.get(c.act, 999), c.source_start_s),
    )


def sort_clips_by_zone(clips: list[ClipEntry]) -> list[ClipEntry]:
    """Sort clips into zone-first order: BEGINNING → ESCALATION → CLIMAX (EORD-01).

    Within each zone, sort by money_shot_score descending (EORD-02).
    Clips with narrative_zone=None (title_card, button, or unassigned) sort last.

    Replaces sort_clips_by_act() as the primary ordering function for v2.0 pipeline.
    sort_clips_by_act() is preserved for backward compatibility and tests.

    Zone-first ordering is the core narrative claim of v2.0:
      trailer arc = BEGINNING → ESCALATION → CLIMAX, NOT film chronology.
    """
    return sorted(
        clips,
        key=lambda c: (
            ZONE_ORDER.get(c.narrative_zone, 999) if c.narrative_zone is not None else 999,
            -(c.money_shot_score or 0.0),    # score descending within zone (negate for ascending sort)
        ),
    )


def compute_act_avg_duration(clips: list[ClipEntry], act: str) -> float:
    """Return mean clip duration for a specific act. Returns 0.0 if no clips for that act."""
    act_clips = [c for c in clips if c.act == act]
    if not act_clips:
        return 0.0
    return sum(c.source_end_s - c.source_start_s for c in act_clips) / len(act_clips)


def enforce_pacing_curve(
    clips: list[ClipEntry],
    profile: VibeProfile,
) -> list[ClipEntry]:
    """Trim act3 clips to enforce measurable pacing curve (act1_avg > act3_avg).

    If measured act3 average duration exceeds profile.act3_avg_cut_s * 1.5,
    each act3 clip is trimmed to profile.act3_avg_cut_s by adjusting source_end_s.
    Uses model_copy() (Pydantic v2) since ClipEntry is a BaseModel.
    Minimum clip duration: MIN_CLIP_DURATION_S (0.5s) — never trim below this.
    """
    result = list(clips)
    measured_act3_avg = compute_act_avg_duration(result, "act3")
    if measured_act3_avg <= profile.act3_avg_cut_s * 1.5:
        return result  # Already within acceptable range — no trimming needed

    for i, clip in enumerate(result):
        if clip.act == "act3":
            duration = clip.source_end_s - clip.source_start_s
            target = profile.act3_avg_cut_s
            if duration > target * 1.5:
                new_end = clip.source_start_s + max(target, MIN_CLIP_DURATION_S)
                result[i] = clip.model_copy(update={"source_end_s": new_end})
    return result


def enforce_zone_pacing_curve(
    clips: list[ClipEntry],
    profile: VibeProfile,
) -> list[ClipEntry]:
    """Trim CLIMAX zone clips to act3 duration targets (EORD-03).

    BEGINNING zone clips use act1_avg_cut_s — long cuts are fine for setup.
    ESCALATION zone clips use act2_avg_cut_s (enforced implicitly via clip window).
    CLIMAX zone clips are trimmed if average exceeds profile.act3_avg_cut_s * 1.5.

    Clips with narrative_zone=None are left untouched (treated as ESCALATION duration).
    Uses model_copy() (Pydantic v2) — same pattern as enforce_pacing_curve.
    Minimum clip duration: MIN_CLIP_DURATION_S (0.5s) — never trim below this.

    Does NOT modify BEGINNING zone clips — act1 targets allow longer cuts (4-8s range
    per EORD-03). Does NOT modify ESCALATION clips — act2 targets applied at window
    computation time in generator.py.
    """
    result = list(clips)

    # Compute CLIMAX zone average duration
    climax_clips = [c for c in result if c.narrative_zone == NarrativeZone.CLIMAX]
    if not climax_clips:
        return result  # No CLIMAX clips — nothing to enforce

    climax_avg = sum(c.source_end_s - c.source_start_s for c in climax_clips) / len(climax_clips)
    if climax_avg <= profile.act3_avg_cut_s * 1.5:
        return result  # Already within acceptable range

    # Trim CLIMAX clips that exceed 1.5x target
    target = profile.act3_avg_cut_s
    for i, clip in enumerate(result):
        if clip.narrative_zone == NarrativeZone.CLIMAX:
            duration = clip.source_end_s - clip.source_start_s
            if duration > target * 1.5:
                new_end = clip.source_start_s + max(target, MIN_CLIP_DURATION_S)
                result[i] = clip.model_copy(update={"source_end_s": new_end})

    return result
